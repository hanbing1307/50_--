# 一、HTML
## 1、语义化标签
    header：定义文档的页眉（头部）；
    nav：定义导航链接的部分；
    artical：定义文章内容；
    section：定义文档中的节（section、区段）；
    aside：定义其所处内容之外的内容（侧边）
    footer：定义文档或节的页脚（底部）

## 2、音频、视频标签
    音频标签：audio   src=“url路径”     controls: 控件      autoplay：自动播放  loop：循环播放
    视频标签：video  src=“url路径” width=“100px” height=“100px“ autoplay：自动播放  loop：循环播放
            preload=none/auto预加载（选择autoplay之后忽略这一项）
            poster=”等待加载的图片url“  muted：静音播放

## 3、src和href的区别
    src 用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。

    （1）src
        src 是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 frame 等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js 脚本放在底部而不是头部。

    （2）href
        href 是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果在文档中添加 那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止对当前文档的处理。 这也是为什么建议使用 link 方式来加载 css，而不是使用@import 方式。

## 4、对HTML语义化的理解
    语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。通俗来讲就是用正确的标签做正确的事情。
    语义化的优点如下：
        - 对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；
        - 对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。

## 5、DOCTYPE(⽂档类型) 的作用
    DOCTYPE是文档类型声明，它的目的是告诉浏览器（解析器）应该以什么样（html或xhtml）的模式来渲染文档。它必须声明在HTML⽂档的第⼀⾏。
    浏览器渲染页面的两种模式（可通过document.compatMode获取，比如，语雀官网的文档类型是CSS1Compat）：
        - CSS1Compat：标准模式（Strick mode），默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。
        - BackCompat：怪异模式(混杂模式)(Quick mode)，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。

## 6、script标签中defer和async的区别
    如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。使用defer和async都会使得解析HTML的同时进行js脚本的异步下载，不会阻碍文档的解析，区别是，async在下载完js脚本之后立即执行js，有可能会阻碍文档的解析，且多个标记async的js脚本可能不会按照顺序执行；使用defer会在html解析完成之后再执行js脚本文件，而且多个defer的脚本会按照顺序执行。

## 7、常⽤的meta标签有哪些
    meta 标签由 name 和 content 属性定义，用来描述网页文档的属性，比如网页的作者，网页描述，关键词等
        常用的meta标签：
        （1）charset，用来描述HTML文档的编码类型：<meta charset="UTF-8" >
        （2） keywords，页面关键词：
            <meta name="keywords" content="关键词" />
        （3）description，页面描述：
            <meta name="description" content="页面描述内容" />
        （4）refresh，页面重定向和刷新：
            <meta http-equiv="refresh" content="0;url=" />
        （5）viewport，适配移动端，可以控制视口的大小和比例：
            <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
            其中，content 参数有以下几种：
                ● width viewport ：宽度(数值/device-width)
                ● height viewport ：高度(数值/device-height)
                ● initial-scale ：初始缩放比例
                ● maximum-scale ：最大缩放比例
                ● minimum-scale ：最小缩放比例
                ● user-scalable ：是否允许用户缩放(yes/no）
        （6）搜索引擎索引方式：
            <meta name="robots" content="index,follow" />
            其中，content 参数有以下几种：
                ● all：文件将被检索，且页面上的链接可以被查询；
                ● none：文件将不被检索，且页面上的链接不可以被查询；
                ● index：文件将被检索；
                ● follow：页面上的链接可以被查询；
                ● noindex：文件将不被检索；
                ● nofollow：页面上的链接不可以被查询。

## 8、HTML5有哪些更新
    语义化标签header、nav、artical、section、aside、footer
    媒体标签audio <audio src='' controls autoplay loop='true'></audio>
    Video  <video src='' poster='imgs/aa.jpg' “controls></video>
    source标签：因为浏览器对视频格式支持程度不一样，为了能够兼容不同的浏览器，可以通过source来指定视频源。
    表单
        表单类型
            tel、search、number、email、url、date、time、month、week、color、
        表单属性
            required、autofocus、autocomplate、multiple、pattern、form
        表单事件
            oninput：每当input里的输入框内容发生变化都会触发此事件。
            oninvalid：当验证不通过时触发此事件。
    进度条、度量器
        进度条：progress标签：用来表示任务的进度（IE、Safari不支持），max用来表示任务的进度，value表示已完成多少
        度量器 ● meter属性：用来显示剩余容量或剩余库存（IE、Safari不支持）
            ○ high/low：规定被视作高/低的范围
            ○ max/min：规定最大/小值
            ○ value：规定当前度量值    设置规则：min < low < high < max	
    DOM查询操作:它们选择的对象可以是标签，可以是类(需要加点)，可以是ID(需要加#)
            document.querySelector(‘’“)
            document.querySelectorAll(‘’”)
    Web存储
        sessionStorage：针对一个 session 的数据存储（会话存储：关闭页面会消失）
        localStorage：没有时间限制的数据存储（本地存储：关闭页面不会消失）
    history API
        history.go(num)（前进或后退,可正可负）
        history.forward(num)（前进）
        history.back（num）（后退）
        pushstate
    其他
        拖放：<img draggable="true" />
        画布（canvas ）：canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 <canvas id="myCanvas" width="200" height="100"></canvas>
        SVG：SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准
        地理定位：Geolocation（地理定位）用于定位用户的位置。

## 9、img的srcset属性的作用？
    响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。<img src="image-128.png" srcset="image-256.png 2x" />使用上面的代码，就能实现在屏幕密度为1x的情况下加载image-128.png, 屏幕密度为2x时加载image-256.png。

    按照上面的实现，不同的屏幕密度都要设置图片地址，目前的屏幕密度有1x,2x,3x,4x四种，如果每一个图片都设置4张图片，加载就会很慢。所以就有了新的srcset标准。代码如下：
        <img src="image-128.png"
            srcset="image-128.png 128w, image-256.png 256w, image-512.png 512w"
            sizes="(max-width: 360px) 340px, 128px" />
    其中srcset指定图片的地址和对应的图片质量。sizes用来设置图片的尺寸零界点。对于 srcset 中的 w 单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用。浏览器会自动选择一个最小的可用图片。
    sizes语法如下：
        sizes="[media query] [length], [media query] [length] ... "
        sizes就是指默认显示128px, 如果视区宽度大于360px, 则显示340px。

## 10、行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？
        行内元素：span、a、img、input、strong、em、del、ins
        块级元素：div、h1~h6、p、ul、li、ol、dl、dt、dd、header、nav、artical、section、aside、footer
        空元素（没有闭合）：img、input、br、hr、link、meta

## 11、对 web worker 的理解
    JavaScript 语言采用的是单线程模型，Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。
    JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。
    Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。

    如何创建 web worker： 
        1. 检测浏览器对于 web worker 的支持性 
        2. 创建 web worker 文件（js，回传函数等） 
        3. 创建 web worker 对象

## 12、HTML5的离线储存怎么使用，它的工作原理是什么
    离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。
    原理：HTML5的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示
        使用方法：
        （1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：
        <html lang="en" manifest="index.manifest">
        （2）在 cache.manifest 文件中编写需要离线存储的资源：
        CACHE MANIFEST
            #v0.11
            CACHE:
            js/app.js
            css/style.css
            NETWORK:
            resourse/logo.png
            FALLBACK:
            / /offline.html
        ● CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。
        ● NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。
        ● FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。
        （3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。
        如何更新缓存：
         （1）更新 manifest 文件
         （2）通过 javascript 操作
         （3）清除浏览器缓存
        注意事项：
         （1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。
         （2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。
         （3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。
         （4）FALLBACK 中的资源必须和 manifest 文件同源。
         （5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。
         （6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。
         （7）当 manifest 文件发生改变时，资源请求本身也会触发更新。

## 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？
        在线情况下：浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件。第一次访问页面，会根据manidest内容下载相应资源并存储，不是第一次根据离线资源加载页面，并对比新旧manifest，未改变不做修改，改变了下载新的资源并进行存储

        离线情况下：加载离线资源

## title与h1的区别、b与strong的区别、i与em的区别？
        strong标签有语义，是起到加重语气的效果，而b标签是没有的，b标签只是一个简单加粗标签。b标签之间的字符都设为粗体，strong标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重strong标签。
        title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取有很大的影响
        i内容展示为斜体，em表示强调的文本

## iframe标签 有那些优点和缺点？
    iframe作用：iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。
        优点:
            ● 用来加载速度较慢的内容（如广告）
            ● 可以使脚本可以并行下载
            ● 可以实现跨子域通信
        缺点：
            ● iframe 会阻塞主页面的 onload 事件
            ● 无法被一些搜索引擎索识别
            ● 会产生很多页面，不容易管理

    label 的作用是什么？如何使用？
    作用：label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。

    使用方法：<label for="mobile">Number:</label>
    <input type="text" id="mobile"/>

## Canvas和SVG的区别
    SVG
        SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。
        其特点如下：
            ● 不依赖分辨率
            ● 支持事件处理器
            ● 最适合带有大型渲染区域的应用程序（比如谷歌地图）
            ● 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）
            ● 不适合游戏应用
    Canvas
        Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。
        其特点如下：
            ● 依赖分辨率
            ● 不支持事件处理器
            ● 弱的文本渲染能力
            ● 能够以 .png 或 .jpg 格式保存结果图像
            ● 最适合图像密集型的游戏，其中的许多对象会被频繁重绘
## head 标签有什么作用，其中什么标签必不可少？
        作用：<head> 标签用于定义文档的头部，它是所有头部元素的容器。<head> 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。
        可包含的标签：下面这些标签可用在 head 部分：<base>, <link>, <meta>, <script>, <style>, <title>。 其中只有title是必须的

## 文档声明（Doctype）和<!Doctype html>有何作用? 严格模式与混杂模式如何区分？它们有何意义?
        文档声明的作用：文档声明是为了告诉浏览器，当前HTML文档使用什么版本的HTML来写的，这样浏览器才能按照声明的版本来正确的解析。
        <!Doctype html>的作用：<!doctype html> 的作用就是让浏览器进入标准模式，使用最新的 HTML5 标准来解析渲染页面；如果不写，浏览器就会进入混杂模式，我们需要避免此类情况发生。

## 严格模式与混杂模式的区分：
        ● 严格模式： 又称为标准模式，指浏览器按照W3C标准解析代码；
        ● 混杂模式： 又称怪异模式、兼容模式，是指浏览器用自己的方式解析代码。混杂模式通常模拟老式浏览器的行为，以防止老站点无法工作；
        区分：网页中的DTD，直接影响到使用的是严格模式还是浏览模式，可以说DTD的使用与这两种方式的区别息息相关。
        ● 如果文档包含严格的DOCTYPE ，那么它一般以严格模式呈现（严格 DTD ——严格模式）；
        ● 包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式）；
        ● DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现（DTD不存在或者格式不正确——混杂模式）；
        ● HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的 法，实现时，已经尽可能大的实现了向后兼容(HTML5 没有严格和混杂之分)。
        总之，严格模式让各个浏览器统一执行一套规范兼容模式保证了旧网站的正常运行。

## 浏览器乱码的原因是什么？如何解决？
        产生乱码的原因：                                                                       ● 网页源代码是gbk的编码，而内容中的中文字是utf-8编码的，这样浏览器打开即会出现html乱码，反之也会出现乱码；
        ● html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码；
        ● 浏览器不能自动检测网页编码，造成网页乱码。
        解决方式：                                                                                  ● 使用软件编辑HTML网页内容；
        ● 如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进行程序转码；
        ● 如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换。

## 渐进增强和优雅降级之间的区别
        两者区别：
        ● 优雅降级是从复杂的现状开始的，并试图减少用户体验的供给；而渐进增强是从一个非常基础的，能够起作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要；
        ● 降级（功能衰竭）意味着往回看，而渐进增强则意味着往前看，同时保证其根基处于安全地带。
        “优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。 
        “渐进增强”观点则认为应关注于内容本身。内容是建立网站的诱因，有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。 

        渐进增强：主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验。
        优雅降级：一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。

## 说一下 HTML5 drag API （拖放）
    dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。
    drag：事件主体是被拖放元素，在正在拖放被拖放元素时触发。
    dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。 
    dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。
    dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。
    drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。在一个拖动过程中，释放鼠标键时触发此事件
    dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。

## html与XML
        html是超文本标记语言，是一种描述性语言，用html可以创建能在互联网上传输的信息页，是构成网页文档的主要内容，由很多标签组成

        XML可扩展标记语言，是互联网环境中跨平台、基于内容的技术，是当前处理结构类文档信息的强有力的工具，适合作为各种存储与共享的通用平台，是对html的补充

## 元素类型
        块级元素
            特点
                自己独占一行
                可以设置宽度、高度、内外边距，默认高度与父亲一致
                容器内可以放行内块元素或者块级元素（文字类的元素内不能放块级元素）
        行内元素
            相邻的行内元素一行显示多个
            不能设置宽度和高度，默认的宽度和高度就是它自身的高度和宽度
            行内元素内部只能放文本或者行内元素（a可以放块级元素）
        行内块元素
            一行可以显示多个行内块元素，而且行内块元素之间有间隔
            默认宽度和高度是自身的宽度和高度
            可以设置宽度和高度、内外边距

# CSS面试题
## CSS选择器及优先级
    选择器
        1.基础选择器：通配符选择器 标签选择器/元素选择器 类选择器  id选择器
        2.复合选择器
            后代选择器：格式：父级 子级{属性:属性值;属性:属性值;}
                .class h3{color:red;font-size:16px;}
            子代选择器 .class>h3{color:red;font-size:14px;}
            交集选择器 h3.class{ color:red; }
                其中第一个为标签选择器，第二个为class选择器，两个选择器之间不能有空格，如h3.special。
                交集选择器 是 并且的意思。 即...又...的意思
            并集选择器 .class,h3 {color:red;}
                并集选择器通常用于集体声明 ，逗号隔开的，所有选择器都会执行后面样式，逗	号可以理解为 和的意思。
                链接伪类选择器 a:link a:hover

        3.新增选择器
            属性选择器
                E[att]     	    选择具有att属性的E元素
                E[att="val"]   	选择具有att属性且属性值等于val的E元素
                E[att^="val"]     	匹配具有att属性且值以val开头的E元素
                E[att$="val"]     	匹配具有att属性且值以val结尾的E元素
                E[att*="val“]	    匹配具有att属性且值中含有val的E元素
            结构伪类选择器
                E:first-child	匹配父元素中的第一个子元素E
                E:last-child	匹配父元素中最后一个E元素
                E:nth-child(n)	匹配父元素中的第n个子元素E
                E:first-of-type	 指定类型E的第一个
                E:last-of-type	指定类型E的最后一个
                E:nth-of-type(n)	指定类型E的第n个

                nth-child的序号是固定的，从第一个孩子顺序排列下来
                nth-of-type而是按照元素 类型开始排序的，先去找队员的元素类型，再去找对应的顺序
            伪元素选择器
                before和after创建一个元素 ,但是属于行内元素
                新创建的这个元素在文档树中是找不到的,所以我们称为伪元素
                语法: element::before 
                before和after必须有content属性
                before在父元素内容的前面创建元素, after 在父元素内容的后面插入元素
                伪元素选择器和标签选择器一 样,权重为1

                优先级
                    0：通配符选择器（继承）
                    1：标签选择器、伪元素选择器
                    10：类选择器、属性选择器、结构伪类选择器
                    100：id选择器
                    1000：内联样式
                    无穷大：！important
                    需计算累加权重：复合选择器
            注意
                !important声明的样式的优先级最高；
                如果优先级相同，则最后出现的样式生效；
                继承得到的样式的优先级最低；
                通用选择器（*）、子选择器（>）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0 ；
                样式表的来源不同时，优先级顺序为：内联样式 > 内部样式 > 外部样式 > 浏览器用户自定义样式 > 浏览器默认样式。
## CSS中可继承与不可继承属性有哪些
            不可继承属性
                display：元素的显示模式（块级、行内元素、行内块）
                文本属性
                    vertical-align：垂直对齐方式
                    text-decoration：规定添加到文本的装饰
    （underline-line、line-through、overline）
                    text-shadow：文本阴影效果
                    white-space：空白符的处理
                    unicode-bidi：设置文本的方向
                盒子模型的属性
                    border  margin  padding  width  height

                    背景属性
                    background、background-color、background-image、background-repeat、				background-position、background-attachment
                    定位属性
                    float、clear、position、top、right、bottom、left、min-width、min-height、				max-width、max-height、overflow、clip、z-index
                    生成内容属性
                        content、counter-reset、counter-increment
                    轮廓样式属性
                        outline-style、outline-width、outline-color、outline
                    页面样式属性
                        size、page-break-before、page-break-after
                    声音样式属性
                    pause-before、pause-after、pause、cue-before、cue-after、cue,play-during
            可继承属性
                字体系列属性
                    font-family
                    font-size
                    font-weight（normal、bold）
                    font-style（normal、italic）
                文本系列属性
                    text-align：文本水平对齐
                    text-indent：文本缩进
                    line-height：行高
                    word-spacing：单词之间的间距
                    letter-spacing：中文或者字母之间的间距
                    text-transform：控制文本大小写（uppercase、lowercase、capitalize）
                    color：文本颜色
                元素可见性
                    visibility：控制元素显示隐藏
                列表布局属性
                    list-style：列表风格，包括list-style-type、list-style-image等
                光标属性
                    cursor：光标显示为何种形态
## display的属性值及其作用
            none：元素不显示，并且会从文档流中移除。
            block：元素显示/块类型。默认宽度为父元素宽度，可设置宽高，换行显示。
            inline：行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。
            inline-block：行内块元素类型。默认宽度为内容宽度，可以设置宽高，
    同行显示（有间隙）。
            list-item：像块类型元素一样显示，并添加样式列表标记。
            table：此元素会作为块级表格来显示。
            inherit：规定应该从父元素继承display属性的值。

        display的block、inline和inline-block的区别
            block：块级元素类型
                独占一行，多个元素换行显示
                可以设置宽度、高度、border、padding、margin
            inline：行内元素类型
                一行显示多个
                不可以设置宽度、高度
                可设置水平方向的padding和margin，不可以设置垂直方向的padding和margin
            inline-block：行内块元素类型
                一行内显示多个，且有间隙，默认宽度为内容的宽度
                可以设置宽度和高度
        隐藏元素的方法有哪些
            display：none
                渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置
            visibility：hidden
                元素在页面中仍占据空间
            opacity: 0
                将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间
            position: absolute
                通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。
            z-index: 负值
                来使其他元素遮盖住该元素，以此来实现隐藏。
            clip/clip-path
                使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置
            transform: scale(0,0)
                将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置

## display:none与visibility:hidden的区别
        这两个属性都是让元素隐藏，不可见。两者区别如下：
    在渲染树中display:none会让元素完全从渲染树中消失，渲染时不会占据任何空间；
    visibility:hidden不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。
        是否是继承属性:
            display:none是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；
            visibility:hidden是继承属性，子孙节点消失是由于继承了hidden，通过设置visibility:visible可以让子孙节点显示；
            修改常规文档流中元素的 display 通常会造成文档的重排，但是修改visibility属性只会造成本元素的重绘；
            如果使用读屏器，设置为display:none的内容不会被读取，设置为visibility:hidden的内容会被读取。

## link和@import的区别
    两者都是外部引用CSS的方式，它们的区别如下：
                link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。
                link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。
                link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。
                link支持使用Javascript控制DOM去改变样式；而@import不支持。
## transition和animation的区别
            transition是过渡属性
                强调过渡，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。
            animation是动画属性
                它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。
## 伪元素和伪类的区别和作用？
            伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。
            伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。
## 对盒模型的理解
            两种盒模型（box-sizing），但是都包含content、padding、border、margin
                box-sizing：content-box 盒子大小为width+padding+border（以前默认的，会撑大盒子）
                box-sizing：border-box 盒子大小为width
    如果盒子模型我们改为了box-sizing：border-box，那padding和border就不会撑大盒子了（前提padding和border不会超过width宽度）
    为什么有时候⽤translate来改变位置⽽不是定位？
            translate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。 ⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。translate不会影响其他元素的位置，而绝对定位会脱标，从而影响其他元素的位置
## li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？
    原因：浏览器会把inline内联元素间的空白字符（空格、换行、Tab等）渲染成一个空格。为了美观，通常是一个<li>放在一行，这导致<li>换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。

    解决办法：
        （1）为<li>设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。
        （2）将所有<li>写在同一行。不足：代码不美观。
        （3）将<ul>内的字符尺寸直接设为0，即font-size:0。不足：<ul>中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。
        （4）消除<ul>的字符间隔letter-spacing:-8px，不足：这也设置了<li>内的字符间隔，因此需要将<li>内的字符间隔设为默认letter-spacing:normal。
## CSS3中有哪些新特性
    新增选择器
        属性选择器
        结构伪类选择器
        伪元素选择器
    2D转换：transform
        位移：transform：translate（100px，100px）
        缩放：transform：scale（1，1）
        旋转：transform：rotate（45deg）
    3D转换：transform
        位移：transform：translate（100px，100px，100px）
        旋转：transform：rotate（0，0，1，45deg）
        3D呈现：transform-style
            flat：子元素不开启3d空间
            preserve-3d：子元素开启3d空间
        透视：perspective（单位px）
            人的眼睛到屏幕的距离；近大远小。
    动画  @keyframes 动画名称 {0% {width：100px} 100% {width：200px}}
    过渡：transition  谁过度给谁加
    其他特性
        背景渐变background：linear-gradient（top left，red，pink）
        图片模糊：filter：blur（5px）数值越大越模糊
        calc函数：width：calc（100% - 80px）
        圆角：border-radius
        文字特效 （text-shadow）
        文字渲染 （text-decoration）
## 常见的图片格式和适用场景
    BMP
        是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。
    GIF
        是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。
    JPEG
        是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。

    PNG-8
        是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。
    PNG-24
        是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。
    SVG
        是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。
    WebP
        是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。
        ● 在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；
        ● 在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；
        ● WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。

## 对 CSSSprite 的理解
    CSSSprite（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。
    优点
        利用CSS Sprite能很好地减少网页的http请求，从而大大提高了页面的性能，这是CSS Sprite最大的优点；
        CSS Sprite能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。
    缺点
        在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；
        CSSSprite在开发的时候相对来说有点麻烦，需要借助photoshop或其他工具来对每个背景单元测量其准确的位置。
        维护方面：CSS Sprite在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的CSS，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动CSS。

## 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？
    物理像素：指的是设备屏幕实际拥有的像素点。一个设备生产出来，它的像素就已经确定了，iphone6的分辨率是375px * 667px。
    逻辑像素：是我们进行CSS样式设计时的一种抽象单位，它可以自动在不同设备之间调节。
    像素密度/设备像素比：设备的物理像素 / CSS像素
    对于一张50px*50px的图片，在手机Retina屏中打开，按照刚才的物理像素比会放大倍数，这样会造成图片模糊
    也就是说当我们需要一个50px*50px的图片的时候，放到手机上会显示100*100的，图片放大会模糊，可以准备一个原本就是100*100的图片，把他缩小到50*50，那么在手机上即使放大，也不会出现模糊的问题。移动端开发时需要用到@3x, @2x这种图片目的是使图片分辨率高一些，不失真
## margin 和 padding 的使用场景
            需要在border外侧添加空白，使用 margin；
            需要在border内测添加空白，使用 padding。
## 对line-height 的理解及其赋值方式
    line-height的概念：
    line-height 指一行文本的高度，包含了字间距，上间距、下间距，实际上是下一行基线到上一行基线距离；
    如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；
    一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；
            把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；
            line-height 和 height 都能撑开一个高度；
        line-height 的赋值方式：
            带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高
            纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，					则子元素行高为 1.5 * 18 = 27px
            百分比：将计算后的值传递给后代
## CSS 优化和提高性能的方法有哪些？
    加载性能
        css压缩：将写好的css进行打包压缩，可以减小文件体积。
        css单一样式：当需要下边距和左边距的时候，很多时候会选择使用 margin:top 0 bottom 0；但margin-bottom:bottom;margin-left:left;执行效率会更高。
        减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。
    选择器性能
        关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；
        如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。
        避免使用通配规则，如*{}计算次数惊人，只对需要用到的元素进行选择。
        尽量少的去对标签进行选择，而是用class。
        尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。
        了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。
    渲染性能
        慎重使用高性能属性：浮动、定位。
        尽量减少页面重排、重绘。
        去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。
        属性值为0时，不加单位。
        属性值为浮动小数0.**，可以省略小数点之前的0。
        标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。
        不使用@import前缀，它会影响css的加载速度。
        选择器优化嵌套，尽量避免层级过深。
        css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。
        正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。
        不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。
    可维护性、健壮性
        将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。
        样式与内容分离：将css代码定义到外部css中。
## CSS预处理器/后处理器是什么？为什么要使用它们？
            预处理器：less，sass，stylus，用来预编译。sass或者less，增加了css代码的复用性。层级，mixin， 变量，循环， 函数等对编写以及开发UI组件都极为方便。
                css预处理器为css增加一些编程特性，无需考虑浏览器的兼容问题，可以在CSS中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让css更加的简洁，增加适应性以及可读性，可维护性等。
            后处理器， 如： postCss，通常是在完成的样式表中根据css规范处理css，让其更加有效。目前最常做的是给css属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。
            使用原因
                结构清晰， 便于扩展
                可以很方便的屏蔽浏览器私有语法的差异
                可以轻松实现多重继承
                完美的兼容了CSS代码，可以应用到老项目中
## Sass、Less 是什么？为什么要使用他们？ 
    他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，Less 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。

    为什么要使用
        结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。 
        可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。
## ::before 和 :after 的双冒号和单冒号有什么区别？
            单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。
            ::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。
            注意:before 和 :after 这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before、::after。
## display:inline-block 什么时候会显示间隙？
            有空格时会有间隙，可以删除空格解决；
            margin正值时，可以让margin使用负值解决；
            使用font-size时，可通过设置font-size:0、letter-spacing（字母间距）、word-spacing（单词间距，中文无效）解决；
## 单行、多行文本溢出隐藏
    单行文本溢出
        white-space：nowrap；overflow：hidden；text-hidden：ellipsis；
    多行文本溢出
        overflow：hidden；text-hidden：ellipsis；display:-webkit-box;（作为弹性伸缩盒子模型显示）-webkit-box-orient:vertical; （ 设置伸缩盒子的子元素排列方式：从上到下垂直排列）-webkit-line-clamp:3;       （ 显示的行数）
## 对媒体查询的理解？
            使用 @media 查询，可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是需要设置设计响应式的页面，@media 是非常有用的。当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。
## 对 CSS 工程化的理解
    CSS 工程化是为了解决以下问题
        宏观设计：CSS 代码如何组织、如何拆分、模块结构怎样设计？
        编码优化：怎样写出更好的 CSS？
        构建：如何处理我的 CSS，才能让它的打包结果最优？
        可维护性：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？
    以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践
        预处理器：Less、 Sass 等；
        重要的工程化插件： PostCss；
        Webpack loader 等 。
## 如何判断元素是否到达可视区域 
    window.innerHeight 是浏览器可视区的高度；
    document.body.scrollTop || document.documentElement.scrollTop 是浏览器滚动的过的距离；
    imgs.offsetTop 是元素顶部距离文档顶部的高度（包括滚动条的距离）；
    内容达到显示区域的：img.offsetTop < window.innerHeight + document.body.scrollTop;
## z-index属性在什么情况下会失效
    通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。
    z-index属性在下列情况下会失效
        父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；
        元素没有设置position属性为非static属性，解决：设置该元素的position属性为relative，absolute或是fixed中的一种；
        元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；

## 定位与浮动
    为什么需要清除浮动，清除浮动的方式？
        为什么清除浮动
            非IE浏览器下，容器不设高度且子元素浮动时，浮动的子元素脱离文档流，不占据空间（引起“高度塌陷”现象），父元素的高度无法被撑开，影响与父元素同级的元素，影响布局
        清除浮动的方式
            给父级div定义height属性
            最后一个浮动元素之后添加一个空的div标签，并添加clear:both样式
            包含浮动元素的父级标签添加overflow:hidden或者overflow:auto
            使用 ::after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout**
    使用clear属性清除浮动的原理
        使用clear属性清除浮动，其语法如下：clear:none|left|right|both，官方对clear属性解释：“元素盒子的边不能和前面的浮动元素相邻”，对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。
            一般使用伪元素的方式清除浮动：
            .clear::after{
            content:'';
            display: block; 
            clear:both;
            }
## 对BFC的理解，如何创建BFC
    BFC理解
        Box: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个Box就是我们所说的盒模型。

        Formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。 

        块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。

        通俗来讲：BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。
    
    如何创建BFC
        ● 根元素：body；
        ● 元素设置浮动：float 除 none 以外的值；
        ● 元素设置绝对定位或者固定定位：position (absolute、fixed)；
        ● display 值为：inline-block、table-cell、table-caption、flex等；
        ● overflow 值为：hidden、auto、scroll；

    BFC特点
        ● 垂直方向上，自上而下排列，和文档流的排列方式一致。
        ● 在BFC中上下相邻的两个容器的margin会重叠
        ● 计算BFC的高度时，需要计算浮动元素的高度
        ● BFC区域不会与浮动的容器发生重叠
        ● BFC是独立的容器，容器内部元素不会影响外部元素
        ● 每个元素的左margin值和容器的左border相接触

    BFC应用
        解决margin的重叠问题
            由于BFC是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个BFC，就解决了margin重叠的问题。
        解决高度塌陷的问题
            在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把父元素变成一个BFC。常用的办法是给父元素设置overflow:hidden。
        创建自适应两栏布局
            可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。
## 什么是margin重叠问题？如何解决
    margin重叠问题
        个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，浮动的元素和绝对定位这种脱离文档流的元素的外边距不会折叠。重叠只会出现在垂直方向。只有块级元素会触发外边距塌陷的问题
    计算原则
        如果两者都是正数，那么就去最大者
        如果是一正一负，就会正值减去负值的绝对值
        两个都是负值时，用0减去两个中绝对值大的那个
    解决方案
        兄弟之间重叠
            底部元素变为行内盒子：display: inline-block
            底部元素设置浮动：float
            底部元素的position的值为absolute/fixed
        父子之间重叠 
            父元素加入：overflow: hidden
            父元素添加透明边框：border:1px solid transparent
            子元素变为行内盒子：display: inline-block
            子元素加入浮动属性或定位
## 元素的层叠顺序
    层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。
            背景和边框：建立当前层叠上下文元素的背景和边框。
            负的z-index：当前层叠上下文中，z-index属性值为负的元素。
            块级盒：文档流内非行内级非定位后代元素。
            浮动盒：非定位浮动元素。
            行内盒：文档流内行内级非定位后代元素。
            z-index:0：层叠级数为0的定位元素。
            正z-index：z-index属性值为正的定位元素。
## position的属性有哪些？区别是什么
    属性
        static
            默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。
        relative
            生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过left、top、right、bottom属性进行规定。   元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。
        absolute
            生成绝对定位的元素，相对于static定位以外的一个有定位的父元素进行定位。元素的位置通过left、top、right、bottom属性进行规定。  元素的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了position:relative/absolute/fixed的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。
        fixed
            生成固定定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。元素的定位是相对于 window （或者 iframe）边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。
        sticky
            粘性定位，基于用户的滚动位置来定位。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。
        inherit
            规定从父元素继承position属性的值
        display、float、position的关系
            首先判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。
            然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。
            如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。
            如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。
            总的来说，可以把它看作是一个类似优先级的机制，"position:absolute"和"position:fixed"优先级最高，有它存在的时候，浮动不起作用，'display'的值也需要调整；其次，元素的'float'特性的值不是"none"的时候或者它是根元素的时候，调整'display'的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，'display'特性值同设置值。
        absolute和fixed的共同点和不同点
            共同点
                改变行内元素的呈现方式，将display置为inline-block  
                子主题使元素脱离普通文档流，不再占据文档物理空间
                覆盖非定位文档元素
            不同点
                absolute与fixed的根元素不同，absolute的根元素可以设置，fixed根元素是浏览器。
                在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。
## 对sticky定位的理解
            sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：position: sticky; 基于用户的滚动位置来定位。
            粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。

# 页面布局
## 常见的CSS布局单位
    像素（px）：是页面布局的基础，一个像素表示终端（电脑、手机、平板等）屏幕所能显示的最小的区域，像素分为两种类型：CSS像素和物理像素：
        CSS像素：为web开发者提供，在CSS中使用的一个抽象单位；
        物理像素：只与设备的硬件密度有关，任何设备的物理像素都是固定的。
        百分比（%）：当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。
    em和rem：对于px更具灵活性，它们都是相对长度单位，它们之间的区别：em相对于自身或者父元素字体，rem相对于根元素（html字体大小）。
        em： 文本相对长度单位。相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)。
        rem： rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。作用：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值来设置font-size的值，以此实现当屏幕分辨率变化时让元素也随之变化。

    vw/vh是与视口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。
        vw：相对于视窗的宽度，1vw = 1/100视口宽度；
        vh：相对于视窗的高度，1vh = 1/100视口高度；
        vmin：vw和vh中的较小值；
        vmax：vw和vh中的较大值；

## px、em、rem的区别及使用场景
    区别
        px是固定的像素，一旦设置了就无法因为适应页面大小而改变。
        em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。
            em是以自身的font-size为参考的，当em没有设置自身的font-size，则会以父元素的font-size为标准；
            rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。
    适用场景
        对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。
        对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。
## 两栏布局的实现
    一般两栏布局指的是左边一栏宽度固定，右边一栏宽度自适应
        左侧浮动+右侧margin-left
            给父容器一个高度；左边盒子宽度给200px，高度100%，左浮动，右边盒子margin-left：200px，宽度auto，高度100%
        左侧浮动+右侧BFC
            给父容器一个高度，左侧的盒子宽度200px，高度100%，左浮动，右侧的盒子高度100%，overflow：hidden触发BFC
        flex布局
            父容器给一个高度，display：flex；左侧盒子给一个宽度200px，高度100%，右侧盒子宽度100%，flex：1
        左侧绝对定位+右侧margin-left
            父容器给一个高度，position：relative；左侧盒子给一个宽度200px，高度100%，position：absolute，top：0；left：0；右侧盒子margin-left：200px，高度100%
        右侧绝对定位+右侧定位left
            父容器给一个高度，position：relative；左侧盒子宽度200px，高度100%；右侧盒子高度100%，position：absolute，top：0；right：0；bottom：0；left：200px；
## 三栏布局的实现
    三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局
        左右绝对定位，中间margin
            给父容器一个高度，position：relative；左侧盒子和右侧盒子宽度200px，高度100%，左侧盒子左侧绝对定位，右侧盒子右侧绝对定位（position：absolute）中间盒子高度100%，margin：0  200px；
        flex布局
            父容器给一个高度，display：flex；左侧和右侧盒子高度100%，宽度200px；中间盒子高度100%，flex：1；
        两侧浮动+中间margin
            父容器给一个高度；左右盒子宽度200px，高度100%，左边左浮动，右边右浮动，中间的盒子margin：0 200px；高度100%
        圣杯布局：父盒子padding+三个盒子浮动+左右盒子相对定位并负边距
        双飞翼布局：三个盒子浮动+中间盒子左右margin留位+左右负边距
## 水平垂直居中的实现
    绝对定位+transform
        父亲给一个高度，position：relative；子盒子position：absolute，top：50%；left：50%；transform：translate（-50%，-50%）
    绝对定位+margin:auto
        父容器给一个高度，position：relative；子容器有宽度和高度，position：absolute，上下左右都是0，margin：auto；
    绝对定位+margin负值
        父容器给一个高度，position：relative；子盒子绝对定位，top：50%；left：50%，margin-top： - 高度/2 px;margin-left:- 宽度/2 px
    flex布局
        父容器给一个高度，display：flex，justify-content：center，align-items：center；
## 如何根据设计稿进行移动端适配？
    移动端适配主要有两个维度
        适配不同像素密度
            针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；
        适配不同屏幕大小
            由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。
## 对Flex布局的理解及其使用场景
    Flex是FlexibleBox的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。采用Flex布局的元素，称为Flex容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称"项目"。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿水平主轴排列。

    容器属性
        flex-direction属性决定主轴的方向（即项目的排列方向）。
        flex-wrap属性定义，如果一条轴线排不下，是否换行。
        flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。
        justify-content属性定义了项目在主轴上的对齐方式。
        align-items属性定义单行项目在侧轴上如何对齐。
        align-content属性定义了多行项目在侧轴的对齐方式。如果项目只有一行，该属性不起作用。

    项目属性
        order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。
        flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
        flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
        flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。
        flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。
            flex:1 表示什么
                flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。flex:1 表示 flex: 1 1 auto，它还有另外两种完整写法, 分别是 initial (0 1 auto) 和 none (0 0 auto)
        align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。
## 响应式设计的概念及基本原理
    概念
        响应式网站设计（Responsive Web design）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。
    原理
        基本原理是通过媒体查询（@media）查询检测不同的设备屏幕尺寸做处理。
    兼容
        页面头部必须有meta声明的viewport。
## 品字布局
    margin： 0 auto；+ 浮动
        设置三个div宽和高，第一个div margin： 0 auto；后两个div浮动使其一行显示，然后通过margin-left以及transform：translate实现布局，（padding和margin若是百分比则是以父亲的宽度为准）
    margin： 0 auto； + inline-block
        设置三个div宽和高，第一个div margin： 0 auto；后两个div display：inline-block使其一行显示，然后通过margin-left以及transform：translate实现布局，（padding和margin若是百分比则是以父亲的宽度为准）
## 九宫格布局
    float
        给ul设定宽和高（需计算：比如330*330）每个li宽和高（100*100）并且设置左浮动，每个li margin-right：10px；margin-bottom：10px；
    flex
        给ul设定宽和高（330*330），display：flex；flex-wrap：wrap；justify-content：space-around；align-items：space-around；，每个li给定宽和高（100*100）
    inline-block
        给ul设定宽和高（需计算：比如330*330）每个li宽和高（100*100）并且设置display：inline-block；每个li  margin-bottom： 10px；

# 场景应用
## 实现一个三角形
    原理
        CSS绘制三角形主要用到的是border属性，也就是边框。平时在给盒子设置边框时，往往都设置很窄，就可能误以为边框是由矩形组成的。实际上，border属性是由三角形组成的
    实现
        div {
            width: 0;
            height: 0;
            border: 100px solid;
            border-color: orange blue red green;
        }		
                    
## 实现一个扇形
    原理
        用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形
    实现
        div{
            border: 100px solid transparent;
            width: 0;
            height: 0;
            border-radius: 100px;
            border-top-color: red;
        }

## 圆
    div {
        background-color: red;
        height: 100px;
        width: 100px;
        border-radius: 50%;
    }

## 实现一个宽高自适应的正方形
    vw方式
        .square {
            width: 10%;
            height: 10vw;
            background: tomato;
        }

## 利用元素的margin/padding百分比是相对父元素width的性质来实现：
    .square {
        width: 20%;
        height: 0;
        padding-top: 20%;
        background: orange;
    }
## 利用子元素的margin-top的值来实现：
    .square {
        width: 30%;
        overflow: hidden;
        background: yellow;
    }
    .square::after {
        content: '';
        display: block;
        margin-top: 100%;
    }

## 画一条0.5px的线
    采用transform: scale()的方式
        transform: scale(0.5,0.5);
    采用meta viewport的方式
        <meta name="viewport" content="width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5"/>

## 设置小于12px的字体
    使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。
    使用css3的transform缩放属性-webkit-transform:scale(0.5); 注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/inline-block/...；
    使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。
## 如何解决1px问题
    问题
        1px 问题指的是：在一些 Retina屏幕 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——CSS 中的 1px 并不能和移动设备上的 1px 划等号。
    原因
        window.devicePixelRatio = 设备的物理像素 / CSS像素。
        打开 Chrome 浏览器，启动移动端调试模式，在控制台去输出这个 devicePixelRatio 的值。这里选中 iPhone6/7/8 这系列的机型，输出的结果就是2：
        这就意味着设置的 1px CSS 像素，在这个设备上实际会用 2 个物理像素单元来进行渲染，所以实际看到的一定会比 1px 粗一些。
    解决方案
        1.直接写 0.5px
            目前为止最简单的一种方法。这种方法的缺陷在于兼容性不行，IOS 系统需要8及以上的版本，安卓系统则直接不兼容。
        2.伪元素先放大后缩小
            思路是先放大、后缩小：在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的宽和高都设置为目标元素的两倍，border值设为 1px。接着借助 CSS 动画特效中的放缩能力，把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一，间接地实现了 0.5px 的效果。
        这个方法的可行性会更高，兼容性也更好。唯一的缺点是代码会变多。
        3. viewport 缩放来解决
            <meta name="viewport" content="initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no">
                整个页面被缩放了。这时 1px 已经被处理成物理像素大小，这样的大小在手机上显示边框很合适。但是，一些原本不需要被缩小的内容，比如文字、图片等，也被无差别缩小掉了。

# JS
## 1.数据类型
JavaScript有哪些数据类型，它们的区别？
    数据类型
        基本数据类型
            字符串String
            数字型Number
            布尔型Boolean
            未定义undefined
            Null
            Symbol
        引用数据类型
            对象型Object
            数组型Array
            函数型Function
            Date
            Math
            正则RegExp
            Map
            Set
    区别
        两种类型的区别在于存储位置的不同
            基本数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储
            引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体
## 数据类型检测的方式有哪些
    typeof xxx
        用于检测基本数据类型（除Null外，Null会被检测为object）
        检测引用数据类型除（除function外，function会被检测为function）会被检测为object
        返回结果为字符串类型，且类型第一个字母均为小写
            
    xxx instanceof constructor
        适用于精准检测引用数据类型
            可以正确判断对象的类型，用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上，object instanceof constructor，object为实例对象，constructor为构造函数
                
    Object.prototype.toString.call()
        适用于所有数据类型
            调用该方法，统一返回格式“[object Xxx]”的字符串
                        
## 判断数组的方式有哪些
    xxx instanceof constructor
        返回布尔值
    Object.prototype.toString.call( )
        返回“[object Xxx]”的字符串
    数组.__proto__ === Array.prototype(通过原型链做判断)
        返回布尔值
    通过ES6的Array.isArray()做判断
        返回布尔值
    通过Array.prototype.isPrototypeOf(数组名）
        返回布尔值
## null和undefined区别
    首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。
            undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。
## 如何获取安全的 undefined 值？
    因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。 var a = void 0;    void数字0
## typeof NaN 的结果是什么？
    NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。返回的结果为"number"，NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN !== NaN 为 true。

## isNaN 和 Number.isNaN 函数的区别？
    函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。
    函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。
                
## == 操作符的强制类型转换规则？
    首先会判断两者类型是否相同，相同的话就比较两者的大小；
    类型不相同的话，就会进行类型转换；
    会先判断是否在对比 null 和 undefined，是的话就会返回 true
    判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number
    判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断
    判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就			会把 object 转为原始类型再进行判断

## 其他值到字符串的转换规则？
    Null 和 Undefined 类型 ，null 转换为 "null"，undefined 转换为 "undefined"
    Boolean 类型，true 转换为 "true"，false 转换为 "false"
    Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式
    Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误
    对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如"[object Object]"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值

## 其他值到数字值的转换规则？
    Undefined 类型的值转换为 NaN
    Null 类型的值转换为 0
    Boolean 类型的值，true 转换为 1，false 转换为 0
    String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0
    Symbol 类型的值不能转换为数字，会报错
    对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字
    总结
        如果值有toString（）方法，则调用该方法并返回结果；null返回“null”，undefined返回“undefined”

## 其他值到布尔类型的值的转换规则？
    false
        undefined
        null
        false
        +0、-0 和 NaN
        ""
    true
        除以上外

## || 和 && 操作符的返回值？
    || 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。
    对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。
    && 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。

## Object.is(value1, value2) 与比较操作符 “===”、“==” 的区别？
    使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较
    使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false
    使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的

## 什么是 JavaScript 中的包装类型？
    在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象，如：
        
        在访问'abc'.length时，JavaScript 将'abc'在后台转换成String('abc')，然后再访问其length属性。
        JavaScript也可以使用Object函数显式地将基本类型转换为包装类型：
            
        也可以使用valueOf方法将包装类型倒转成基本类型：
                        
## +操作符什么时候用于字符串的拼接？
            根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。
## 为什么会有BigInt的提案？ 
            javaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。 

## object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别
    在Es6中扩展运算符(…)与Object.assign()中复制是浅拷贝，所谓的浅拷贝和深拷贝：浅拷贝是在在拷贝过程中，遍历时那部分为对象/数组类型指向原来的地址，而深拷贝，则是完全开辟新的内存地址。
            Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。
            扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。

## 如何判断一个对象是空对象
            使用JSON自带的JSON.stringify方法来判断
                
            使用ES6新增的方法Object.keys()来判断
                

# 2.ES6
    let、const、var的区别
        区别主要体现在七个方面
            是否有块级作用域
                块作用域由 { }包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：
                    内层变量可能覆盖外层变量
                    用来计数的循环变量泄露为全局变量
            是否存在变量提升
                var存在变量提升
                let、const不存在变量提升，即变量只能在声明之后使用，否在会报错
            是否添加全局属性
                浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。
            能否重复声明变量
                var可以重复声明变量，后声明的同名变量会覆盖之前声明的变量
                const和let不允许重复声明变量
            是否存在暂时性死区
                在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区 let a = a/const a = a（会报错）
                使用var声明的变量不存在暂时性死区：var a = a（不会报错）
            是否必须设置初始值
                var和let不需要赋初始值，只声明就可以
                const声明时必须赋初始值，否则会报错
            能否改变指针指向（重复赋值）
                let创建的变量是可以更改指针指向（可以重新赋值）

        const声明的变量是不允许改变指针的指向
        const对象的属性可以修改吗
            const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量；
        但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。

## 如果new一个箭头函数的会怎么样
    箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数；
    new操作符的实现步骤如下：
        1. 创建一个对象
        2. 将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）
        3. 指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）
        4. 返回新的对象                                                                                               
        所以，上面的第二、三步，箭头函数都是没有办法执行的。

## 箭头函数与普通函数的区别
    箭头函数比普通函数更加简洁
        如果只有一个参数，可以省去参数的括号
        如果函数体的返回值只有一句，可以省略大括号，且必须省略return
    箭头函数没有自己的this
        箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。
    call()、apply()、bind()等方法不能改变箭头函数中this的指向,箭头函数的this指向要么是window，要么是他的外层
    箭头函数不能作为构造函数使用,箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。
    箭头函数没有prototype
    箭头函数不能用作Generator函数，不能使用yield关键字

## 箭头函数的this指向哪⾥？
    箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。箭头函数的this指向外层函数的this


## 扩展运算符的作用及使用场景
    对象扩展运算符
        对象的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。扩展运算符对对象实例的拷贝属于浅拷贝
    数组扩展运算符
        数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。
## 对对象与数组的解构的理解
    数组的解构
        在解构数组时，以元素的位置为匹配条件来提取想要的数据的
    对象的解构
        在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的
## 如何提取高度嵌套的对象里的指定属性？
    const school = {
    classes: {
        stu: {
            name: 'Bob',
            age: 24,
        }
    }
    }                                                                                           const { classes: { stu: { name } }} = school
## 对 rest 参数的理解
    扩展运算符（...args)被用在函数形参上时，它还可以把一个分离的参数序列整合成一个数组，便于使用数组的遍历等方法【与arguments类似，但是arguments是以对象形式】

## ES6中模板语法与字符串处理
    允许用${}的方式嵌入变量，优势有两个
        在模板字符串中，空格、缩进、换行都会被保留，可以识别html代码
        模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算

# 3.JS基础
    new操作符的实现原理
    new操作符的执行过程：
        （1）首先创建了一个新的空对象(创建一个新的内存空间）
        （2）设置原型，将对象的原型设置为函数的 prototype 对象。
        （3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）
        （4）返回新对象（所以构造函数不需要return）

## Map和Object的区别
    同名碰撞
        对象其实就是在堆开辟了一块内存，其实Map的键存的就是这块内存的地址。只要地址不一样，就是两个不同的键，这就解决了同名属性的碰撞问题，而传统的Object显然做不到这一点。
            
    键的类型
        Map的键可以是任意值，包括函数、对象或任意基本类型。
        Object 的键必须是 String 或是Symbol。
    键的顺序
        Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。
        Object 的键是无序的
    Size
        Map 的键值对个数可以轻易地通过size 属性获取
        Object 的键值对个数只能手动计算
    迭代
        Map 是 iterable 的，所以可以直接被迭代，可用for...of遍历
        Object不是 iterable，不可以被迭代，不能用for...of遍历
## Map和weakMap的区别
    Map
        map本质上就是键值对的集合，但是普通的Object中的键值对中的键只能是字符串。而ES6提供的Map数据结构类似于对象，但是它的键不限制范围，可以是任意类型，是一种更加完善的Hash结构。如果Map的键是一个原始数据类型，只要两个键严格相同，就视为是同一个键。
        Map数据结构有以下操作方法
            size
                map.size 返回Map结构的成员总数
            set(key,value)
                设置键名key对应的键值value，然后返回整个Map结构，如果key是简单数据类型且已经有值，则键值会被更新，否则就新生成该键，若键为引用数据类型，则不会被更改。
            get(key)
                该方法读取key对应的键值，如果找不到key，返回undefined
            has(key)
                该方法返回一个布尔值，表示某个键是否在当前Map对象中
            delete(key)
                该方法删除某个键，返回true，如果删除失败，返回false
            clear()
                map.clear()清除所有成员，没有返回值
                Map结构原生提供三个遍历器生成函数和一个遍历方法
                        
                keys()
                    返回键名的遍历器
                values()
                    返回键值的遍历器
                entries()  返回所有成员的遍历器
                forEach()  遍历Map的所有成员 

        weakMap
            WeakMap 对象也是一组键值对的集合，其中的键是弱引用的。其键必须是对象，原始数据类型不能作为key值，而值可以是任意的
                weakMap对象也有以下几种方法
                    set(key,value)
                        设置键名key对应的键值value，然后返回整个Map结构
                    get(key)
                        该方法读取key对应的键值，如果找不到key，返回undefined
                    has(key)
                        该方法返回一个布尔值，表示某个键是否在当前Map对象中
                    delete(key)
                        该方法删除某个键，返回true，如果删除失败，返回false
        WeakMap的设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存。而WeakMap的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用

## JavaScript有哪些内置对象
    值属性
        这些全局属性返回一个简单值，这些值没有自己的属性和方法。
        例如 Infinity、NaN、undefined、null 字面量
    函数属性
        全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。
        例如 eval()、parseFloat()、parseInt() 等
    基本对象
        基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。
        例如 Object、Function、Boolean、Symbol、Error 等
    数字和日期对象
        用来表示数字、日期和执行数学计算的对象。
        例如 Number、Math、Date
    字符串
        用来表示和操作字符串的对象。
        例如 String、RegExp
    可索引的集合对象
        这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array
    使用键的集合对象
        这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。
        例如 Map、Set、WeakMap、WeakSet
    矢量集合
        SIMD 矢量集合中的数据会被组织为一个数据序列。
        例如 SIMD 等
    结构化数据
        这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。
        例如 JSON 等
    控制抽象对象
        例如 Promise、Generator 等
    反射
        例如 Reflect、Proxy
    国际化
        为了支持多语言处理而加入 ECMAScript 的对象。
        例如 Intl、Intl.Collator 等
    WebAssembly
    其他
        例如 arguments

## 常用的正则表达式有哪些？
    （1）匹配 16 进制颜色值
    var color = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g;
    （2）匹配日期，如 yyyy-mm-dd 格式
    var date = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;
    （3）匹配 qq 号
    var qq = /^[1-9][0-9]{4,10}$/g;
    （4）手机号码正则
    var phone = /^1[34578]\d{9}$/g;
    （5）用户名正则
    var username = /^[a-zA-Z\$][a-zA-Z0-9_\$]{4,16}$/;
    （6）Email正则
    var email = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/;
    （7）身份证号（18位）正则
    var cP = /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/;
    （8）URL正则
    var urlP= /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;
     (9)ipv4地址正则
    var ipP = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
     (10)//车牌号正则
    var cPattern = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/;
     (11)强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：var pwd = /^(?=.\d)(?=.[a-z])(?=.[A-Z]).{8,10}$/


# JSON
    对JSON的理解
            JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为 
    JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。
                js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理
                    JSON.stringify 函数
                        通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串
                    JSON.parse() 函数
                        这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问

        JavaScript脚本延迟加载的方式有哪些？
            defer 属性
                给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。
            async 属性
                给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。

    动态创建 DOM 方式
        动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本
            使用 setTimeout 延迟方法
                设置一个定时器来延迟加载js脚本文件
            让 JS 最后加载
                将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行

    JavaScript 类数组对象的定义？
            一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数
                常见的类数组转换为数组的方法
                    通过 call 调用数组的 slice 方法来实现转换
                        Array.prototype.slice.call(arrayLike);
                    通过 call 调用数组的 splice 方法来实现转换
                        Array.prototype.splice.call(arrayLike, 0);
                    通过 apply 调用数组的 concat 方法来实现转换
                        Array.prototype.concat.apply([], arrayLike);
                    通过 Array.from 方法来实现转换
                        Array.from(arrayLike);
        数组有哪些原生方法？
            数组和字符串的转换方法
                toString()、toLocalString()、join() 
            数组尾部操作的方法
                pop() 和 push()，push 方法可以传入多个参数
            数组首部操作的方法
                shift() 和 unshift() unshift方法可以传递多个参数，表示在数组开头增加
            重排序的方法
                reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置
            数组连接的方法
                concat() ，返回的是拼接好的数组，不影响原数组
            数组截取（浅拷贝）办法
                slice(begin【end】)，用于截取数组中的一部分返回，不影响原数组。
            数组插入/删除/新增方法
                array.splice(start[, deleteCount[, item1[, item2[, ...]]]])，改变原数组
            数组归并方法
                reduce() 和 reduceRight() 方法

    Unicode、UTF-8、UTF-16、UTF-32的区别？

    ● Unicode 是编码字符集（字符集），而UTF-8、UTF-16、UTF-32是字符集编码（编码规则）；
    ● UTF-16 使用变长码元序列的编码方式，相较于定长码元序列的UTF-32算法更复杂，甚至比同样是变长码元序列的UTF-8也更为复杂，因为其引入了独特的代理对这样的代理机制；
    ● UTF-8需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而UTF-16不会判断开头标志，即使错也只会错一个字符，所以容错能力教强；
    ● 如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用UTF-8就比UTF-16节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么UTF-16就占优势了，可以节省很多空间；




    常见的位运算符有哪些？其计算规则是什么？
            &---与
                两个位都为1时，结果才为1
            |---或
                两个位都为0时，结果才为0
            ^---异或
                两个相应位相同为0，相异为1
            ~---取反
                0变1，1变0
            <<---左移
                各二进制位全部左移若干位，高位丢弃，低位补0
            >>---右移
                各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃

    为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?
            arguments是一个对象，它的属性是从 0 开始依次递增的数字，还有callee和length等属性，与数组相似；但是它却没有数组常见的方法属性，如forEach, reduce等，所以叫它们类数组。
            要遍历类数组的方法
                使用call和apply方法
                Array.from方法将类数组转化成数组
                使用展开运算符将类数组转化成数组
                    
    什么是 DOM 和 BOM？
            DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。
            BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的方法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象、history对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。

    对AJAX的理解，实现一个AJAX请求
            指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。
                
                    readyState属性的五个状态
                
    ajax、axios、fetch的区别
            AJAX
                异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：
                    本身是针对MVC编程，不符合前端MVVM的浪潮
                    基于原生XHR开发，XHR本身的架构不清晰
                    不符合关注分离（Separation of Concerns）的原则
                    配置和调用方式非常混乱，而且基于事件的异步模型不友好
            Axios
                Axios 是一种基于Promise封装的HTTP客户端，支持浏览器端和 Node.js 端其特点如下
                    浏览器端发起XMLHttpRequests请求
                    node端发起http请求
                    支持Promise API
                    监听请求和返回
                    对请求和返回进行转化
                    取消请求
                    自动转换json数据
                    客户端支持抵御XSRF攻击
            Fetch
                fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。
                    优点
                        语法简洁，更加语义化
                        基于标准 Promise 实现，支持 async/await
                        更加底层，提供的API丰富（request, response）
                        脱离了XHR，是ES规范里新的实现方式
                    缺点
                        fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject
                        fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: 'include'})
                        fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费
                        fetch没有办法原生监测请求的进度，而XHR可以
    JavaScript为什么要进行变量提升，它导致了什么问题？
            为什么要进行变量提升
                解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间
                声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行
                    
            变量提升导致的问题
                
    ES6模块与CommonJS模块有什么异同？
            不同点
                1.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
                2.CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载
                3.CommonJS是对模块的浅拷贝，ES6 Module是对模块的引入，即ES6 Module只存只读，不能改变其值，具体点就是指针指向不能变，类似const 。
                4.import的接口是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向。可以对commonJS重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。
            相同点
                CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变
    常见的DOM操作有哪些
            DOM 节点的获取
                通过id获取
                    document.getElementById("id名”）
                通过标签名获取
                    document.getElementById("标签名”）
                通过类名获取
                    document.getElementByClassName('.类名‘）
                querySelector获取
                    document.querySelector('#id名/.类名/标签名’）
                querySelectorAll获取
                    document.querySelectorAll('#id名/.类名/标签名’）
                特殊元素获取
                    获取body元素
                        document.body
                    获取html元素
                        document.documentElement
            DOM 节点的创建
                document.createElement('标签名‘）
            DOM 节点的添加
                后面添加
                    父元素名.appendChild（要添加的元素）
                指定元素前面添加
                    父元素名.insertBefore(要添加的元素，添加到哪个元素前面）
            DOM 节点的删除
                父节点名.removeChild（子节点名）
            DOM 节点的克隆
                要克隆的节点名.cloneNode（true/false）
    use strict是什么意思 ? 使用它区别是什么？
            概念
                use strict 是一种 ECMAscript5 添加的（严格模式）运行模式，这种模式使得 Javascript 在更严格的条件下运行。
            目的
                消除 Javascript 语法的不合理、不严谨之处，减少怪异行为;
                消除代码运行的不安全之处，保证代码运行的安全；
                提高编译器效率，增加运行速度；
                为未来新版本的 Javascript 做好铺垫
            区别
                禁止使用 with 语句
                禁止 this 关键字指向全局对象
                对象不能有重名的属性

    如何判断一个对象是否属于某个类
            第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。
            第二种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来判断

    强类型语言和弱类型语言的区别
            强语言类型
                强类型语言也称为强类型定义语言，是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。Java和C++等语言都是强制类型定义的，也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。例如你有一个整数，如果不显式地进行转换，你不能将其视为一个字符串
            弱语言类型
                弱类型语言也称为弱类型定义语言，与强类型定义相反。JavaScript语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。比如JavaScript是弱类型定义的，在JavaScript中就可以将字符串'12'和整数3进行连接得到字符串'123'，在相加的时候会进行强制类型转换
    解释性语言和编译型语言的区别
            解释型语言
                使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下
                    解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低
                    只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植
                    JavaScript、Python等属于解释型语言
            编译型语言
                使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下
                    一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高
                    与特定平台相关，一般无法移植到其他平台
                    C、C++等属于编译型语言
    for...in和for...of的区别 
            区别
                for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链
                对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值
        如何使用for...of遍历对象 
            for…of是作为ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，普通的对象用for..of遍历是会报错的。
                如果需要遍历的对象是类数组对象，用Array.from转成数组即可
                    输出的为键值
                如果不是类数组对象，就给对象添加一个[Symbol.iterator]属性，并指向一个迭代器即可

    数组的遍历方法有哪些
            for...of
                不改变原数组
                    for...of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象
            forEach()
                视情况是否改变原数组
                    没有返回值
            filter()
                不改变原数组
                    数组方法，不改变原数组，有返回值，返回一个符合筛选规则的新数组
            every() 和 some()
                不改变原数组
                    数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.
            map()
                不改变原数组
                    数组方法，不改变原数组，有返回值，生成一个一一对应的新数组
            find() 和 findIndex()
                不改变原数组
                    数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值
            reduce() 和 reduceRight()
                不改变原数组
                    数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作
    forEach和map方法有什么区别
            forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值
            map()方法不会改变原数组的值，有返回值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值

    addEventListener()方法的参数和使用
            概念
                EventTarget.addEventListener() 方法将指定的监听器注册到 EventTarget 上，当该对象触发指定的事件时，指定的回调函数就会被执行。 事件目标可以是一个文档上的元素 Element，Document和Window或者任何其他支持事件的对象。
            原理
                将实现EventListener的函数或对象添加到调用它的EventTarget上的指定事件类型的事件侦听器列表中。
            语法
                    type
                        表示监听事件类型的字符串
                    listener
                        当所监听的事件类型触发时，会接收到一个事件通知（实现了 Event 接口的对象）对象。listener 必须是一个实现了 EventListener 接口的对象，或者是一个函数。
                    options 可选
                        一个指定有关 listener 属性的可选参数对象。可用的选项如下：
    ● capture:  Boolean，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。
    ● once:  Boolean，表示 listener 在添加之后最多只调用一次。如果是 true， listener 会在其被调用之后自动移除。
    ● passive: Boolean，设置为true时，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。
    ● signal：AbortSignal，该 AbortSignal 的 abort() 方法被调用时，监听器会被移除。
                    useCapture  可选
                        Boolean，在DOM树中，注册了listener的元素， 是否要先于它下面的EventTarget，调用该listener。 当useCapture(设为true) 时，沿着DOM树向上冒泡的事件，不会触发listener。当一个元素嵌套了另一个元素，并且两个元素都对同一事件注册了一个处理函数时，所发生的事件冒泡和事件捕获是两种不同的事件传播方式。事件传播模式决定了元素以哪个顺序接收事件。如果没有指定， useCapture 默认为 false 。
                    wantsUntrusted 
                        如果为 true , 则事件处理程序会接收网页自定义的事件。此参数只适用于 Gecko（chrome的默认值为true，其他常规网页的默认值为false），主要用于附加组件的代码和浏览器本身。





    如何实现深拷贝？
            JSON.stringify()
                    ● JSON.parse(JSON.stringify(obj))是目前比较常用的深拷贝方法之一，它的原理就是利用JSON.stringify 将js对象序列化（JSON字符串），再使用JSON.parse来反序列化(还原)js对象。
                    ● 这个方法可以简单粗暴的实现深拷贝，但是还存在问题，拷贝的对象中如果有函数，undefined，symbol，当使用过JSON.stringify()进行处理之后，都会消失。
            函数库lodash的_.cloneDeep方法
                
            手写实现深拷贝函数
                    

    4.原型
        对原型、原型链的理解
            
                在JavaScript中是使用构造函数来初始化一个对象的，每一个构造函数的内部都有一个 prototype（原型对象） 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 __proto__ 属性来访问这个属性（prototype原型对象），但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype（除null外）
        原型修改、重写
            修改：并没有改变构造函数原型对象内部的constructor指向，只是在原型对象身上新增了属性或者方法
                
            重写：将构造函数的原型对象直接进行替换，修改了构造函数内部constructor的指向，若想仍然指向原来的构造函数，需要在修改的原型对象内部重新将constructor指向该构造函数	
        原型链指向
    原型链的终点是什么？如何打印出原型链的终点？
            原型链的终点
                由于Object是构造函数，原型链终点是Object.prototype.__proto__，而Object.prototype.__proto__=== null // true，所以，原型链的终点是null
            如何打印出原型链的终点
                原型链上的所有原型都是对象，所有的对象最终都是由Object构造的，而Object.prototype的下一级是Object.prototype.__proto__
                    
    如何获得对象非原型链上的属性？
            使用hasOwnProperty()方法来判断属性是否属于原型链的属性
                

    5.异步编程
        Event Loop（JS执行机制）
            JS是单线程，也就是说，同一时间只能做一件事。
                同步（按顺序来）
                    同步任务：同步任务都在主流程上执行，形成一个执行栈。（宏任务）
                异步（同时进行）
                    异步任务：JS的异步是通过回调函数实现的。异步任务相关回调函数添加到任务队列中（任务队列也称消息队列）。一般而言，异步任务有三种类型：
                        普通事件，如click、resize等
                        资源加载，如load、error等
                        定时器，包括setTimeout、setInterval等。
            JS执行机制--Event Loop
                先执行执行栈中的同步任务；
                异步任务（回调函数）放入任务队列中；
                一旦执行栈中的所有同步任务执行完毕，系统会按次序取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。
                
                
    什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？
            回调函数概念
                回调函数是一个作为变量传递给另一个函数的函数，它在主体函数执行完之后再执行
            回调函数特点
                你定义的
                你没有调用
                但是最终执行了
            缺点
                回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）
                    嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身
                    嵌套函数一多，就很难处理错误
                不能使用 try catch 捕获错误
                不能直接 return
            常见的回调函数
                DOM事件回调函数
                定时器回调函数
                ajax请求回调函数
                生命周期回调函数
            如何解决回调函数
                promise
                async/await
                Generator


    异步编程的实现方式？
            回调函数的方式
                使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护
            Promise的方式
                使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确
            generator的方式
                它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行
            async函数的方式
                async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行

    对Promise的理解
            Promise本身是同步的立即执行函数，当在executor中执行resolve（）或者reject（）的时候, 此时是异步操作，也就是说promise中函数体内部的非异步操作正常顺序执行，resolve（）和reject（）异步操作为promise实例对象的返回结果，这个返回结果后面的then或者catch需要用，所以then和catch要放到异步任务中等待所有同步任务执行完毕之后再按顺序（或者如果有定时器，需要遵循定时器的时间）执行。
            Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理
            Promise解决了什么问题/为什么需要promise
                在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码
                    上面的代码有如下缺点：
    ● 后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。
    ● 如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。
                    promise写法：解决了地狱回调的问题
            Promise的实例有三个状态
                Pending（进行中）
                Resolved（已完成）
                Rejected（已拒绝）
            Promise的实例有两个过程
                pending -> fulfilled : Resolved（已完成）
                pending -> rejected：Rejected（已拒绝）
            Promise的特点
                对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，pending（进行中）、fulfilled（已成功）、rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“承诺”
                一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从pending变为fulfilled，从pending变为rejected。这时就称为resolved（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的
            Promise的缺点
                无法取消Promise，一旦新建它就会立即执行，无法中途取消
                如果不设置回调函数，Promise内部抛出的错误，不会反应到外部
                当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）
            总结
                Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行
    Promise解决了什么问题
            在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求
                上面的代码有如下缺点：
    ● 后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。
    ● 如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观
                promise形式：代码看起了就简洁了很多，解决了地狱回调的问题
        Promise的基本用法
            创建Promise对象
                new Promise()法
                    
                promise.resolve（）方法
                    resolve(11)代码中，会让promise对象进入确定(resolve状态)，并将参数11传递给后面的then所指定的onFulfilled 函数；
                promise.reject（）方法
                    reject(‘wrong’)代码中，会让promise对象进入拒绝(reject状态)，并将参数wrong传递给后面的catch所指定的reject 函数；
    Promise方法
                then（）方法
                    p.then(res => {...},err => {...})
                        then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中第二个参数可以省略
                        then方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法
                catch（）方法
                    p.catch(err => {...})
                        该方法相当于then方法的第二个参数，指向reject的回调函数
                            
                all（）方法
                    Promise.all([p1,p2...])
                        all方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个promise对象。当数组中所有的promise的状态都达到resolved的时候，all方法的状态就会变成resolved，如果有一个状态变成了rejected，那么all方法的状态就会变成rejected
                        当所有的子Promise都完成，该Promise完成，返回值是全部值的数组,这个数组按顺序保存着每一个promise对象resolve执行时的值
                            
                        如果有任何一个失败，该Promise失败，返回值是第一个失败的子Promise的结果
                race（）方法
                    Promise.race([p1,p2...])
                        race方法和all一样，接受的参数是一个每项都是promise的数组，但是与all不同的是，当最先执行完的事件执行完之后，就直接返回该promise对象的值。如果第一个promise对象状态变成resolved，那自身的状态变成了resolved；反之第一个promise变成rejected，那自身状态就会变成rejected
                            
                        实际应用
                            当要做一件事，超过多长时间就不做了，可以用这个方法来解决
                                
                finally（）方法
                    p.finally（）
                        finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作
                        不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数
                        服务器使用 Promise 处理请求，然后使用finally方法关掉服务器，finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected
        Promise.all和Promise.race的区别的使用场景
            Promise.all（）
                Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。
            Promise.race（）
                Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决
                    
    对async/await 的理解
            async/await其实是Generator 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。
            async函数返回的是一个Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象，async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：then() 链来处理这个 Promise 对象
                async函数返回的是一个promise对象
                可以用then（）方法或者catch（）方法来处理async函数（promise对象）
    对promise/then、async/await 的理解
                async函数实际上就是promise对象，promise是同步的立即执行函数，所以aysnc函数也是立即执行函数，也就是说含有async或者promise（下面还有普通函数，或者console.log（...))会按照代码的顺序进行执行（若async函数中有await需要重新考虑执行顺序，具体看下面的tip）
                promise（async函数）异步任务只针对promise（async函数）中调用的then（）方法或者catch（）方法等里面的函数执行，promise（async函数）中的同步任务正常执行，不会阻塞，此时then或者catch方法里面的代码会放到异步任务队列中，待页面所有同步任务完成后再按照顺序（或时间顺序）执行
            没有await的async函数也是立即执行函数，会正常执行async函数里面的代码
                tip：有await的async函数，会暂时阻碍await下面所有代码的执行，在async函数中并且在await前面的代码（以及await紧跟着的那个异步函数也会正常运行）会正常运行，待await等待到他后面异步函数的结果之后，再执行await下面的代码。注意：await在没有等待到它后面的异步函数的结果时只是阻碍async函数中且在await下面的代码的执行，async函数中且在await前面、await后面紧跟着的那个异步任务的代码，以及async函数之后的代码不会受到影响，会正常运行
                    
    await 到底在等啥？
            await后面必须是异步函数， await是在等待一个异步函数完成，而这个异步函数返回值可能时promise对象，也可能是其他值，而await 等待的就是就是异步函数的返回值
                如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西
                如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞在async函数之中且await后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果
    async/await的优势
            Promise 通过 then 链来解决多层回调的问题，而 async/await 来进一步优化promise的then（）方法的多层调用
            async/await对比Promise/then（）的优势
                代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担
                Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅 
                错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余
                调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步
    async/await 如何捕获异常
            try...catch
                a为await等待的结果，await下面的代码捕获a resolve的信息
                catch捕获a reject的信息
    setTimeout、Promise、Async/Await 的区别
            setTimeout
                定时器是异步任务，会将定时器中的代码放到异步任务中，待页面中所有同步任务执行完毕之后再执行异步任务队列
            Promise
                Promise本身是同步的立即执行函数， 当在executor中执行resolve或者reject的时候, 此时是异步操作，会先执行promise中的同步任务，然后执行promise之外的同步操作（按照书写代码的先后顺序），而promise.then( )视为异步任务的方法，会加入到任务队列中，等待全部同步任务执行完毕再按顺序执行异步任务队列中的任务，promise后面的定时器也是异步函数，也要加入到异步函数队列中，即使定时器是0s，而且按照代码书写先后顺序，在任务队列中会排到then后面
            async/await
                async函数为异步函数，返回的也是promise对象，所以说async函数也是立即执行函数，他里面的代码会按照顺序相继执行；但当有异步任务，且异步任务前面有await时，这时await若未等到异步任务的结果，会阻碍async里面且在await下面的代码（await后面紧跟着的异步任务会正常执行），执行async函数下面的代码直至await等到结果之后再执行它下面在async函数中的代码

    并发与并行的区别？
            并发
                并发是宏观概念，在一段时间内通过任务间的切换完成了这些任务，这种情况就可以称之为并发（指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行）
                    
            并行
                并行是微观概念，指在同一时刻，有多条指令在多个处理器上同时执行。同时完成多个任务的情况就可以称之为并行
                    
    setTimeout、setInterval、requestAnimationFrame 各有什么特点？
            异步编程当然少不了定时器了，常见的定时器函数有 setTimeout、setInterval、requestAnimationFrame。
                最常用的是setTimeout，很多人认为 setTimeout 是延时多久，那就应该是多久后执行，其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 setTimeout 不会按期执行。当然了，可以通过代码去修正 setTimeout，从而使定时器相对准确
                setInterval，其实这个函数作用和 setTimeout 基本一致，只是该函数是每隔一段时间执行一次回调函数，通常来说不建议使用 setInterval。第一，它和 setTimeout 一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题，如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题
                如果有循环定时器的需求，其实完全可以通过 requestAnimationFrame 来实现，首先 requestAnimationFrame 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题

    6.执行上下文/作用域链/闭包
        对闭包的理解
            概念
                闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。
                比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。
                    注意：必须要先调用A，B才可以访问到A里面的变量
            用途
                闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。
                闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。
            经典面试题：循环中使用闭包解决 var 定义函数的问题
                首先因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。解决办法
                    第一种是使用闭包的方式+立即执行函数
                        在上述代码中，首先使用了立即执行函数将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的
                    使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入
                        
                    第三种就是使用 let 定义 i 了来解决问题
                        
    对作用域、作用域链的理解
            作用域
                全局作用域
                    最外层函数和最外层函数外面定义的变量拥有全局作用域（函数本身也是一个特殊的变量，其名字就是函数名字）
                    所有未定义直接赋值的变量自动声明为全局作用域
                    所有window对象的属性拥有全局作用域
                局部作用域
                    声明在函数内部的变量，一般只有固定的代码片段可以访问到
                    作用域是分层的，内层作用域可以访问外层作用域，反之不行
                块级作用域
                    使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由{ }包裹的代码片段）
                    let和const声明的变量不会有变量提升，也不可以重复声明
                    在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部
            作用域链
                概念
                    在当前作用域中查找所需变量，如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。
                作用
                    保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。
                本质
                    一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象
    对执行上下文的理解
            执行上下文类型
                全局执行上下文
                    任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文
                函数执行上下文
                    当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个
                eval函数执行上下文
                    执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用
            执行上下文栈
                JavaScript引擎使用执行上下文栈来管理执行上下文
                当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文
            输出顺序Inside first function--Inside second function--Again inside first function

    7.this/call/apply/bind
        对this对象的理解
            apply 、 call 和 bind 调用模式，这三个方法都可以改变指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。
    call() 和 apply() 的区别
            它们的作用一模一样，区别仅在于传入参数的形式的不同。
    ● apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。
    ● call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。

    8.面向对象
        如何理解面向对象？
            面向对象程序设计以对象为核心，该方法认为程序由一系列对象组成。类是对现实世界的抽象，包括表示静态属性的数据和对数据的操作，对象是类的实例化。面向对象有三个特点：
                封装性
                    将描述每一个对象的属性以及其行为的程序代码组装到一起，一并封装在一个有机的实体中，把它们封装在一个“模块”中，也就是一个类中
                继承性
                    继承性是面向对象技术中的另外一个重要特点，继承在面向对象技术是指一个对象针对于另一个对象的某些独有的特点、能力进行复制或者延续。
                多态性
                    从宏观的角度来讲，多态性是指在面向对象技术中，当不同的多个对象同时接收到同一个完全相同的消息之后，所表现出来的动作是各不相同的，具有多种形态；从微观的角度来讲，多态性是指在一组对象的一个类中，面向对象技术可以使用相同的调用方式来对相同的函数名进行调用

    对象创建的方式有哪些？
            new Object（）方式
            字面量方式
                
            工厂模式
                
        工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系
            构造函数方式
                js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个空对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，给实例对象添加属性和方法，最后再指回这个新对象。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的
            原型方式
                因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。
            构造函数+原型方式
                
                    这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好
            类方式
        对象继承的方式有哪些？
            构造函数继承（call/apply）
            prototype原型链继承
                子类原型 = 父类实例
            类继承（extends+super）

    9.垃圾回收与内存泄露
        浏览器的垃圾回收机制
            垃圾回收的概念
                垃圾回收：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。
            回收机制
                Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。
                JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。
                当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。
            垃圾回收的方式
                标记清除
                    标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。
                    垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。
                引用计数
                    另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来
                    这种方法会引起循环引用的问题：例如： obj1和obj2通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，obj1和obj2还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用
                        
            减少垃圾回收
                对数组进行优化
                    在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的
                对object进行优化
                    对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收
                对函数进行优化
                    在循环中的函数表达式，如果可以复用，尽量放在函数的外面
        哪些情况会导致内存泄漏
            意外的全局变量
                由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收
            被遗忘的计时器或回调函数
                设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收
            脱离 DOM 的引用
                获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收
            闭包
                不合理的使用闭包，从而导致某些变量一直被留在内存当中




# Vue
    1.VUE基础
        对vue设计原则的理解
            渐进式JavaScript框架
                与其它大型框架不同的是，Vue被设计为可以自底向上逐层应用。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue也完全能够为复杂的单页应用提供驱动
            易用性
                vue提供数据响应式、声明式模板语法和基于配置的组件系统等核心特性。这些使我们只需要关注应用的核心业务即可，只要会写js、html和css就能轻松编写vue应用。
            灵活性
                渐进式框架的最大优点就是灵活性，如果应用足够小，我们可能仅需要vue核心特性即可完成功能；随着应用规模不断扩大，我们才可能逐渐引入路由、状态管理、vue-cli等库和工具，不管是应用体积还是学习难度都是一个逐渐增加的平和曲线。
            高效性
                超快的虚拟DOM和diﬀ算法使我们的应用拥有最佳的性能表现。追求高效的过程还在继续，vue3中引入Proxy对数据响应式改进以及编译器中对于静态内容编译的改进都会让vue更加高效。
        vue的基本原理
            当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将每一个属性身上绑定一个 getter和setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。
                
    双向数据绑定的原理
                Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤
                    M（model--data）
                        需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化
                    V（view）
                        compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
                    VM（vue）
                        Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退
                    MVVM
                        MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果
    使用 Object.defineProperty() 来进行数据劫持有什么缺点？
            在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。
            在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。
    MVVM、MVC、MVP的区别
            MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。
                MVVM
                    VM作为更新桥梁
                        MVVM构成
                            Model代表数据模型，数据和业务逻辑都在Model层中定义
                            View代表UI视图，负责数据的展示
                            ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作
                        Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步，这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM
                MVC
                    M驱动V（数据驱动视图）
                        MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新
                MVP
                    MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑
    MVVM的优缺点? 
            优点
                分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性
                提⾼可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码
                ⾃动更新dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动dom中解放
            缺点
                Bug很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得⼀个位置的Bug被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的
                ⼀个⼤的模块中model也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，但是当⻓期持有，不释放内存就造成了花费更多的内存 
                对于⼤型的图形应⽤程序，视图状态较多，ViewModel的构建和维护的成本都会⽐较⾼

    Computed 和 Watch 的区别
    Computed
                它支持缓存，只有依赖的数据发生了变化，才会重新计算
                不支持异步，当Computed中有异步操作时，无法监听数据的变化
                computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的
                如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed
                如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法
    Watch
                它不支持缓存，数据变化时，它就会触发相应的操作
                支持异步监听
                监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值
                当一个属性发生变化时，就需要执行相应的操作
                监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数
                    immediate：组件加载立即触发回调函数
                    deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化
            总结
    ● computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。 
    ● watch 侦听器 : 更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。 
                运用场景
                    ● 当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。 
                    ● 当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

    Computed 和 Methods 的区别
            computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；
            method 调用总会执行该函数
        对Vue组件化的理解
            组件是独立和可复用的代码组织单元。组件系统是Vue核心特性之一，它使开发者使用小型、独立和通常可复用的组件构建大型应用；
            组件化开发能大幅提高应用开发效率、测试性、复用性等；
            遵循单向数据流的原则。

    slot是什么？有什么作用？原理是什么？
            概念及作用
                slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽
                    默认插槽
                        又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽
                    具名插槽
                        带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽
                    作用域插槽
                        默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽
            原理
                当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default，具名插槽为vm.$slot.xxx，xxx 为插槽名，当组件执行渲染时候，遇到slot标签，使用$slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽
    过滤器的作用，如何实现一个过滤器
            作用
                根据过滤器的名称，过滤器是用来过滤数据的，在Vue中使用filters来过滤数据，filters不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 computed ，方法 methods 都是通过修改数据来处理数据格式的输出显示）。
            使用场景
                ● 需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 / 显示。
                ● 比如后端返回一个 年月日的日期字符串，前端需要展示为 多少天前 的数据格式，此时就可以用fliters过滤器来处理数据。
            实现过滤器
                过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在插值表达式 {{ }} 和 v-bind 表达式 中，然后放在操作符“ | ”后面进行指示。
                    
    对keep-alive的理解
            keep-alive是vue中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM；设置了 keep-alive 缓存的组件，会多出两个生命周期钩子activated 和deactivated
        如何保存页面的当前的状态
            应用场景
                项目中常常会有许多列表页，当我们点击进详情后再返回列表页,页面会刷新,导致列表返回到第一条,用户体验并不是很好.这时候我们就需要用到状态保持,让页面保持之前的状态,当用户返回的时候不刷新页面
            既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况
                前组件会被卸载
                    将状态存储在LocalStorage / SessionStorage
                        只需要在组件即将被销毁的生命周期中在 LocalStorage / SessionStorage 中把当前组件的 state 通过 JSON.stringify() 储存下来就可以了。在这里面需要注意的是组件更新状态的时机
                            优点
                                ● 兼容性好，不需要额外库或工具。
                                ● 简单快捷，基本可以满足大部分需求
                            缺点
                                ● 状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点）
                                ● 如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象
                    路由传值
                        通过 vue-router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。在这里需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值，保存它。返回 A 组件时再次携带 state 达到路由状态保持的效果。
                            优点
                                ● 简单快捷，不会污染 LocalStorage / SessionStorage。
                                ● 可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify / parse 的不足）
                            缺点
                                如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑
                前组件不会被卸载
                    要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态
                        优点
                            ● 代码量少
                            ● 不需要考虑状态传递过程中的错误
                        缺点
                            ● 增加 A 组件维护成本
                            ● 需要传入额外的 prop 到 B 组件
                            ● 无法利用路由定位页面
                    用keep-alive来缓存页面
    在Vue中，还可以是用keep-alive来缓存页面，当组件在keep-alive内被切换时组件的activated、deactivated这两个生命周期钩子函数会被执行，被包裹在keep-alive中的组件的状态将会被保留
                            
                            
    常见的事件修饰符及其作用
            ● .stop：等同于 JavaScript 中的 event.stopPropagation() ，防止事件冒泡；
            ● .prevent ：等同于 JavaScript 中的 event.preventDefault() ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；
            ● .capture ：与事件冒泡的方向相反，事件捕获由外到内；
            ● .self ：只会触发自己范围内的事件，不包含子元素；
            ● .once ：只会触发一次。
            ● .passive：事件的默认行为立即执行，无需等待事件回调执行完毕。

    v-if、v-show、v-html 的原理
            ● v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染，v-if指令会根据表达式重建或销毁元素、组件以及它们所绑定的事件；
            ●  v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display，v-show 指令只是简单地设置 css 属性； 
            ● v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。

    v-if和v-show的区别
            手段
                v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐
            编译过程
                v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换
            编译条件
                v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留
            性能消耗
                v-if有更高的切换消耗；v-show有更高的初始渲染消耗
            使用场景
                v-if适合不大可能改变；v-show适合频繁切换
    v-if和v-for哪个优先级更高？如果同时出现，应如何优化？
            vue2.0版本中v-for优先于v-if被解析，如果同时出现，每次渲染都会先执行循环再判断条件，无论如何循环都不可避免，浪费了性能。要避免出现这种情况，则在外层嵌套template，在这一层进行v-if判断，然后在内部进行v-for循环。如果条件出现在循环内部，可通过计算属性提前过滤掉那些不需要显示的项
            3.x 版本中 v-if 总是优先于 v-for 生效

    v-model的实现原理
            vue中v-model可以实现数据的双向绑定，但是为什么这个指令就可以实现数据的双向绑定呢？其实v-model是vue的一个语法糖。即利用v-model绑定数据后，既绑定了数据，又添加了一个input事件监听。
                实现原理
                    ● v-bind绑定响应数据
                    ● 触发input事件并传递数据
        v-model 是如何实现的，语法糖实际是什么？
            作用在表单元素上
                动态绑定了 input 的 value 指向了 message 变量，并且在触发 input 事件的时候去动态把 message设置为目标值：
            作用在组件上
                在父组件中，v-model =“message”默认会将message传递给子组件，子组件用props：["message"]接收，并为自身绑定一个input事件，这个input事件会接收子组件传过来的值，进而修改自己的message的值；在子组件内，用props：["message"]接收父组件传递过来的值，利用事件来触发父组件的事件，并将改变的值传递给父组件
                    父组件内
                    子组件内
    v-model 可以被用在自定义组件上吗？如果可以，如何使用？
            父组件
                相当于
                    父组件将searchText变量传入custom-input 组件，使用的 prop 名为value
                    custom-input 组件向父组件传出名为input的事件，父组件将接收到的值赋值给searchText
            子组件
                
    data为什么是一个函数而不是对象
            Vue组件可能存在多个实例，如果使用对象形式定义data，则会导致它们共用一个data对象，那么状态变更将会影响所有组件实例，这是不合理的；采用函数形式定义，在initData时会将其作为工厂函数返回全新data对象，有效规避多实例之间状态污染问题。而在Vue根实例创建过程中则不存在该限制，也是因为根实例只能有一个，不需要担心这种情况

    $nextTick 原理及作用
            原理
                Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。nextTick 的本质是为了利用 JavaScript 的异步回调任务队列来实现 Vue 框架中自己的异步回调队列。
            作用
                Vue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了nextTick了。由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在$nextTick中
                在以下情况下，会用到nextTick
                    ● 在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在nextTick()的回调函数中。
                    ● 在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在nextTick()的回调函数中。因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在nextTick()的回调函数中。

    Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？
                问题
                    点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新
                原因
                    这是因为在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，也就是没有为该属性设置getter和setter，自然就不会触发视图的更新
                解决方法
                    使用Vue的全局 api $set()，$set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了
                        
    Vue中封装的数组方法有哪些，其如何实现页面更新
            Vue中封装的数组方法
            如何实现页面更新
                简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的__ob__，也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过target__proto__ == arrayMethods来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。

    vue如何监听对象或者数组某个属性的变化
            先判断属性是否原本就存在，若存在，则利用自身的setter和getter实现数据的实时更新
            当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。
                解决方式
                    数组
                        this.$set(你要改变的数组，你要改变的位置，你要改成什么value)
                        vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用再进行额外的操作，视图自动进行更新。 
                    对象
                        this.$set(你要改变的对象，你要改变的key，你要改成什么value)
                    vm.$set 的实现原理
                        ● 如果目标是数组，直接使用数组的 splice 方法触发响应式；
                        ● 如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）

    Vue 单页应用与多页应用的区别
            概念
                SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源
                MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新
            区别
    对 SPA 单页面的理解，它的优缺点分别是什么？
            概念
                SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。
            优点
                ● 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
                ● 基于上面一点，SPA 相对对服务器压力小；
                ● 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；
            缺点
                ● 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
                ● 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
                ● SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。


    Vue模版编译原理
            vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所以需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。
                解析阶段
                    使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST
                优化阶段
                    遍历AST，找到其中的一些静态节点并进行标记，方便在页面重新渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能
                生成阶段
                    将最终的AST转化为render函数字符串，生成render函数，浏览器执行render函数，在页面中渲染出对应的HTML元素
        Vue template 到 render 的过程                             
            vue 在模版编译版本的码中会执行 compileToFunctions 将template转化为render函数
                CompileToFunctions中的主要逻辑如下
                    调用parse方法将template转化为ast（抽象语法树）
                        ● parse的目标：把template转换为AST树，它是一种用 JavaScript对象的形式来描述整个模板。
    ● 解析过程：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的 回调函数，来达到构造AST树的目的。
    AST元素节点总共三种类型：type为1表示普通元素、2为表达式、3为纯文本
                    对静态节点做优化
                        这个过程主要分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化，深度遍历AST，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用
                    生成代码
                        generate将ast抽象语法树编译成 render字符串并将静态部分放到 staticRenderFns 中，最后通过 new Function( render) 生成render函数

    对SSR的理解
            概念
                SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端
            优势
                ● 更好的SEO
                ● 首屏加载速度更快
            劣势
                ● 开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；
                ● 当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境；
                ● 更多的服务端负载。

    Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？
            不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。

    什么是 mixin ？
            Mixin 使我们能够为 Vue 组件编写可重用的功能。
            如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。
            然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优先于组件自已的 hook。
        简述 mixin、extends 的覆盖逻辑
            mixin 和 extends
                mixin 和 extends均是用于合并、拓展组件的，两者均通过 mergeOptions 方法实现合并
                    ● mixins 接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。
                    ● extends 主要是为了便于扩展单文件组件，接收一个对象或构造函数。
            mixin、extends 的覆盖逻辑
            mergeOptions 的执行过程
                规范化选项
                对未合并的选项，进行判断
                合并处理。根据一个通用 Vue 实例所包含的选项进行分类逐一判断合并，如 props、data、 methods、watch、computed、生命周期等，将合并结果存储在新定义的 options 对象里
                返回合并结果 options
    mixin 和 mixins 区别
            mixin 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。虽然文档不建议在应用中直接使用 mixin，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 ajax 或者一些工具函数等等。
                
            mixins 应该是最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行（watch也是），并且在遇到同名选项的时候也会有选择性的进行合并。
                
    描述下Vue自定义指令
            为什么要使用自定义指令
                在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令，一般需要对DOM元素进行底层操作时使用，尽量只用来操作 DOM展示，不修改内部的值。当使用自定义指令直接修改 value 值时绑定v-model的值也不会同步更新；如必须修改可以在自定义指令中使用keydown事件，在vue组件中使用 change事件，回调中修改vue数据
            自定义指令分类
                全局自定义指令
                    在任意页面的任意位置都可使用的自定义指令
                局部自定义指令
                    只针定义自定义指令所在的组件内的元素
            自定义指令定义方式
                函数形式
                对象形式
                    配置对象中常用的3个回调:
    □ bind:指令与元素成功绑定时调用。
    □ inserted:指令所在元素被插入页面时调用。
    □ update:指令所在模板结构被重新解析时调用。
            钩子函数
                bind
                    只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
                inSerted
                    被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。
                update
                    所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前调用。指令的值可能发生了改变，也可能没有。但是可以通过比较更新前后的值来忽略不必要的模板更新。
                ComponentUpdate
                    指令所在组件的 VNode及其子VNode全部更新后调用
                unbind
                    只调用一次，指令与元素解绑时调用
            钩子函数参数
                el
                    绑定元素
                binding
                    指令核心对象，描述指令全部信息属性
                name
                value
                oldValue
                expression
                arg
                modifers
                vnode  
                    虚拟节点
                oldVnode
                    上一个虚拟节点（更新钩子函数中才有用）
            使用场景
                普通DOM元素进行底层操作的时候，可以使用自定义指令
                自定义指令是用来操作DOM的。尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的DOM操作，并且是可复用的。
            使用案例
                初级应用
                    鼠标聚焦
                    下拉菜单
                    相对时间转换
                    滚动动画
                高级应用
                    自定义指令实现图片懒加载
                    自定义指令集成第三方插件

    子组件可以直接改变父组件的数据吗？
            子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。

    Vue是如何收集依赖的？
            在初始化 Vue 的每个组件时，会对组件的 data 进行初始化，就会将由普通对象变成响应式对象，在这个过程中便会进行依赖收集的相关逻辑
        Vue的优点
            轻量级框架
                只关注视图层，是一个构建数据的视图集合，大小只有几十 kb
            简单易学
                国人开发，中文文档，不存在语言障碍 ，易于理解和学习
            双向数据绑定
                保留了 angular 的特点，在数据操作方面更为简单
            组件化
                保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势
            视图，数据，结构分离
                使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作
            虚拟DOM
                dom 操作是非常耗费性能的，不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式；
            运行速度更快
                相比较于 react 而言，同样是操作虚拟 dom，就性能而言， vue 存在很大的优势

    assets和static的区别
            相同点
                assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下
            不同点
                assets 中存放的静态资源文件在项目打包时，也就是运行 npm run build 时会将 assets 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器
                static 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 static 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 assets 中打包后的文件提交较大点。在服务器中就会占据更大的空间。
            建议
                将项目中 template需要的样式文件js文件等都可以放置在 assets 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如iconfoont.css 等文件可以放置在 static 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。

    delete和Vue.delete删除数组的区别
            delete 只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变，数组长度不变
            Vue.delete 直接删除了数组元素，改变了数组的键值，数组长度变化。

    Vue的性能优化有哪些
            编码阶段
                ● 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher
                ● v-if和v-for不能连用
                ● 如果需要使用v-for给每项元素绑定事件时使用事件代理
                ● SPA 页面采用keep-alive缓存组件
                ● key保证唯一
                ● 使用路由懒加载、异步组件
                ● 防抖、节流
                ● 第三方模块按需导入
                ● 长列表滚动到可视区域动态加载
                ● 图片懒加载
            SEO优化
                ● 预渲染（渲染到虚拟DOM上）
                ● 服务端渲染SSR
            打包优化
                ● 压缩代码
                ● Tree Shaking/Scope Hoisting
                ● 使用cdn加载第三方模块
                ● 多线程打包happypack
                ● splitChunks抽离公共文件
                ● sourceMap优化
            用户体验
                ● 骨架屏
                ● PWA
                ● 还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。
        常见的Vue性能优化方法
            路由懒加载
            keep-alive缓存页面
            使用v-show复用DOM
                两个模块来回切换
            v-for 遍历避免同时使用 v-if
            长列表滚动到可视区域动态加载
            图片懒加载
                对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。
            第三方插件按需引入
                像element-ui这样的第三方组件库可以按需引入避免体积太大
            SSR（服务端渲染）
            变量本地化
            子组件分隔
            无状态的组件标记为函数式组件

    vue初始化页面闪动问题
            闪动问题出现原因
                使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于{{message}}的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的。
            解决方案
                我们可以使用 v-cloak 指令来解决这一问题。v-cloak 指令设置样式，这些样式会在 Vue 实例编译结束时，从绑定的 HTML 元素上被移除	
            
            注意
                在简单项目中，使用 v-cloak 指令是解决屏幕闪动的好方法。但在大型、工程化的项目中（webpack、vue-router）只有一个空的 div 元素，元素中的内容是通过路由挂载来实现的，这时我们就不需要用到 v-cloak 指令（大型项目中一般不会出现闪现现象）

    2.生命周期
        说一下Vue的生命周期
            Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -> 渲染、更新 -> 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。

                beforeCreate（创建前）
                    数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据

                created（创建后）
                    实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，可以访问data数据以及methods方法，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 $el 属性（vm实例身上）。

                beforeMount（挂载前）
                    在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上，虚拟DOM生成，此时页面渲染的是未经vue编译的DOM结构

                mounted（挂载后）
                    在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。

                beforeUpdate（更新前）
                    响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。

                updated（更新后）
                    在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。

                beforeDestroy（销毁前）
                    实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例。

                destroyed（销毁后）
                    实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。
    另外还有 keep-alive 独有的生命周期，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，缓存渲染后会执行 activated 钩子函数。
    Vue 子组件和父组件执行顺序
            加载渲染过程
                1.父组件 beforeCreate
                2.父组件 created
                3.父组件 beforeMount
                4.子组件 beforeCreate
                5.子组件 created
                6.子组件 beforeMount
                7.子组件 mounted
                8.父组件 mounted
            更新过程
                1. 父组件 beforeUpdate
                2.子组件 beforeUpdate
                3.子组件 updated
                4.父组件 updated
            销毁过程
                1. 父组件 beforeDestroy
                2.子组件 beforeDestroy
                3.子组件 destroyed
                4.父组件 destoryed

    created和mounted的区别
            created
                在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图，此时可以访问到data数据及methods中的方法等。
            mounted
                在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作（尽量避免），至此初始化过程结束，一般在此阶段会发送ajax请求，开启定时器、绑定自定义事件，订阅消息等初始化操作。
        一般在哪个生命周期请求异步数据
            我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：
            能更快获取到服务端数据，减少页面加载时间，用户体验更好；
            SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性

    keep-alive 中的生命周期哪些
            keep-alive是 Vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染DOM。
                如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。
            当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated钩子函数。

    3.组件通信
        常用的组件间通信方式有哪些？
            父->子组件通信
                props
                    父组件
                        子组件
                            props只能是父组件向子组件进行传值，props使得父子组件之间形成了一个单向下行绑定。子组件的数据会随着父组件不断更新。
                            props 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，同样也可以传递一个函数。
                依赖注入（（provide/ inject））
                    provide / inject是Vue提供的两个钩子，和data、methods是同级的。并且provide的书写形式和data一样。● provide 钩子用来发送数据或方法● inject钩子用来接收数据或方法
                        父组件
                        子组件
                        或者这样写可以访问父组件中的所有属性
            子->父组件通信
                自定义事件（$emit）
                    父组件
                        子组件
                ref/$refs
                    ref： 这个属性用在子组件上，它的引用就指向了子组件的实例。可以通过实例来访问组件的数据和方法。
                        子组件
                        父组件
            父子组件通信
                $parent / $children
                    ● 使用$parent可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）【对象】
    ● 使用$children可以让组件访问子组件的实例，但是，$children并不能保证顺序（如果有多个孩子，不要用索引的方式，可以用$refs打标记），并且访问的数据也不是响应式的。【数组】
                        父组件
                                ref可以获取到某一个DOM节点、组件标签、子组件标签（以便操作子组件的数据与方法）；$children组件实例的属性，可以获取到当前组件的全部子组件【数组】
                        子组件
                            $parent组件实例的属性，可以获取到当前子组件的父组件。从而可以操作父组件的数据和方法
            跨代通信
                $attrs / $listeners（属性/方法）
                    $attrs：继承所有的父组件属性（除了子组件prop接收的属性），一般用在子组件的子元素上【对象形式】
                    $listeners：该属性是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合 v-on="$listeners" 将所有的事件监听器指向这个组件的某个特定的子元素。（相当于子组件继承父组件的事件）【对象形式】
                    inheritAttrs
                        inheritAttrs：默认值 true，继承所有的父组件属性（除 props 的特定绑定）作为普通的HTML特性应用在子组件的根元素上，如果你不希望组件的根元素继承特性设置 inheritAttrs: false ,但是 class 属性会继承。
                            孙子组件中能直接触发父组件的自定义方法的原因在于子组件调用孙子组件时 使用 v-on 绑定了$listeners 属性
                            在子组件中通过v-bind 绑定$attrs属性，孙子组件可以直接获取到父组件中传递下来的props（除了子组件中props声明的）
            所有组件间通讯
                全局事件总线
                    创建事件中心管理组件之间的通信
                    发送事件
                        传递方this.$bus.$emit('xxx',数据）
                    接收事件
                        接收方this.$bus.$on('xxx',this.方法名)/this.$bus.$on('xxx',回调函数)【回调函数写成箭头函数】	
                vuex

    4.vuex
        Vuex 的原理
                vuex概述
                    Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。
                        ● Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
                        ● 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化。
                核心流程及主要功能
                    ● Vue Components 是 vue 组件，组件会触发（dispatch）一些事件或动作，也就是图中的 Actions;
                    ● 在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，不能直接去更改数据，所以会把这个动作提交（Commit）到 Mutations 中;
                    ● 然后 Mutations 就去改变（Mutate）State 中的数据;
                    ● 当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue Components 中去，组件展示更新后的数据，完成一个流程。
                各模块在核心流程中的主要功能
                    ● Vue Components∶ Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。
                    ● dispatch∶操作行为触发方法，是唯一能执行action的方法。
                    ● actions∶ 操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。
                    ● commit∶状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。
                    ● mutations∶状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。
                    ● state∶ 页面状态管理容器对象。集中存储Vuecomponents中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，并进行状态更新。
                    ● getters∶ state对象读取方法。
                总结
                    Vuex 实现了一个单向数据流，在全局拥有一个 State 存放数据，当组件要更改 State 中的数据时，必须通过 Mutation 提交修改信息， Mutation 同时提供了订阅者模式供外部插件调用获取 State 数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走 Action ，但 Action 也是无法直接修改 State 的，还是需要通过Mutation 来修改State的数据。最后，根据 State 的变化，渲染到视图上。
    为什么要用 Vuex
            对于多层嵌套的组件之间传递数据采取传参或者组件间通信的方式将会非常繁琐，而且通常会导致代码无法维护。所以需要把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，组件树构成了一个巨大的"视图"，不管在树的哪个位置，任何组件都能获取状态或者触发行为。另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，代码将会变得更结构化且易维护。而且vuex中的数据是响应式的，只要vuex中的数据更新，依赖他的数据的组件也会跟着更新。
    Vuex有哪几种属性？
            state => 基本数据(数据源存放地)
            getters => 从基本数据派生出来的数据
            mutations => 提交更改数据的方法，同步
            actions => 像一个装饰器，包裹mutations，使之可以异步。
            modules => 模块化Vuex
    Vuex中actions和mutations的区别
            mutations
                mutation中的操作是一系列的同步函数，用于修改state中的变量的的状态。当使用vuex时需要通过commit来提交需要操作的内容。
            actions
                Action 可以包含任意异步操作，Action 提交的是 mutation，而不是直接变更状态。
            区别
                Mutation专注于修改State，理论上是修改State的唯一途径；Action业务代码、异步请求。
                Mutation：必须同步执行；Action：可以异步，但不能直接操作State。
                在视图更新时，先触发actions，actions再触发mutations
    为什么 Vuex 的 mutation 中不能做异步操作？
            每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以将新的状态存下来，然后就可以实现 数据的更新 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。
    Vuex 和 localStorage 的区别
            存储位置区别
                ● vuex存储在内存中
                ● localstorage 则以文件的方式存储在本地，只能存储字符串类型的数据，存储对象需要 JSON的stringify和parse方法进行处理。 读取内存比读取硬盘速度要快
            应用场景区别
                ● Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex用于组件之间的传值。
                ● localstorage是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用 。
            响应式区别
                Vuex能做到数据的响应式
                localstorage不能做到数据的响应式
            时效区别
                刷新页面时vuex存储的值会丢失
                刷新页面时localstorage存储的值不会丢失

    Vuex和单纯的全局对象有什么区别？
            Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
            不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化。

    Vuex的严格模式是什么,有什么作用，如何开启？
            严格模式作用
                在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。
            开启方式

    如何在组件中批量使用Vuex的getter属性
            使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中
                
    如何在组件中重复使用Vuex的mutation

            在组件中使用mapMutation，然后调用this.setNumber(10)相当调用				 			this.$store.commit('SET_NUMBER',10)


    5.router
        对前端路由的理解
            路由
                路由是url到函数的映射，可以根据不同的url地址展示不同的内容或页面。
            服务器端路由（后端路由）
                对于服务器来说，当接收到客户端发来的HTTP请求，会根据请求的URL，来找到相应的映射函数，然后执行该函数，并将函数的返回值发送给客户端。
            客户端路由（前端路由）
                早期的路由都是后端实现的，直接根据 url 来 reload 页面，页面变得越来越复杂服务器端压力变大，随着 ajax 的出现，页面实现非 reload 就能刷新数据，更新页面内容，使内容的切换更加流畅，可以通过记录 url 来记录 ajax 的变化，从而实现前端路由。对于客户端（通常为浏览器）来说，路由的映射函数通常是进行一些DOM的显示和隐藏操作。这样，当访问不同的路径的时候，会显示不同的页面组件。
                    前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步——为 SPA 中的各个视图匹配一个唯一标识。这意味着用户前进、后退触发的新内容，都会映射到不同的 URL 上去。此时即便他刷新页面，因为当前的 URL 可以标识出他所处的位置，因此内容也不会丢失。

    Vue-router跳转和location.href有什么区别
            使用 location.href= ‘/url’ 来跳转，简单方便，但是刷新了页面；
            引进 router ，然后使用 router.push( ‘/url’ ) 来跳转，无刷新页面，静态跳转。使用了 diff 算法，实现了按需加载，减少了 dom 的消耗。使用 router 跳转底层是用history.pushState() 

    $route 和$router 的区别
            $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等，可以使用$router.push()、$router.replace()、$router.go()等
            $route 是“路由信息对象”，包括 name，path，params，query，meta，fullPath，hash、matched等路由信息参数

    params和query的区别
            用法
                query可以用name和path来引入；接收参数this.$route.query.name；在路由信息配置时路径path不需要占位
                params要用name来引入；接收参数this.$route.params.name；在路由信息配置时路径path需要占位
            url地址显示
                query更加类似于ajax中get传参，在浏览器地址栏中显示参数
                params则类似于post，在浏览器地址栏中不显示参数
            刷新
                query刷新不会丢失query里面的数据
                params刷新会丢失 params里面的数据（可考虑采取本地存储解决此问题）


    路由的hash和history模式的区别
            hash模式
                简介
                    hash模式是开发中默认的模式，它的URL带着一个#，例如：http://www.abc.com/#/vue，它的hash值就是#/vue。
                特点
                    hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。
                原理
                    hash模式的主要原理就是onhashchange()事件：
                        使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。
            history模式
                简介
                    history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。
                特点
                    当使用history模式时，URL就像这样：http://abc.com/user/id。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。
                API
                    history api可以分为两大部分，切换历史状态和修改历史状态：
                        修改历史状态
                            包括了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个API。
                        切换历史状态
                            包括forward()、back()、go()三个方法，对应浏览器的前进，后退，跳转操作。
                虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。
                切换为history模式
            调用 history.pushState() 与直接修改 hash对比
                pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；
                pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；
                pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；
                pushState() 可额外设置 title 属性供后续使用。
                hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。

    如何获取页面的hash变化
            监听$route的变化
            window.location.hash读取#值
                window.location.hash 的值可读可写，读取来判断状态是否改变，写入时可以在不重载网页的前提下，添加一条历史访问记录。

    如何定义动态路由？如何获取传过来的动态参数？
            params传参
                路由格式
                    配置路由格式：/router/:id
                    传递的方式：在path后面跟上对应的值
                    传递后形成的路径：/router/123
                定义路由
                接收参数
                    通过 $route.params.userid 获取传递的值
            query传参
                路由格式
                    配置路由格式：/router？key1=value1&key2=value2
                    传递的方式：对象中使用query的key作为传递方式
                    传递后形成的路径：/route?id=123&uname=cara
                定义路由
                接收参数
                    通过$route.query.userid获取传递的值

    Vue-Router 的懒加载如何实现
            非懒加载
            懒加载
                使用箭头函数+import动态加载
                使用箭头函数+require动态加载
                webpack
                    
    Vue-router 导航守卫有哪些
            全局守卫（前置/后置）：beforeEach、beforeResolve、afterEach
            路由独享的守卫：beforeEnter
            组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave
        Vue-router 路由守卫在生命周期的体现



    完整的路由导航解析流程
                ● 触发进入其他路由。
                ● 调用要离开路由的组件守卫beforeRouteLeave
                ● 调用全局前置守卫∶ beforeEach
                ● 在重用的组件里调用 beforeRouteUpdate
                ● 调用路由独享守卫 beforeEnter。
                ● 解析异步路由组件。
                ● 在将要进入的路由组件中调用 beforeRouteEnter
                ● 调用全局解析守卫 beforeResolve
                ● 导航被确认。
                ● 调用全局后置钩子的 afterEach 钩子。
                ● 触发DOM更新（mounted）。
                ● 执行beforeRouteEnter 守卫中传给 next 的回调函数
    触发钩子的完整顺序
                ● beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。
                ● beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。
                ● beforeEnter：路由独享守卫
                ● beforeRouteEnter：路由组件的组件进入路由前钩子。
                ● beforeResolve：路由全局解析守卫
                ● afterEach：路由全局后置钩子
                ● beforeCreate：组件生命周期，不能访问this。
                ● created;组件生命周期，可以访问this，不能访问dom。
                ● beforeMount：组件生命周期
                ● deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。
                ● mounted：访问/操作dom。
                ● activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。
                ● 执行beforeRouteEnter回调函数next。
    导航行为被触发到导航完成的整个过程
                ● 导航行为被触发，此时导航未被确认。
                ● 在失活的组件里调用离开守卫 beforeRouteLeave。
                ● 调用全局的 beforeEach守卫。
                ● 在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。
                ● 在路由配置里调用 beforeEnteY。 
                ● 解析异步路由组件（如果有）。
                ● 在被激活的组件里调用 beforeRouteEnter。
                ● 调用全局的 beforeResolve 守卫（2.5+），标示解析阶段完成。
                ● 导航被确认。
                ● 调用全局的 afterEach 钩子。
                ● 非重用组件，开始组件实例的生命周期：beforeCreate&created、						beforeMount&mounted
                ● 触发 DOM 更新。
                ● 用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数。
                ● 导航完成

    6.vue3.0
        Vue3.0有什么更新
            监测机制的改变
                ● 3.0 将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。
                ● 消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制
                    检测属性的添加和删除；
                    检测数组索引和长度的变更；
                    支持 Map、Set、WeakMap 和 WeakSet。
            模板
                ● 作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。
                ● 同时，对于 render 函数的方面，vue3.0 也进行一系列更改来方便习惯直接使用 api 来生成 vdom 。
            对象式的组件声明方式
                ● vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。
                ● 3.0 修改了组件的声明方式，这样使得和 TypeScript 的结合变得很容易
            其它方面的更改
                ● 支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。
                ● 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。
                ● 基于 tree shaking 优化，提供了更多的内置功能。

    defineProperty和proxy的区别
            defineProperty
                Vue 在实例初始化时遍历 data 中的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。这样当追踪数据发生变化时，setter 会被自动调用。
                存在的问题
                    1. 添加或删除对象的属性时，Vue 检测不到。因为添加或删除的对象没有在初始化进行响应式处理，只能通过$set 来调用Object.defineProperty()处理。
                    2. 无法监控到数组下标和长度的变化。
            proxy
                Vue3 使用 Proxy 来监控数据的变化。Proxy 是 ES6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）
            defineProperty和proxy的区别
                1. Proxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。
                2. Proxy 可以监听数组的变化。

    Vue3.0 为什么要用 proxy？
            在 Vue2 中， 0bject.defineProperty 会改变原始数据，而 Proxy 是创建对象的虚拟表示，并提供 set 、get 和 deleteProperty 等处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截，有以下特点∶
                ● 不需用使用 Vue.$set 或 Vue.$delete 触发响应式。
                ● 全方位的数组变化检测，消除了Vue2 无效的边界情况。
                ● 支持 Map，Set，WeakMap 和 WeakSet。
            Proxy 实现的响应式原理与 Vue2的实现原理相同，实现方式大同小异∶ 
                ● get 收集依赖
                ● set、delete 等触发依赖
                ● 对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执行依赖相关的收集或触发逻辑。

    Vue 3.0 中的 Vue Composition API？
            在 Vue2 中，代码是 Options API 风格的，也就是通过填充 (option) data、methods、computed 等属性来完成一个 Vue 组件。造成了几个问题：
                1. 由于 Options API 不够灵活的开发方式，使得Vue开发缺乏优雅的方法来在组件间共用代码。
                2. Vue 组件过于依赖this上下文，Vue 背后的一些小技巧使得 Vue 组件的开发看起来与 JavaScript 的开发原则相悖，比如在methods 中的this竟然指向组件实例来不指向methods所在的对象。这也使得 TypeScript 在Vue2 中很不好用。
            Vue3 中，舍弃了 Options API，转而投向 Composition API。Composition API本质上是将 Options API 背后的机制暴露给用户直接使用，这样用户就拥有了更多的灵活性，也使得 Vue3 更适合于 TypeScript 结合。
                Vue Composition API 使得 Vue3 的开发风格更接近于原生 JavaScript，带给开发者更多地灵活性

    7.虚拟DOM
        对虚拟DOM的理解？
            虚拟DOM就是用来描述真实DOM的javaScript对象，可以将多次修改的DOM一次性渲染到页面上，减少页面的重排重绘，提高渲染性能。 在代码渲染到页面之前，vue会把代码转换成一个对象（虚拟 DOM）。在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，现在的虚拟DOM会与缓存的虚拟DOM进行比较。在vue内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。
        虚拟DOM的解析过程
            ● 首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来并将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。
            ● 当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。
            ● 最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。
        为什么要用虚拟DOM
            保证性能下限，在不进行手动优化的情况下，提供过得去的性能
                页面渲染的流程
                    解析HTML -> 生成DOM -> 生成 CSSOM -> Layout -> Paint -> Compiler
                对比修改DOM时真实DOM操作和虚拟DOM的过程
                    真实DOM∶ 生成HTML字符串＋重建所有的DOM元素
                    虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新
            跨平台
                Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。
        虚拟DOM真的比真实DOM性能好吗
            首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。
            正如它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。
    DIFF算法的原理
            ● 首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换
            ● 如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的没有子节点，将旧的子节点移除)
            ● 比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。
            ● 匹配时，找到相同的子节点，递归比较子节点
            ● 更新差异，复用节点

    Vue中key的作用
            第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。
            第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。
            总结
                vue为了更高效的渲染元素，会尽可能的复用元素，而非从头渲染，key可以为节点打标记，而非简单的复用节点。当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则
                    旧虚拟DOM中找到了与新虚拟DOM相同的key
                        若虚拟DOM中内容没变, 直接使用之前的真实DOM
                        若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM
                    旧虚拟DOM中未找到与新虚拟DOM相同的key
                        创建新的真实DOM，随后渲染到到页面


    为什么不建议用index作为key?
            若对数据进行：逆序添加、逆序删除等破坏顺序操作:会产生没有必要的真实DOM更新 ==> 界面效果没问题, 但效率低
            如果逆序添加、逆序删除等破坏顺序的操作且结构中还包含输入类的DOM：会产生错误DOM更新 ==> 界面有问题



    计算机网络
    Http协议
        什么是HTTP及HTTPS?HTTP和HTTPS协议的区别
            HTTP
                概念
                    HTTP即超文本运输协议，是实现网络通信的一种规范，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。
    HTTP是一个传输协议，即将数据由A传到B或将B传输到A，并且 A 与 B 之间能够存放很多第三方，如： A<=>X<=>Y<=>Z<=>B；传输的数据并不是计算机底层中的二进制包，而是完整的、有意义的数据，如HTML 文件, 图片文件, 查询结果等超文本，能够被上层应用识别；在实际应用中，HTTP常被用于在Web浏览器和网站服务器之间传递信息，以明文方式发送内容，不提供任何方式的数据加密
                特点/优点
                    支持客户/服务器模式
                    简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快
                    灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记
                    无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间
                    无状态：HTTP协议无法根据之前的状态进行本次的请求处理
                缺点
                    无状态
                        HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。
                    明文传输
                        协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。
                    不安全
                        通信使用明文（不加密），内容可能会被窃听；
                        不验证通信方的身份，因此有可能遭遇伪装；
                        无法证明报文的完整性，所以有可能已遭篡改；
    HTTPS
                概念
                    为了保证这些隐私数据能加密传输，让HTTP运行安全的SSL/TLS协议上，即 HTTPS = HTTP + SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密；SSL 协议位于TCP/IP 协议与各种应用层协议之间，浏览器和服务器在使用 SSL 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持
                流程
                        首先客户端通过URL访问服务器建立SSL连接
                        服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端
                        客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级
                        客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站
                        服务器利用自己的私钥解密出会话密钥
                        服务器利用会话密钥加密与客户端之间的通信
    HTTPS的特点
                    HTTPS的优点
                        ● 使用HTTPS协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器；
                        ● 使用HTTPS协议可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性；
                        ● HTTPS是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本；
                    HTTPS的缺点
                        ● HTTPS需要做服务器和客户端双方的加密个解密处理，耗费更多服务器资源，过程复杂；
                        ● HTTPS协议握手阶段比较费时，增加页面的加载时间；
                        ● SSL证书是收费的，功能越强大的证书费用越高；
                        ● HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本；
                        ● SSL证书需要绑定IP，不能再同一个IP上绑定多个域名。
    区别
                HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理，相对更安全
                HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443
                HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP
                HTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高
        常见的HTTP请求方法
            ● GET: 向服务器获取数据；
            ● POST：将实体提交到指定的资源，通常会造成服务器资源的修改；
            ● PUT：上传文件，更新数据；
            ● DELETE：删除服务器上的对象；
            ● HEAD：获取报文首部，与GET相比，不返回报文主体部分；
            ● OPTIONS：询问支持的请求方法，用来跨域请求；
            ● CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信；
            ● TRACE: 回显服务器收到的请求，主要⽤于测试或诊断。

    GET和POST的请求的区别 
            GET: 向服务器获取数据，POST：将实体提交到指定的资源，通常会造成服务器资源的修改；区别为
                应用场景
                    GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。
                是否缓存
                    因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。
                发送的报文格式
                    Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。
                参数传递方式
                    GET参数通过URL传递，POST放在Request body中
                安全性
                    Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。
                请求长度
                    浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。
                参数类型
                    get的参数类型只接受ASCII字符，post 的参数传递支持更多的数据类型。
        GET方法URL长度限制的原因
            实际上HTTP协议规范并没有对get方法请求的url长度进行限制，这个限制是特定的浏览器及服务器对它的限制。get方法中的URL长度最长不超过2083个字符，这样所有的浏览器和服务器都可能正常工作。
    POST和PUT请求的区别
            ● PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时更新数据）
            ● POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是创建数据）
        OPTIONS请求方法及使用场景
            OPTIONS：询问支持的请求方法，用来跨域请求；通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。该请求方法的响应不能缓存。主要用途
                获取服务器支持的所有HTTP请求方法；
                用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。
    HTTP请求报文的是什么样的？
            组成
                ● 请求⾏ 
                    请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。 
                ● 请求头部 
                    请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔  
                        ● User-Agent：产⽣请求的浏览器类型。 
                        ● Accept：客户端可识别的内容类型列表。 
                        ● Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。
                ● 空⾏
                ● 请求体 
                    post put等请求携带的数据
            
    HTTP响应报文的是什么样的？
            组成
                ● 响应⾏ 
                    由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK 
                ● 响应头 
                    响应部⾸组成 
                ● 空⾏
                ● 响应体
                    服务器响应的数据 
    常见的HTTP请求头和响应头
            HTTP Request Header 常见的请求头
                ● Accept:浏览器能够处理的内容类型
                ● Accept-Charset:浏览器能够显示的字符集
                ● Accept-Encoding：浏览器能够处理的压缩编码
                ● Accept-Language：浏览器当前设置的语言
                ● Connection：浏览器与服务器之间连接的类型
                ● Cookie：当前页面设置的任何Cookie
                ● Host：发出请求的页面所在的域
                ● Referer：发出请求的页面的URL
                ● User-Agent：浏览器的用户代理字符串
            HTTP Responses Header 常见的响应头
                ● Date：表示消息发送的时间，时间的描述格式由rfc822定义
                ● server:服务器名称
                ● Connection：浏览器与服务器之间连接的类型
                ● Cache-Control：控制HTTP缓存
                ● content-type:表示后面的文档属于什么MIME类型
        与缓存相关的HTTP请求头有哪些
            强缓存
                ● Expires
                ● Cache-Control
            协商缓存
                ● Etag、If-None-Match
                ● Last-Modified、If-Modified-Since

    URL有哪些组成部分
            http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name
                协议部分
                    该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在"HTTP"后面的“//”为分隔符；
                域名部分
                    该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用
                端口部分
                    跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口（HTTP协议默认端口是80，HTTPS协议默认端口是443）
                虚拟目录部分
                    从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”；
                文件名部分
                    从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；
                参数部分
                    从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。
                锚部分
                    从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分；
    端口号的作用
            一台主机(对应一个IP地址)可以提供很多服务。如果只有一个IP，就无法区分不同的网络服务，所以采用”IP+端口号”来区分不同的服务。
        HTTP协议的性能怎么样 
            HTTP 协议是基于 TCP/IP，并且使用了请求-应答的通信模式，所以性能的关键就在这两点里。
                长连接
                    连接模式分类
                        HTTP协议有两种连接模式，一种是持续连接（长连接），一种非持续连接（短连接）。
                            非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。
                            持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。
                    HTTP不同版本的采用不同的连接方式
                        ● 在HTTP/1.0 每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。该版本使用的非持续的连接，但是可以在请求时，加上 Connection: keep-alive 来要求服务器不要关闭 TCP 连接。
                            
                        ● 在HTTP/1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。该版本及以后版本默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。
                            
                管道网络传输
                    HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。管道（pipeline）网络传输是指：可以在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序回应请求。如果前面的回应特别慢，后面就会有许多请求排队等着。这称为队头堵塞。
                        队头堵塞
                            HTTP 传输的报文必须是一发一收，但是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是HTTP队头阻塞问题。解决方案
                                并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。
                                域名分片：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。
    对keep-Alive的理解
            HTTP1.0 中默认是在每次请求/应答，客户端和服务器都要新建一个连接，完成之后立即断开连接，这就是短连接。当使用Keep-Alive模式时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接，这就是长连接。
                不同版本HTTP的keep-Alive使用方法
                    ● TTP1.0版本是默认没有Keep-alive的，所以要想连接得到保持，必须手动配置发送Connection: keep-alive字段。若想断开keep-alive连接，需发送Connection:close字段；
                    ● HTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送Connection：close首部字段。
                Keep-Alive的建立过程
                    ● 客户端向服务器在发送请求报文同时在首部添加发送Connection字段
                    ● 服务器收到请求并处理 Connection字段
                    ● 服务器回送Connection:Keep-Alive字段给客户端
                    ● 客户端接收到Connection字段
                    ● Keep-Alive连接建立成功
                服务端自动断开过程
                    ● 客户端向服务器只是发送内容报文（不包含Connection字段）
                    ● 服务器收到请求并处理
                    ● 服务器返回客户端请求的资源并关闭连接
                    ● 客户端接收资源，发现没有Connection字段，断开连接
                客户端请求断开连接过程
                    ● 客户端向服务器发送Connection:close字段
                    ● 服务器收到请求并处理connection字段
                    ● 服务器回送响应资源并断开连接
                    ● 客户端接收资源并断开连接
                开启Keep-Alive的优点
                    ● 较少的CPU和内存的使⽤（由于同时打开的连接的减少了）；
                    ● 允许请求和应答的HTTP管线化； 
                    ● 降低拥塞控制 （TCP连接减少了）； 
                    ● 减少了后续请求的延迟（⽆需再进⾏握⼿）； 
                    ● 报告错误⽆需关闭TCP连接；
                开启Keep-Alive的缺点
                    长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。
    HTTP 1.0 和 HTTP 1.1 之间有哪些区别？
            连接方面
                http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。
            资源请求方面
                在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
            缓存方面
                在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。
            新增了 host 字段
                http1.1 中新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。
            请求方法
                http1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。
    HTTP 1.1 和 HTTP 2.0 的区别
            二进制协议
                HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。
            多路复用
                HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了"队头堵塞"的问题。
            数据流
                HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。
            头信息压缩
                HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。
            服务器推送
                HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。
    HTTP2的头部压缩算法是怎样的？
            原理
                HTTP2的头部压缩是HPACK算法。在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。
                    ● 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；
                    ● 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新；
                    ● 每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。
            例子
                例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。
                    
    说一下HTTP 3.0
            HTTP/3基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。
                    流量控制、传输可靠性功能
                        QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。
                    集成TLS加密功能
                        目前QUIC使用TLS1.3，减少了握手所花费的RTT数。
                    多路复用
                        同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题。
                    快速握手
                        由于基于UDP，可以实现使用0 ~ 1个RTT来建立连接。

    当在浏览器中输入 Google.com 并且按下回车之后发生了什么？
            解析URL
                首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。
            缓存判断
                浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。
            DNS解析
                下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。
            获取MAC地址
                当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。
            TCP三次握手
                下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。
            HTTPS握手
                如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。
            返回数据
                当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。
            页面渲染
                浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。

    TCP四次挥手
                最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。
        页面有多张图片，HTTP是怎样的加载表现？
            ● 在HTTP 1.1下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用多域名部署解决。这样可以提高同时请求的数目，加快页面图片的获取速度。
            ● 在HTTP 2下，可以一瞬间加载出来很多资源，因为，HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。

    Https协议
        什么是HTTPS协议？
            超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。安全层的主要职责就是对发起的HTTP请求的数据进行加密操作 和 对接收到的HTTP的内容进行解密操作。
        TLS/SSL的工作原理
            TLS/SSL全称安全传输层协议（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。TLS/SSL的功能实现主要依赖三类基本算法
                散列函数hash
                    基于散列函数验证信息的完整性
                对称加密
                    对称加密算法采用协商的秘钥对数据加密
                非对称加密
                    非对称加密实现身份认证和秘钥协商
    数字证书是什么？
            数字证书产生的原因
                现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用数字证书。
            数字证书概念及工作原理
                首先使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。要进行对比，就能发现得到的信息是否被更改了。
    HTTPS通信（握手）过程
            1. 客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。
            2. 服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。
            3. 客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。
            4. 服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。
            5. 客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。
    HTTPS的特点
            HTTPS的优点
                ● 使用HTTPS协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器；
                ● 使用HTTPS协议可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性；
                ● HTTPS是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本；
            HTTPS的缺点
                ● HTTPS需要做服务器和客户端双方的加密个解密处理，耗费更多服务器资源，过程复杂；
                ● HTTPS协议握手阶段比较费时，增加页面的加载时间；
                ● SSL证书是收费的，功能越强大的证书费用越高；
                ● HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本；
                ● SSL证书需要绑定IP，不能再同一个IP上绑定多个域名。
    HTTPS是如何保证安全的？
            对称加密与非对称加密
                对称加密：即通信的双⽅都使⽤同⼀个秘钥进⾏加解密，对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥。 
                ⾮对称加密
                    私钥 + 公钥= 密钥对 
                    即⽤私钥加密的数据,只有对应的公钥才能解密,⽤公钥加密的数据,只有对应的私钥才能解密 
                    因为通信双⽅的⼿⾥都有⼀套⾃⼰的密钥对,通信之前双⽅会先把⾃⼰的公钥都先发给对⽅ 
                    然后对⽅再拿着这个公钥来加密数据响应给对⽅,等到到了对⽅那⾥,对⽅再⽤⾃⼰的私钥进⾏解密 
            HTTPS是如何保证安全的
                结合两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。 此时⼜带来⼀个问题，中间⼈问题：如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。 所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。 证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的HASH算法、证书到期时间等。但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，数字签名。 数字签名就是⽤CA⾃带的HASH算法对证书的内容进⾏HASH得到⼀个摘要，再⽤CA的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的Hash算法,再次⽣成消息摘要，然后⽤CA的公钥对数字签名解密,得到CA创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了。 

    Http状态码
        常见的状态码
                1XX
                    100:（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应
                    101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级
                2XX
                    200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回
                    201（已创建）：请求成功并且服务器创建了新的资源
                    202（已创建）：服务器已经接收请求，但尚未处理
                    203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源
                    204（无内容）：服务器成功处理请求，但没有返回任何内容
                    205（重置内容）：服务器成功处理请求，但没有返回任何内容
                    206（部分内容）：服务器成功处理了部分请求
                3XX
                    300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择
                    301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置
                    302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
                    303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码
                    304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
                    305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理
                    307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求,临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求
                4XX
                    400（错误请求）： 服务器不理解请求的语法
                    401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
                    403（禁止）： 服务器拒绝请求
                    404（未找到）： 服务器找不到请求的网页
                    405（方法禁用）： 禁用请求中指定的方法
                    406（不接受）： 无法使用请求的内容特性响应请求的网页
                    407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理
                    408（请求超时）： 服务器等候请求时发生超时
                5XX
                    500（服务器内部错误）：服务器遇到错误，无法完成请求
                    501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码
                    502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应
                    503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）
                    504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求
                    505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本
        HTTP状态码304是多好还是少好
            服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。状态码304不应该认为是一种错误，而是对客户端有缓存情况下服务端的一种响应。搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累的回访率也会提高。
    同样是重定向，307，303，302的区别？ 
            302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码⼜出来了两个303和307。 303明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。 307会遵照浏览器标准，不会从post变为get。

    DNS
        DNS 协议是什么
            概念
                DNS域名系统，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器，简单来讲，DNS相当于一个翻译官，负责将域名翻译成ip地址，它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。
                        IP 地址：一长串能够唯一地标记网络上的计算机的数字
                        域名：是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识。域名是一个具有层次的结构，从上到下一次为根域名、顶级域名、二级域名、三级域名...
                            www.xxx.com，www为三级域名、xxx为二级域名、com为顶级域名，系统为用户做了兼容，域名末尾的根域名.一般不需要输入
            作用
                将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。
        DNS同时使用TCP和UDP协议？
            在区域传输的时候使用TCP协议
                ● 辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。
                ● TCP是一种可靠连接，保证了数据的准确性。
            在域名解析的时候使用UDP协议
                客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。
        DNS的查询方式
            递归查询
                指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。
                    
            迭代查询
                指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。
                    
        DNS完整的查询过程
            
                首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表
                若没有命中，则继续搜索操作系统的 DNS 缓存
                若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果
                若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询
                    首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器
                    本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址
                    本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址
                本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来
                操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起
                至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起

    TCP和UDP
        TCP 和 UDP的概念及特点
            UDP
                概念
                    UDP的全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。
                特点
                    面向无连接
                        首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。
                            ● 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
                            ● 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作
                    有单播，多播，广播的功能
                        UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。
                    面向报文
                        发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文
                    不可靠性
                        首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。
                        并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。
                        再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。
                    头部开销小，传输数据报文时是很高效的
            TCP
                概念
                    TCP的全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是面向连接的、可靠的流协议（流就是指不间断的数据结构）。
                特点
                    面向连接
                        面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。
                    仅支持单播传输
                        每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。
                    面向字节流
                        TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输
                    可靠传输
                        对于可靠传输，判断丢包、误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。
                    提供拥塞控制
                        当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。
                    提供全双工通信
                        TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS
        TCP和UDP的区别
            
        TCP和UDP的使用场景
            TCP应用场景
                效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。
            UDP应用场景
                效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。
        UDP协议为什么不可靠？
            UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付
                ● 不保证消息交付：不确认，不重传，无超时
                ● 不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞
                ● 不跟踪连接状态：不必建立连接或重启状态机
                ● 不进行拥塞控制：不内置客户端或网络反馈机制

    TCP的三次握手和四次挥手
            三次握手
                三次握手作用
                    三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。
                三次握手过程
                    刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。
                        第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。
                        第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。
                        第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。
                为什么不是两次握手
                    每次握手的作用
                        第一次握手：客户端发送网络包，服务端收到了 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
                        第二次握手：服务端发包，客户端收到了 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常
                        第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常
                    为什么不是两次握手原因
                        如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到 无法确定自己发的包对方能收到
                        并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源
            四次挥手
                四次挥手过程
                    刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：
                        第一次挥手： 客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。
                        第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。
                        第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。
                        第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。
                四次挥手原因
                    因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手；TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭。
        TCP的重传机制
            由于TCP的下层网络（网络层）可能出现丢失、重复或失序的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。TCP使用两套独立的机制来完成重传，一是基于时间，二是基于确认信息。TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。
        TCP的拥塞控制机制
            TCP的拥塞控制机制主要是以下四种机制
                ● 慢启动（慢开始）
                    ● 在开始发送的时候设置cwnd = 1（cwnd指的是拥塞窗口）
                    ● 思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。
                    ● 为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)
                        ○ 当cnwd < ssthresh，使用慢开始算法
                        ○ 当cnwd = ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法
                        ○ 当cnwd > ssthresh，使用拥塞避免算法
                ● 拥塞避免
                    ● 拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。
                    ● 思路： 让拥塞窗口cwnd缓慢的增大，即每经过一个返回时间RTT就把发送方的拥塞控制窗口加一
                    ● 无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。
                    其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。
                ● 快速重传
                    ● 快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。
                    ● 由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量
                ● 快速恢复
                    ● 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。
                    ● 考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。
        TCP的流量控制机制
            一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的滑动窗口进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。
                ● 当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。
                ● 当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。）
                ● 如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。
                ● 如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。
        TCP的可靠传输机制
            TCP 的可靠传输机制是基于连续 ARQ 协议和滑动窗口协议的。TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但 未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发 送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。 如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如 果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送 但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示， 说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发 送但确认的报文段。接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文 段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都 已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文 段的发送速率。但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重 传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。
    TCP粘包是怎么回事，如何处理? 
            什么是粘包
                连续调⽤两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下⼏种常⻅的情况:，其中的 BCD 就是我们常⻅的粘包的情况
                    A. 先接收到 data1, 然后接收到 data2 . 
                    B. 先接收到 data1 的部分数据, 然后接收到 data1 余下的部分以及 data2 的全部. 
                    C. 先接收到了 data1 的全部数据和 data2 的部分数据, 然后接收到了 data2 的余下的数据. 
                    D. ⼀次性接收到了 data1 和 data2 的全部数据. 
            如何处理粘包
                多次发送之前间隔⼀个等待时间
                    只需要等上⼀段时间再进⾏下⼀次 send 就好, 适⽤于交互频率特别低的场景. 缺点也很明显, 对于⽐较频繁的场景⽽⾔传输效率实在太低，不过⼏乎不⽤做什么处理. 
                关闭 Nagle 算法
                    关闭 Nagle 算法, 在 Node.js 中你可以通过 socket.setNoDelay() ⽅法来关闭 Nagle 算法, 让每⼀次 send 都不缓冲直接发送。该⽅法⽐较适⽤于每次发送的数据都⽐较⼤ (但不是⽂件那么⼤), 并且频率不是特别⾼的场景。如果是每次发送的数据量⽐较⼩, 并且频率特别⾼的, 关闭 Nagle 纯属⾃废武功。另外, 该⽅法不适⽤于⽹络较差的情况, 因为 Nagle 算法是在服务端进⾏的包合并情况, 但是如果短时间内客户端的⽹络情况不好, 或者应⽤层由于某些原因不能及时将 TCP 的数据 recv, 就会造成多个包在客户端缓冲从⽽粘包的情况。 (如果是在稳定的机房内部通信那么这个概率是⽐较⼩可以选择忽略的)  
                进⾏封包/拆包
                    封包/拆包是⽬前业内常⻅的解决⽅案了。即给每个数据包在发送之前, 于其前/后放⼀些有特征的数据, 然后收到数据的时 候根据特征数据分割出来各个数据包。
    为什么UDP不会粘包？ 
            ● TCP协议是⾯向流的协议，UDP是⾯向消息的协议。UDP段都是⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据 
            ● UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易进⾏区分处理了。传输协议把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收。

    网络模型
        OSI七层模型               
            OSI概念
                OSI （Open System Interconnect）模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。OSI将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。即每一层扮演固定的角色，互不打扰
            OSI七层模型
                    应用层
                        OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。
                            ● 在客户端与服务器中经常会有数据的请求，这个时候就是会用到http(hyper text transfer protocol)(超文本传输协议)或者https.在后端设计数据接口时，我们常常使用到这个协议。
                            ● FTP是文件传输协议，在开发过程中，个人并没有涉及到，但是我想，在一些资源网站，比如百度网盘``迅雷应该是基于此协议的。
                            ● SMTP是simple mail transfer protocol（简单邮件传输协议）。在一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议。
                    表示层
                        表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。在项目开发中，为了方便数据传输，可以使用base64对数据进行编解码。如果按功能来划分，base64应该是工作在表示层。
                    会话层
                        会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。
                    传输层
                        传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。
                    网络层
                        本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。我们可以这样理解，网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式。
                    数据链路层
                        将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。
    网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，在数据链路层上还增加了差错控制的功能。
                    物理层
                        实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。
    OSI七层模型通信特点
                对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。
            传输过程
                    应用层报文被传送到运输层
                    在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用
                    应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变
                    运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报
                    网络层数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧
                    在物理层数据帧被封装成比特流，之后通过传输介质传送到对端
                    对端再一步步解开封装，获取到传送的数据
        TCP/IP五层协议
            TCP/IP概念
                TCP/IP，传输控制协议/网际协议，是指能够在多个不同网络间实现信息传输的协议簇，TCP/IP协议不仅仅指的是TCP和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇，只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols）
                    TCP（传输控制协议）
                        一种面向连接的、可靠的、基于字节流的传输层通信协议
                    IP（网际协议）
                        用于封包交换数据网络的协议
            TCP/IP体系分类
                五层体系
                    五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层，五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构
                        
                            应用层
                                TCP/IP 模型将 OSI参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务。如：FTP、Telnet、DNS、SMTP 等
                            传输层
                                该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能；传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）；其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输
                            网络层
                                负责为分组网络中的不同主机提供通信服务，并通过选择合适的路由将数据传递到目标主机；在发送数据时，网络层把运输层产生的报文段或用户数据封装成分组或包进行传送
                            数据链路层
                                数据链路层在两个相邻节点传输数据时，将网络层交下来的IP数据报组装成帧，在两个相邻节点之间的链路上传送帧
                            物理层
                                保证数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境
                四层体系
            特点
                TCP/IP协议的通信方式也是对等通信
            OSI 参考模型与 TCP/IP 参考模型对比
                相同点
                    OSI 参考模型与 TCP/IP 参考模型都采用了层次结构
                    都能够提供面向连接和无连接两种通信服务机制
                区别
                    OSI 采用的七层模型； TCP/IP 是四层或五层结构
                    TCP/IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分
                    OSI 参考模型虽然网络划分为七层，但实现起来较困难。TCP/IP 参考模型作为一种简化的分层结构是可以的
                    TCP/IP协议去掉表示层和会话层的原因在于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 OSI 设想中的应用程序维度的分层是无法实现的

    Websocket
        对 WebSocket 的理解
            概念
                WebSocket是HTML5提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。WebSocket 的出现就解决了半双工通信的弊端。它最大的特点是：服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。
            WebSocket原理
                客户端向 WebSocket 服务器通知（notify）一个带有所有接收者ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有ID在接收者ID序列中的客户端才会处理这个事件。
            特点
                ● 支持双向通信，实时性更强，相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少
                ● 可以发送文本，也可以发送二进制数据‘’
                ● 建立在TCP协议之上，服务端的实现比较容易
                ● 数据格式比较轻量，性能开销小，通信高效
                ● 没有同源限制，客户端可以与任意服务器通信
                ● 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL
                ● 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
            应用场景
                弹幕
                媒体聊天
                协同编辑
                基于位置的应用
                体育实况更新
                股票基金报价实时更新

    浏览器原理
    浏览器安全
        什么是 XSS 攻击？     
            概念
                XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。
            攻击类型
                存储型
                    存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。
                反射型
                    反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。
                DOM 型
                    DOM 型指的通过修改页面的 DOM 节点形成的 XSS。
        如何防御 XSS 攻击？
            可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。
            使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。
        什么是 CSRF 攻击？
            概念
                CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。CSRF 攻击的本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。
            攻击类型
                ● GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。
                ●  POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。
                ● 链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。
        如何防御 CSRF 攻击？
            进行同源检测
                服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）
            使用 CSRF Token 进行验证
                服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。
            对 Cookie 进行双重验证
                服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。
            在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能被第三方使用
                在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。
        什么是中间人攻击？如何防范中间人攻击？
            中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。
        有哪些可能引起前端安全的问题? 
            ● 跨站脚本 (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不限于 JavaScript / CSS / Flash 等； 
            ● iframe的滥⽤: iframe中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在iframe中运⾏JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端⽤户体验；
            ● 跨站点请求伪造（Cross-Site Request Forgeries，CSRF）: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击 
            ● 恶意第三⽅库: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。
        网络劫持有哪几种，如何防范？
            网络劫持分类
                HTTP劫持
                    (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告) 
                DNS劫持
                    (输⼊京东被强制跳转到淘宝这就属于dns劫持)DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器
            防范
                DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。

    进程与线程
        进程与线程的概念
            进程和线程都是 CPU 工作时间片的一个描述，进程是资源分配的最小单位，线程是CPU调度的最小单位
                进程
                    进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。
                线程
                    线程是进程中的更小单位，描述了执行一段指令所需的时间。
                进程和线程之间关系的特点
                    进程中的任意一线程执行出错，都会导致整个进程的崩溃。
                    线程之间共享进程中的数据。
                    当一个进程关闭之后，操作系统会回收进程所占用的内存
                    进程之间的内容相互隔离，进程隔离就是为了使操作系统中的进程互不干扰，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的
        进程和线程的区别
            ● 进程可以看做独立应用，线程不能
            ● 资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。
            ● 通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。
            ● 调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
            ● 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。
        浏览器渲染进程的线程有哪些
            
                GUI渲染线程
                    负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要重绘或由于某种操作引发回流时，该线程就会执行。注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。
                JS引擎线程
                    JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。
                事件触发线程
                    事件触发线程属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；
                定时器触发线程
                    定时器触发进程即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。
                异步http请求线程
                    ● XMLHttpRequest连接后通过浏览器新开一个线程请求；
                    ● 检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；
        进程之间的通信方式
            管道通信
                概念
                    管道是一种最基本的进程间通信机制。管道就是操作系统在内核中开辟的一段缓冲区，进程1可以将需要交互的数据拷贝到这段缓冲区，进程2就可以读取了。
                特点
                    ● 只能单向通信
                    ● 只能血缘关系的进程进行通信
                    ● 依赖于文件系统
                    ● 生命周期随进程
                    ● 面向字节流的服务
                    ● 管道内部提供了同步机制
            消息队列通信
                消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。使用消息队列进行进程间通信，可能会收到数据块最大长度的限制约束等，这也是这种通信方式的缺点。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。
            信号量通信
                共享内存最大的问题就是多进程竞争内存的问题，就像类似于线程安全问题。我们可以使用信号量来解决这个问题。信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。
            信号通信
                信号（Signals ）是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。
            共享内存通信
                共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
            套接字通信
                上面我们说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。
        僵尸进程和孤儿进程是什么？
            孤儿进程
                父进程退出了，而它的一个或多个进程还在运行，那这些子进程都会成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
            僵尸进程
                子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。
        死锁产生的原因？ 如果预防死锁的问题？
            概念
                所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。
            产生死锁的原因
                竞争资源
                    产生死锁中的竞争资源之一指的是竞争不可剥夺资源（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）
                        可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；
                        不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。
                    产生死锁中的竞争资源另外一种资源指的是竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁
                进程间推进顺序非法
                    若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁
            产生死锁的必要条件
                ● 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
                ● 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
                ● 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
                ● 环路等待条件：在发生死锁时，必然存在一个进程——资源的环形链。
            预防死锁的方法
                ● 资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）
                ● 只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）
                ● 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
                ● 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）
        如何实现浏览器内多个标签页之间的通信?
            实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下
                ● 使用 websocket 协议，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。
                ● 使用 ShareWorker 的方式，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。
                ● 使用 localStorage 的方式，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。
                ● 使用 postMessage 方法，如果我们能够获得对应标签页的引用，就可以使用postMessage 方法，进行通信。
        对Service Worker的理解
            Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。

    浏览器缓存
        对浏览器的缓存机制的理解
            
                ● 浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；
                ● 下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 expires 头判断是否过期；
                ● 如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；
                ● 服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；
                ● 如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；
        浏览器资源缓存的位置有哪些？
            资源缓存的位置一共有 3 种，按优先级从高到低分别是
                Service Worker
                    Service Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。当 Service Worker 没有命中缓存的时候，需要去调用 fetch 函数获取  数据。也就是说，如果没有在 Service Worker 命中缓存，会根据缓存查找优先级去查找数据。但是不管是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示是从 Service Worker 中获取的内容。
                Memory Cache
                    Memory Cache 就是内存缓存，它的效率最快，但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。
                Disk Cache
                    Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。
        协商缓存和强缓存的区别
            强缓存
                使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。
            协商缓存
                如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。命中协商缓存的条件有两个：max-age=xxx 过期了；值为no-cache。使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。
                    ● no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；
                    ● no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。
            总结
                强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。
        为什么需要浏览器缓存？
            对于浏览器的缓存，主要针对的是前端的静态资源，最好的效果就是，在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。所谓的浏览器缓存指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。
            使用浏览器缓存的优点
                ● 减少了服务器的负担，提高了网站的性能
                ● 加快了客户端网页的加载速度
                ● 减少了多余网络数据传输
        点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？
            ● 点击刷新按钮或者按 F5：浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。
            ● 用户按 Ctrl+F5（强制刷新）：浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。
            ● 地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。

    浏览器组成
        对浏览器的理解
            浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。浏览器可以分为两部分，shell 和 内核。
                ● shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。
                ● 内核是浏览器的核心。内核是基于标记语言显示内容的程序或模块。
        对浏览器内核的理解
            浏览器内核主要分成两部分
                ● 渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。
                ● JS 引擎：解析和执行 javascript 来实现网页的动态效果。
        常见的浏览器内核比较
            ● Trident：这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。
            ● Gecko：这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。
            ● Presto：Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。
            ● Webkit：Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。
            ● Blink：谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。
        常见浏览器所用内核
            （1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；
            （2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；
            （3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；
            （4） Safari 浏览器内核：Webkit 内核；
            （5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；
            （6） 360浏览器、猎豹浏览器内核：IE + Chrome 双内核；
            （7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；
            （8） 百度浏览器、世界之窗内核：IE 内核；
            （9） 2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；
            （10）UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说是基于火狐内核。
        浏览器的主要组成部分
            ● ⽤户界⾯ - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗⼝显示的您请求的⻚⾯外，其他显示的各个部分都属于⽤户界⾯。 
            ● 浏览器引擎 - 在⽤户界⾯和呈现引擎之间传送指令。 
            ● 呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。 
            ● ⽹络 - ⽤于⽹络调⽤，⽐如 HTTP 请求。其接⼝与平台⽆关，并为所有平台提供底层实现。 
            ● ⽤户界⾯后端 - ⽤于绘制基本的窗⼝⼩部件，⽐如组合框和窗⼝。其公开了与平台⽆关的通⽤接⼝，⽽在底层使⽤操作系统的⽤户界⾯⽅法。 
            ● JavaScript 解释器。⽤于解析和执⾏ JavaScript 代码。 
            ● 数据存储 - 这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“⽹络数据库”，这是⼀个完整（但是轻便）的浏览器内数据库。
            注意
                值得注意的是，和⼤多数浏览器不同，Chrome 浏览器的每个标签⻚都分别对应⼀个呈现引擎实例。每个标签⻚都是⼀个独⽴的进程。

    浏览器渲染和原理
        浏览器的渲染过程
            注意：这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。
                ● 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。
                ● 然后对 CSS 进行解析，生成 CSSOM 规则树。
                ● 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。
                ● 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。
                ● 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。
        浏览器渲染优化
            针对JavaScript
                JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。因此我们可以对JavaScript的加载方式进行改变，来进行优化
                    尽量将JavaScript文件放在body的最后
                    <script>标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 async 属性和 defer 属性来异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（尽量使用异步加载）。三者的区别如下
                        ● script 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；
                        ● async 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；
                        ● defer 是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。
            针对CSS
                使用CSS有三种方式：使用link、@import、内联样式，其中link和@import都是导入外部样式。它们之间的区别：
                    ● link：浏览器会派发一个新的线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码
                    ● @import：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)
                    ● style：GUI直接渲染
                    所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。
                外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式
            针对DOM树、CSSOM树
                ● HTML文件的代码层级尽量不要太深
                ● 使用语义化的标签，来避免不标准语义化的特殊处理
                ● 减少CSS代码的层级，因为选择器是从右向左进行解析的
            减少回流与重绘
                CSS
                    避免设置多层内联样式。
                    如果需要设置动画效果，最好使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素。
                    避免使用CSS表达式（例如：calc()）。
                JS
                    避免频繁操作样式，最好将样式列表定义为class并一次性更改class属性。
                    避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。
                    可以先为元素设置为不可见：display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
                浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列
                    浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批量处理。这样就会让多次的回流、重绘变成一次回流重绘。
    渲染过程中遇到 JS 文件如何处理？
            JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。
        什么是文档的预解析？
            Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。
        CSS 如何阻塞文档解析？
            理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们。然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。
        如何优化关键渲染路径？
            （1）对关键路径进行分析和特性描述：资源数、字节数、长度。
            （2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。
            （3）优化关键字节数以缩短下载时间（往返次数）。
            （4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度
        什么情况会阻塞渲染？
            首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。

    浏览器本地存储
        浏览器本地存储方式及使用场景
            Cookie
                概念
                    Cookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。Cookie的大小只有4kb，它是一种纯文本文件，每次发起HTTP请求都会携带Cookie。
                特性
                    ● Cookie一旦创建成功，名称就无法修改
                    ● Cookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样就能够阻止非法获取其他网站的Cookie
                    ● 每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb
                    ● 有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的
                    ● Cookie在请求一个新的页面的时候都会被发送过去
                使用场景
                    ● 最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。（cookie与session都可用于身份认证）
                        cookie用于身份认证
                            客户端第一次请求服务器的时候，服务器通过响应头的形式，向客户端发送一个身份认证的 Cookie，客户端会自动 将 Cookie 保存在浏览器中。 
    随后，当客户端浏览器每次请求服务器的时候，浏览器会自动将身份认证相关的 Cookie，通过请求头的形式发送给 服务器，服务器即可验明客户端的身份。
                        session用于身份认证
                            
                    ● 可以用来统计页面的点击次数
            LocalStorage
                概念
                    LocalStorage是HTML5新引入的特性，由于有的时候我们存储的信息较大，Cookie就不能满足我们的需求，这时候LocalStorage就派上用场了。永久存储，不会随着刷新页面或者关闭页面而消失
                优点
                    ● 在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息
                    ● LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在
                    ● 仅储存在本地，不像Cookie那样每次HTTP请求都会被携带
                缺点
                    ● 存在浏览器兼容问题，IE8以下版本的浏览器不支持
                    ● 如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage
                    ● LocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问
                常用API
                    
                使用场景
                    ● 有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可
                    ● 在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中
            SessionStorage
                概念
                    SessionStorage和LocalStorage都是在HTML5才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。
                SessionStorage与LocalStorage对比
                    ● SessionStorage和LocalStorage都在本地进行数据存储；
                    ● SessionStorage也有同源策略的限制，但是SessionStorage有一条更加严格的限制，SessionStorage只有在同一浏览器的同一窗口下才能够共享；
                    ● LocalStorage和SessionStorage都不能被爬虫爬取
                常用API
                    
                应用场景
                    由于SessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。
        Cookie有哪些字段，作用分别是什么
            ● Name：cookie的名称
            ● Value：cookie的值，对于认证cookie，value值包括web服务器所提供的访问令牌；
            ● Size： cookie的大小
            ● Path：可以访问此cookie的页面路径。 比如domain是abc.com，path是/test，那么只有/test路径下的页面可以读取此cookie。
            ● Secure： 指定是否使用HTTPS安全协议发送Cookie。使用HTTPS安全协议，可以保护Cookie在浏览器和Web服务器间的传输过程中不被窃取和篡改。该方法也可用于Web站点的身份鉴别，即在HTTPS的连接建立阶段，浏览器会检查Web网站的SSL证书的有效性。但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到SSL证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。
            ● Domain：可以访问该cookie的域名，Cookie 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 Cookie。当需要实现单点登录方案时，Cookie 的上述特性非常有用，然而也增加了 Cookie受攻击的危险，比如攻击者可以借此发动会话定置攻击。因而，浏览器禁止在 Domain 属性中设置.org、.com 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围。
            ● HTTP： 该字段包含HTTPOnly 属性 ，该属性用来设置cookie能否通过脚本来访问，默认为空，即可以通过脚本访问。在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。该属性用于防止客户端脚本通过document.cookie属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。但是，HTTPOnly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对Cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过XMLHTTP对象读取HTTP响应中的Set-Cookie头。
            ● Expires/Max-size ： 此cookie的超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。
            总结
                服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。
        Cookie、LocalStorage、SessionStorage区别
            浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。
                cookie：其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。
                sessionStorage：html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。
                localStorage：html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享
                注
                    上面三种方式都是存储少量数据的时候的存储方式，当需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。
            Web Storage 和 cookie 的区别
                ● Web Storage是为了更大容量存储设计的。Cookie 的大小是受限的，并且每次你请求一个新的页面的时候 Cookie 都会被发送过去，这样无形中浪费了带宽；
                ● cookie 需要指定作用域，不可以跨域调用；
                ● Web Storage 拥有 setItem,getItem,removeItem,clear 等方法，不像 cookie 需要前端开发者自己封装 setCookie，getCookie；
                ● Cookie 也是不可以或缺的：Cookie 的作用是与服务器进行交互，作为 HTTP 规范的一部分而存在 ，而 Web Storage 仅仅是为了在本地“存储”数据而生。
        前端储存的⽅式有哪些？
            ● cookies： 在HTML5标准前本地储存的主要⽅式，优点是兼容性好，请求头⾃带cookie⽅便，缺点是⼤⼩只有4k，⾃动请求头加⼊cookie浪费流量，每个domain限制20个cookie，使⽤起来麻烦，需要⾃⾏封装；
            ● localStorage：HTML5加⼊的以键值对(Key-Value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为5M，兼容IE8+ ；
            ● sessionStorage：与localStorage基本类似，区别是sessionStorage当⻚⾯关闭后会被清理，⽽且与cookie、localStorage不同，他不能在所有同源窗⼝中共享，是会话级别的储存⽅式； 
            ● IndexedDB： 是被正式纳⼊HTML5标准的数据库储存⽅案，存储大量数据时使用，它是NoSQL数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合web场景，同时⽤JavaScript进⾏操作会⾮常便。 
        IndexedDB有哪些特点？
            ● 键值对储存：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以"键值对"的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。
            ● 异步：IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。
            ● 支持事务：IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。
            ● 同源限制：IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。
            ● 储存空间大：IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。
            ● 支持二进制储存：IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。

    浏览器同源策略
        什么是同源策略
            跨域问题其实就是浏览器的同源策略造成的。同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。同源指的是：协议、端口号、域名必须一致。同源策略：protocol（协议）、domain（域名）、port（端口）三者必须一致。同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。同源政策主要限制了三个方面
                ● 当前域下的 js 脚本不能够访问其他域下的 cookie、LocalStorage、SessionStorage 和 indexDB。
                ● 当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。
                ● 当前域下 ajax 无法发送跨域请求。
        如何解决跨越问题
            CORS
                跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain)上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域HTTP 请求。CORS需要浏览器和服务器同时支持，整个CORS过程都是浏览器完成的，无需用户参与。因此实现CORS的关键就是服务器，只要服务器实现了CORS请求，就可以跨源通信了。
            JSONP
                jsonp的原理就是利用<script>标签没有跨域限制，通过<script>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。
                缺点
                    ● 具有局限性， 仅支持get方法
                    ● 不安全，可能会遭受XSS攻击
            postMessage 跨域
                解决问题
                    ● 页面和其打开的新窗口的数据传递
                    ● 多窗口之间消息传递
                    ● 页面与嵌套的iframe消息传递
                    ● 上面三个场景的跨域数据传递
                用法
                    postMessage(data,origin)方法接受两个参数
                        ● data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。
                        ● origin： 协议+主机+端口号，也可以设置为"*"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。
            nginx代理跨域
                nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。
                    跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。
            nodejs 中间件代理跨域
                node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。
            document.domain + iframe跨域
                此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。
            location.hash + iframe跨域
                实现原理：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。
            window.name + iframe跨域
            WebSocket协议跨域
                WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。
        正向代理和反向代理的区别
            正向代理和反向代理的结构是一样的，都是 client-proxy-server 的结构，它们主要的区别就在于中间这个 proxy 是哪一方设置的。在正向代理中，proxy 是 client 设置的，用来隐藏 client；而在反向代理中，proxy 是 server 设置的，用来隐藏 server。
                正向代理
                    客户端想获得一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置。
                        
                反向代理
                    服务器为了能够将工作负载分不到多个服务器来提高网站性能 (负载均衡)等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。
                        
        Nginx的概念及其工作原理
            Nginx 是一款轻量级的 Web 服务器，也可以用于反向代理、负载平衡和 HTTP 缓存等。Nginx 使用异步事件驱动的方法来处理请求，是一款面向性能设计的 HTTP 服务器。传统的 Web 服务器如 Apache 是 process-based 模型的，而 Nginx 是基于event-driven模型的。正是这个主要的区别带给了 Nginx 在性能上的优势。Nginx 架构的最顶层是一个 master process，这个 master process 用于产生其他的 worker process，这一点和Apache 非常像，但是 Nginx 的 worker process 可以同时处理大量的HTTP请求，而每个 Apache process 只能处理一个。

    浏览器事件机制
        事件是什么？事件模型？
            事件是什么？
                事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整（事件是用户操作网页时发生的交互动作或者网页本身的一些操作）。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。
            事件模型
                DOM0 级事件模型
                    这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。所有浏览器都兼容这种方式。直接在dom对象上注册事件名称，就是DOM0写法。
                IE 事件模型
                    在该事件模型中，一次事件共有两个过程，事件处理阶段和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。
                DOM2 级事件模型
                    在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。
        如何阻止事件冒泡
            ● 普通浏览器使用：event.stopPropagation() 
            ● IE浏览器使用：event.cancelBubble = true;
        对事件委托的理解
            事件委托概念
                事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托（事件代理）。使用事件委托可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理还可以实现事件的动态绑定，比如说新增了一个子节点，并不需要单独地为它添加一个监听事件，它绑定的事件会交给父元素中的监听函数来处理。（e.target)
            事件委托优点
                减少内存消耗
                    如果有一个列表，列表之中有大量的列表项，需要在点击列表项的时候响应一个事件，如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能。因此，比较好的方法就是把这个点击事件绑定到他的父层，然后在执行事件时再去匹配判断目标元素，所以事件委托可以减少大量的内存消耗，节约效率。
                动态绑定事件
                    给每个列表项都绑定事件，在很多时候，需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的，所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。
            事件委托缺点
                focus、blur 之类的事件没有事件冒泡机制，所以无法实现事件委托
                mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的
        同步和异步的区别
            同步指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。
            异步指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。
        对事件循环（Event Loop）的理解
            因为 js 是单线程运行的，在代码执行时，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码时，如果遇到异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到一个任务队列中等待执行。任务队列可以分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务队列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行完成后再去执行宏任务队列中的任务。
            顺序
                ● 首先执行同步代码，这属于宏任务
                ● 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行
                ● 执行任务队列中所有微任务
                ● 当执行完所有微任务后，如有必要会渲染页面
                ● 执行任务队列中所有宏任务
        宏任务和微任务分别有哪些
            宏任务
                script 脚本的执行（同步任务）
                异步 Ajax 请求
                定时器
                    setTimeout
                    setInterval 
                    setImmediate
                DOM事件
            微任务
                promise 的回调
                node 中的 process.nextTick
                对 Dom 变化监听的 MutationObserver
        什么是执行栈
            可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。当开始执行 JS 代码时，根据先进后出的原则，后执行的函数会先弹出栈
        Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？
            Node 中的 Event Loop
                Node 的 Event Loop 分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。
                    
                        （1）Timers（计时器阶段）：初次进入事件循环，会从计时器阶段开始。此阶段会判断是否存在过期的计时器回调（包含 setTimeout 和 setInterval），如果存在则会执行所有过期的计时器回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Pending callbacks 阶段。
                        （2）Pending callbacks：执行推迟到下一个循环迭代的I / O回调（系统调用相关的回调）。
                        （3）Idle/Prepare：仅供内部使用。
                        （4）Poll（轮询阶段）：
                        ● 当回调队列不为空时：会执行回调，若回调中触发了相应的微任务，这里的微任务执行时机和其他地方有所不同，不会等到所有回调执行完毕后才执行，而是针对每一个回调执行完毕后，就执行相应微任务。执行完所有的回调后，变为下面的情况。
                        ● 当回调队列为空时（没有回调或所有回调执行完毕）：但如果存在有计时器（setTimeout、setInterval和setImmediate）没有执行，会结束轮询阶段，进入 Check 阶段。否则会阻塞并等待任何正在执行的I/O操作完成，并马上执行相应的回调，直到所有回调执行完毕。
                        （5）Check（查询阶段）：会检查是否存在 setImmediate 相关的回调，如果存在则执行所有回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Close callbacks 阶段。
                        （6）Close callbacks：执行一些关闭回调，比如socket.on('close', ...)等。
            Node 中的 process.nextTick
                这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。
        事件触发（事件流）的过程是怎样的 
            事件触发三个阶段
                ● window 往事件触发处传播，遇到注册的捕获事件会触发（捕获阶段）
                ● 传播到事件触发处时触发注册的事件（当前目标阶段）
                ● 从事件触发处往 window 传播，遇到注册的冒泡事件会触发（冒泡阶段）

    垃圾回收机制
        V8的垃圾回收机制是怎样的
            V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。
                新生代算法
                    新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。
                老生代算法
                    老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。
                        标记清除算法
                            在老生代中，以下情况会先启动标记清除算法
                                ● 某一个空间没有分块的时候
                                ● 空间中被对象超过一定限制
                                ● 空间不能保证新生代中的对象移动到老生代中
                            在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行。
                        标记压缩算法
                            清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象向一端移动，直到所有对象都移动完成然后清理掉不需要的内存。
                    什么情况下对象会出现在老生代空间中
                        新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中
                        To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中
        哪些操作会造成内存泄漏？
            意外的全局变量
                由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收
            被遗忘的计时器或回调函数
                设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收
            脱离 DOM 的引用
                获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收
            闭包
                不合理的使用闭包，从而导致某些变量一直被留在内存当中


    小程序
    对微信小程序的理解？优缺点？
            概念
                小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用
                    
            优点
                随搜随用，用完即走：使得小程序可以代替许多APP，或是做APP的整体嫁接，或是作为阉割版功能的承载体
                流量大，易接受：小程序借助自身平台更加容易引入更多的流量
                安全
                开发门槛低
                降低兼容性限制
            缺点
                用户留存：及相关数据显示，小程序的平均次日留存在13%左右，但是双周留存骤降到仅有1%
                体积限制：微信小程序只有2M的大小，这样导致无法开发大型一些的小程序
                受控微信：比起APP，尤其是安卓版的高自由度，小程序要面对很多来自微信的限制，从功能接口，甚至到类别内容，都要接受微信的管控
        微信小程序的生命周期函数有哪些？
            小程序的生命周期函数分类
                应用的生命周期函数
                    小程序的生命周期函数是在app.js里面调用的，通过App(Object)函数用来注册一个小程序，指定其小程序的生命周期回调
                页面的生命周期函数
                    页面生命周期函数就是当你每进入/切换到一个新的页面的时候，就会调用的生命周期函数，通过page(Object)函数用来注册一个页面
                组件的生命周期函数
                    组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发，通过Component(Object)进行注册组件
                        组件实例刚刚被创建好时， created 生命周期被触发，此时，组件数据 this.data 就是在 Component 构造器中定义的数据 data ， 此时不能调用 setData
                        在组件完全初始化完毕、进入页面节点树后， attached 生命周期被触发。此时， this.data 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行
                        在组件离开页面节点树后， detached 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 detached 会被触发
                    组件中特殊的生命周期函数
                        还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理，这样的生命周期称为“组件所在页面的生命周期”，在 pageLifetimes 定义段中定义
                            
        微信小程序中路由跳转的方式有哪些？
            路由跳转方式
                声明式导航
                    导航到tabBar页面
                        
                    导航到非tabBar页面
                        
                    后退导航
                        
                编程式导航
                    导航到tabBar页面
                        基本使用：wx.switchTab({url:'/pages/message/message'})
                        示例
                    导航到非tabBar页面
                        基本使用：wx.navigateTo({url:'/pages/message/message'})
                        示例
                    后退导航
                        基本使用：wx.navigateBack({delta:1})
                        示例
        微信小程序的实现原理？
            在小程序中，渲染层和逻辑层是分开的，双线程同时运行，渲染层和逻辑层这两个通信主体之间的通讯以及通讯主体与第三方服务器之间的通信，都是通过微信客户端进行转发。小程序启动运行两种情况：冷启动（重新开始）：用户首次打开或者小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即为冷启动
    热启动：用户已经打开过小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需要将后台态的小程序切换到前台，这个过程就是热启动
        微信小程序的登录流程？
            背景
                传统web开发实现登录功能
                    传统的web开发实现登陆功能，一般的做法是输入账号密码、或者输入手机号及短信验证码进行登录；服务端校验用户信息通过之后，下发一个代表登录态的 token 给客户端，以便进行后续的交互,每当token过期，用户都需要重新登录；
                小程序实现登录功能
                    而在微信小程序中，可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系，从而实现登陆功能；实现小程序用户体系主要涉及到openid和code的概念：用wx.login()方法会生成code，将code作为参数传递给微信服务器指定接口，就可以获取用户的openid。对于每个小程序，微信都会将用户的微信ID映射出一个小程序 openid，作为这个用户在这个小程序的唯一标识
            流程
                
                    通过 wx.login() 获取到用户的code判断用户是否授权读取用户信息，调用wx.getUserInfo 读取用户数据
                    由于小程序后台授权域名无法授权微信的域名，所以需要自身后端调用微信服务器获取用户信息
                    通过 wx.request() 方法请求业务方服务器，后端把 appid , appsecret 和 code 一起发送到微信服务器。 appid 和 appsecret 都是微信提供的，可以在管理员后台找到
                    微信服务器返回了 openid 及本次登录的会话密钥 session_key
                    后端从数据库中查找 openid ，如果没有查到记录，说明该用户没有注册，如果有记录，则继续往下走
                    session_key 是对用户数据进行加密签名的密钥。为了自身应用安全，session_key 不应该在网络上传输
                    然后生成 session并返回给小程序
                    小程序把 session 存到 storage 里面
                    下次请求时，先从 storage 里面读取，然后带给服务端
                    服务端对比 session 对应的记录，然后校验有效期
        微信小程序的发布流程？
            背景
                小程序的平台里，开发者完成开发之后，需要在开发者工具提交小程序的代码包，然后在小程序后台发布小程序
            流程
                上传代码
                    代码管理服务器上新建分支
                    开发测试新需求
                    测试完成后，将本地分支合并到 master 分支
                    拉取 master 分支最新代码，执行 build 命令生成小程序可执行文件
                    开发者工具点击“上传”
                提交审核
                发布版本
        微信小程序的支付流程？
            背景
                用户通过分享或扫描二维码进入商户小程序，用户选择购买，完成选购流程
                调起微信支付控件，用户开始输入支付密码
                密码验证通过，支付成功。商户后台得到支付成功的通知
                返回商户小程序，显示购买成功
                微信支付公众号下发支付凭证
            流程
                打开某小程序，点击直接下单
                wx.login获取用户临时登录凭证code，发送到后端服务器换取openId
                在下单时，小程序需要将购买的商品Id，商品数量，以及用户的openId传送到服务器
                服务器在接收到商品Id、商品数量、openId后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息
                小程序端在获取对应的参数后，调用wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付
                接下来的一些列操作都是由用户来操作的包括了微信支付密码，指纹等验证，确认支付之后执行鉴权调起支付
                鉴权调起支付：在微信后台进行鉴权，微信后台直接返回给前端支付的结果，前端收到返回数据后对支付结果进行展示
                推送支付结果：微信后台在给前端返回支付的结果后，也会向后台也返回一个支付结果，后台通过这个支付结果来更新订单的状态
        提高微信小程序的应用速度的手段有哪些？
            小程序启动加载性能
                控制代码包的大小
                分包加载
                首屏体验（预请求，利用缓存，避免白屏，及时反馈）
            小程序渲染性能
                避免不当的使用setData
                使用自定义组件
                    自定义组件的更新并不会影响页面上其他元素的更新

    知识点
        小程序与普通网页开发区别
            
        小程序项目结构
            项目的基本组成结构
                
                    pages--存放小程序的多个页面文件
                        每个小程序页面组成部分
                            
                                .json配置文件
                                    页面配置文件.json作用
                                        在小程序中每个页面都有自己的.json配置文件，用来对当前页面的窗口外观、页面效果等进行配置
                                    页面配置常用的配置项
                                        
                                            enablePullDownRefresh--下拉刷新
                                                开启下拉刷新
                                                    将enablePullDownRefresh 的值设为true，仅对当前页面有效
                                                修改下拉时的背景色
                                                    当前页面.json配置文件中的backgroundColor设置为#efefef
                                                设置下拉刷新loading效果
                                                    当前页面的.json配置文件中将backgroundTextStyle指定为light或者dark，，默认为light
                                                监听页面下拉刷新
                                                    
                                                    例子：点击按钮，让data中count的数据自增加1，下拉刷新，让data中的count重置为0
                                                        点击按钮，data中的count自增加1
                                                        下拉刷新，data中的count重置为0
                                                        使用wx.stopPullDownRefresh（）停止当前页面的下拉刷新
                                            onReachBottomDistance--上拉触底
                                                配置距离
                                                    注：若要修改，在当前页面的.json配置文件中onReachBottomDistance中直接在后面加数字即可，不需要加单位，默认为50px
                                                监听页面上拉触底
                                                    
                                    注意
                                        单独配置页面的json配置项会覆盖掉app.json中的相同配置项
                                .wxml--类似于html
                                    wxml概念
                                        wxml是小程序框架设计的一套标签语言，用于构建小程序页面的结构
                                    wxml与html区别
                                        
                                    wxml模板语法
                                        数据绑定
                                            数据绑定的基本原则
                                                在data中定义数据
                                                    
                                                在wxml中使用数据
                                                    使用Mustache语法使用数据
                                                        Mustache语法格式
                                                            
                                                        Mustache使用场景
                                                            绑定内容
                                                                
                                                            绑定属性
                                                                
                                                            运算
                                                                三元运算
                                                                    
                                                                算术运算
                                                                    
                                        事件绑定
                                            什么是事件？
                                                事件是渲染层到逻辑层的通讯方式。通过事件可以将用户在渲染层的行为，反馈到逻辑层进行业务的处理
                                                    
                                            事件绑定的基本原则
                                                在wxml中绑定事件（bindtap=“...”/bindinput=“..."/bindchange=”...“）
                                                在对应的.js文件中定义事件（与data平级，直接写方法/事件名称即可，不用包裹在methods中）
                                            小程序中常用的事件
                                                
                                                    bindtap
                                                        语法格式
                                                            
                                                        修改data中的数值
                                                            通过调用this.setDate({...})方法给data中的数据赋值。                                                                                           注意：setData（）是一个方法，里面传一个对象，对象里面的属性名称不用加this，直接指向data中的数据，属性值需要加this，而且也要加data（和vue不同），也就是说属性名称会覆盖掉原来data中的属性名称，而属性值是取的旧的的属性值的运算
                                                    bindinput
                                                        语法格式
                                                            
                                                        实现input框与data数据同步
                                                            定义数据
                                                                
                                                            渲染结构
                                                                
                                                            绑定input事件
                                                                
                                                    bindchange
                                            事件对象的属性
                                                当事件回调触发的时候，会收到一个对象事件event（在事件绑定时无需声明传递，及（）内不用传递event），他的详细属性如图
                                                    target与currentTarget区别
                                            事件参数
                                                事件传参
                                                    小程序中的事件传参比较特殊，不能在绑定事件的同时为事件处理函数传递参数，可以为组件提供一个data-*自定义属性传递参数，其中*代表的是参数的名字
                                                        
                                                接收参数
                                                    通过e.target.dataset.参数名即可获得具体的参数值
                                                        
                                        条件渲染
                                            wx:if系列
                                                
                                                    wx-：if="{{condition}}"
                                                    wx:elif="{{condition}}"
                                                    wx:else
                                                结合<block></block>使用wx：if
                                                    
                                            hidden="{{condition}}"
                                                
                                            wx:if与hidden对比
                                                运行方式不同
                                                    
                                                使用建议
                                                    
                                        列表渲染
                                            wx:for
                                                语法结构
                                                wx：key
                                                    注：这个wx:key后面一定不要跟{{}}，直接写id或者index即可，不要写成item.id
                                .wxss--类似于css
                                    wxss概念
                                        是一套样式语言，用于描述wxml的组件样式
                                    wxss与css区别
                                        4.@import样式导入
                                            rpx
                                                什么是rpx
                                                    rpx是微信小程序独有的，用来解决屏幕适配的尺寸单位
                                                rpx实现原理
                                                    
                                                rpx与px单位换算
                                                    
                                            @import样式导入
                                                使用wxss提供的@import语法，可以导入外联的样式表
                                                    注：要在对应的wxss中引入样式，在对应的wxml中标签内书写类名
                                    注意：app.wxss样式作用于全部页面，而页面中的.wxss只作用于当前页面，当两个wxss中的样式发生冲突时，采取的原则为：当页面局部样式的权重大于或者等于全局样式的权重时，才会覆盖全局样式
                                .js--类似于js
                        新建小程序页面方式
                            只需要在app.json中的pages中新增页面路径，小程序开发者工具就会在pages中自动创建对应的页面文件
                        调换小程序首页
                            小程序会把app.json中pages数组中的第一个当作小程序的首页，所以只需要调整pages数组中页面顺序即可调换首页
                    utils--存放工具性质模块
                    app.json--全局配置文件
                        包括pages、window、tabBar、style等
                            window
                                小程序窗口的组成部分
                                    都属于window的配置范围
                                window节点常用的配置项
                                    
                                        enablePullDownRefresh--下拉刷新
                                            开启下拉刷新
                                                
                                            修改下拉时的背景色
                                                
                                            设置下拉刷新loading效果
                                                
                                            监听页面下拉刷新
                                                
                                                例子：点击按钮，让data中count的数据自增加1，下拉刷新，让data中的count重置为0
                                                    点击按钮，data中的count自增加1
                                                    下拉刷新，data中的count重置为0
                                                    使用wx.stopPullDownRefresh（）停止当前页面的下拉刷新
                                        onReachBottomDistance--上拉触底
                                            配置距离
                                                注：若要修改，直接在后面加数字即可，不需要加单位
                                            监听页面上拉触底
                                                
                            tabBar
                                什么是tabBar
                                    
                                tanBar组成部分
                                    
                                如何配置
                                    app.json中与window平级配置
                                        tabBar节点配置项
                                            
                                        list中每个tab项的配置项
                                            
                    app.js--小程序项目入口文件
                    app.wxss--小程序项目的全局样式文件
                    project.consig.json--项目配置文件
                        个性化配置
                    sitemap.json--用来配置小程序及其页面是否允许被微信搜索
        小程序宿主环境及宿主环境包含的内容
            宿主环境
                宿主环境指的是程序运行所必须的依赖环境。手机微信是小程序的宿主环境
            小程序宿主环境包含的内容
                通信模型
                    
                        通信主体之间的通信
                            通信主体
                                小程序的通信主体分为渲染层和逻辑层。wxml与wxss工作在渲染层；js脚本工作在逻辑层
                            由微信客户端进行转发
                        通信主体中的逻辑层与第三方服务器之间的通信
                            由微信客户端进行转发
                            网络数据请求
                                小程序中网络数据请求的限制
                                    
                                        配置request合法域名
                                            
                                        查看request合法域名
                                            
                                发起网络数据请求                   
                                    get请求
                                        
                                    post请求
                                        
                                跳过request合法域名检验
                                    
                                关于跨域和AJAX的说明
                                    
                运行机制
                    小程序启动过程
                        
                    页面渲染过程
                        
                组件
                    视图组件
                        常用的视图组件
                            view（类似于div）
                                view基本使用：实现flex横向布局效果
                            scroll-view（可滚动的试图区域）
                                scroll-view基本使用：实现纵向滚动效果
                            swiper和swiper-item（轮播图容器组件与轮播图item组件）
                                轮播图基本使用：实现轮播图效果
                                swiper组件的常用属性
                                    
                    基础内容组件
                        常用的基础内容组件
                            text（文本组件，类似于span，行内元素）
                                text组件基本使用：通过text组件的user-select，实现长按选中文本内容效果
                            rich-text（富文本组件，支持把html字符串渲染成wxml结构）
                                rich-text的基本使用：利用rich-text的nodes属性，把html中字符串渲染为对应的ui结构
                    表单组件
                        button（按钮组件）
                            button组件的基本使用
                    导航组件
                        navigator（页面导航组件，类似于a）
                            实现页面导航两种方式
                                声明式导航
                                    导航到tabBar页面
                                        
                                    导航到非tabBar页面
                                        
                                    后退导航
                                        
                                编程式导航
                                    导航到tabBar页面
                                        基本使用：wx.switchTab({url:'/pages/message/message'})
                                        示例
                                    导航到非tabBar页面
                                        基本使用：wx.navigateTo({url:'/pages/message/message'})
                                        示例
                                    后退导航
                                        基本使用：wx.navigateBack({delta:1})
                                        示例
                            导航参数
                                导航传参
                                    声明式导航传参
                                        
                                    编程式导航传参
                                        
                                页面接收参数
                                    
                    媒体组件
                        image（图片组件，默认300px*240px）
                            image的基本使用
                            image的mode属性用来指定图片的裁剪和缩放模式
                    map地图组件
                    canvas画布组件
                    开放能力
                    无障碍访问
                API
                    API分类
                        事件监听API
                            
                        同步API
                            
                        异步API
                            
        生命周期
            生命周期分类
                应用生命周期
                    概念
                        
                    常见的应用生命周期函数
                        
                页面生命周期
                    概念
                        
                    常见的页面生命周期函数
                        
                组件的生命周期
                    
                    组件所在页面的生命周期
        wxs脚本（相当于过滤器，配合Mustache语法一起使用）
            什么是wxs
                
            wxs应用场景
                
            wxs和js关系
                
            wxs基础语法
                内联wxs脚本
                    
                外联wxs脚本
                    定义外联wxs脚本
                        
                    使用外联wxs脚本
                        
            wxs特点
                
        自定义组件
            自定义组件与页面区别
                
            创建组件
                
            引用组件
                全局引用
                    组件可以在小程序中的任意页面使用
                        app.json中配置
                局部引用
                    组件只能在当前被引用的页面内使用
                        在页面的.json中配置
            自定义组件样式隔离
                自定义组件样式隔离概述
                    
                组件样式隔离注意点
                    
                修改自定义组件的样式隔离
                    在自定义组件的.js中的options中配置
                    样式隔离styleisolation可选值
                        
            自定义组件.js文件配置项
                options属性
                    pureDataPattern：/^_/-纯数据字段
                        什么是纯数据字段
                            
                        使用规则
                            
                    styleisolation：isolated--样式隔离
                    multipleSlots：true--开启多个插槽
                data属性
                    储存自定义组件私有数据
                        
                methods属性
                    储存事件处理函数和自定义方法
                        
                properties属性
                    储存外界传递到自定义组件中的数据，与data中的数据无本质区别，都是可读可写的
                        定义properties
                            
                        修改properties
                            
                observers属性
                    用于监听和响应任何属性和数据字段的变化，从而执行特定的操作
                        基本语法格式
                            
                        监听对象属性
                            
                            当监听对象中多个属性时，可以用**来表示
                                
                        监听属性例子
                            
                lifetimes属性
                    定义组件的生命周期函数
                        
                pageLifetimes属性
                    定义组件在页面的生命周期函数
                        组件所在页面的生命周期
                            
                        定义位置--pageLifetimes属性中
                            
                        例子：当自定义组件所在页面每次被展示时，生成一个随机的颜色给组件
                            
                            
            自定义组件生命周期
                自定义组件全部生命周期函数
                    
                自定义组件主要的生命周期函数
                    
                组件所在页面的生命周期
                    
            自定义组件插槽
                什么是插槽
                    
                插槽个数分类
                    单个插槽
                        
                    多个插槽
                        开启多个插槽模式
                            
                        定义多个插槽
                            
                        使用多个插槽
                            
            通信
                属性绑定
                    传递数据
                        
                    接收数据
                        
                事件绑定
                    
                        
                        
                        
                        
                获取组件实例
                    
            自定义组件的behaviors
                什么是behaviors
                    
                behaviors工作方式
                    
                创建behaviors
                    
                导入并使用behaviors
                    
                Behavior中所有可用的节点
                    
        开发优化
            使用vant weapp
                什么是vant weapp
                    
                使用vant weapp
                    安装vant组件库
                        
                        
                    使用vant组件库
                        
                使用css变量定制vant主题样式
                    
            API的promise化
                原生API数据请求
                    
                什么是API的promise化
                    
                实现API的promise化
                    注：安装完每个包之后要重新构建，在对应文件夹下强制删除miniprogram_npm（shift+delete），然后在工具中重新构建npm
                调用promise化之后的异步API
                    
            全局数据共享
                什么是全局数据共享
                    
                小程序中的全局共享方案
                    
                小程序全局数据共享MobX步骤
                    安装MobX相关的包
                        
                    创建mobx实例store
                        
                    将store中的成员绑定到需要的地方
                        将store中的成员绑定到页面中并使用
                            绑定到页面中，在页面对应的.js中书写
                            在页面对应的.wxml中书写
                        将store中的成员绑定到组件中并使用
                            绑定到组件中，在组件对应的.js中书写
                            在组件对应的.wxml中书写
            分包
                分包概念
                    
                分包好处
                    
                普通分包
                    分包前后项目构成
                        分包前项目构成
                            
                        分包后项目构成
                            
                    分包加载规则
                        
                    分包体积限制
                        
                    使用普通分包
                        配置方法
                            
                        打包原则
                            
                        引用原则
                            
                独立分包
                    独立分包概念
                        
                    独立分包与普通分包区别
                        
                    独立分包应用场景
                        
                    使用独立分包
                        配置方法
                            
                        引用原则
                            
                分包预下载
                    分包预下载概念
                        
                    配置分包预下载
                        
                    分包预下载的限制
                        
    Nodejs
    对Node.js 的理解？优缺点？应用场景？
        概念
            是一个基于Chrome V8引擎的JavaScript运行环境，让JavaScript 运行在服务端的开发平台。Node. js是一个事件驱动、非阻塞式I/O的模型，轻量而又高效。浏览器是js的前端运行环境，node.js是js的后端运行环境。
        优缺点
            优点
                处理高并发场景性能更佳
                适合I/O密集型应用，指的是应用在运行极限时，CPU占用率仍然比较低，大部分时间是在做 I/O硬盘内存读写操作
            缺点
                不适合CPU密集型应用（如复杂的数学计算）
                只支持单核CPU，不能充分利用CPU
                可靠性低，一旦代码某个环节崩溃，整个系统都崩溃
        适用场景
            高并发、实时聊天、实时消息推送、客户端逻辑强大的SPA（单页面应用程序）。
        应用场景
            第一大类：用户表单收集系统、后台管理系统、实时交互系统、考试系统、联网软件、高并发量的web应用程序
            第二大类：基于web、canvas等多人联网游戏
            第三大类：基于web的多人实时聊天客户端、聊天室、图文直播
            第四大类：单页面浏览器应用程序
            第五大类：操作数据库、为前端和移动端提供基于json的API

    Node.js与javascript有什么不同
        
    为什么要用Node.js
        （1）简单， Node. js用 JavaScript、JSON进行编码，简单好学。
        （2）功能强大，非阻塞式I/O，在较慢的网络环境中，可以分块传输数据，事件驱动，擅长高并发访问。
        （3）轻量级， Node. js本身既是代码又是服务器，前后端使用同一语言。
        （4）可扩展，可以轻松应对多实例、多服务器架构，同时有海量的第三方应用组件。

    Node. js 有哪些全局对象？
        在浏览器 JavaScript 中，通常window 是全局对象， 而 Nodejs中的全局对象是 global，global全局对象则在全局作用域中，任何全局变量、函数、对象都是该对象的一个属性值
            全局对象分类
                真正的全局对象
                    Buffer
                        可以处理二进制以及非Unicode编码的数据
                    process
                        进程对象，提供有关当前进程的信息和控制
                    console
                        最常用的输入内容的方式：console.log/console. info、console.error/console.warning、console.time/console.timeEnd 、console.trace、console .table。
                    clearInterval、setInterval
                        设置定时器与清除定时器
                    clearTimeout、setTimeout
                        设置延时器与清除延时器
                    global
                        全局命名空间对象，process、console、setTimeout等都有放到global中
                模块级别的全局变量
                    __dirname
                        获取当前文件所在的路径，不包括后面的文件名
                    __filename
                        获取当前文件所在的路径和文件名称，包括后面的文件名称
                    exports
                        module.exports 用于指定一个模块所导出的内容，即可以通过 require() 访问的内容
                            
                    module
                        对当前模块的引用，通过module.exports 用于指定一个模块所导出的内容，即可以通过 require() 访问的内容
                    require
                        用于引入模块、 JSON、或本地文件。 可以从 node_modules 引入模块。

    你知道哪些 Node.js核心模块？
        EventEmitter 、Stream、FS、Net和全局对象等。

    对 Node.js 中的 process 的理解？有哪些常用方法？
        概念
            process 对象是一个全局变量，提供了有关当前 Node.js进程的信息并对其进行控制，作为一个全局变量
        属性与方法
            属性
                process.env：环境变量，例如通过 `process.env.NODE_ENV 获取不同环境项目配置信息
                process.nextTick：这个在谈及 EventLoop 时经常为会提到
                process.pid：获取当前进程id
                process.ppid：当前进程对应的父进程
                process.cwd()：获取当前进程工作目录，
                process.platform：获取当前进程运行的操作系统平台
                process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值
                进程事件： process.on(‘uncaughtException’,cb) 捕获异常信息、 process.on(‘exit’,cb）进程推出监听
                三个标准流： process.stdout 标准输出、 process.stdin 标准输入、 process.stderr 标准错误输出
                process.title 指定进程名称，有的时候需要给进程指定一个名称
            方法
                process.cwd()
                    返回当前 Node进程执行的目录
                process.argv
                    在终端通过 Node 执行命令的时候，通过 process.argv 可以获取传入的命令行参数，返回值是一个数组
                process.env
                    返回一个对象，存储当前环境相关的所有信息，一般很少直接用到。
                process.nextTick()
                    NodeJs是基于事件轮询，在这个过程中，同一时间只会处理一件事情，在这种处理模式下，process.nextTick()就是定义出一个动作，并且让这个动作在下一个事件轮询的时间点上执行

    Node. js中的异步和同步如何理解？
        Node.js是单线程的，异步是通过一次次的循环事件队列来实现的。同步则是阻塞式的IO，这在高并发环境中会是一个很大的性能问题，所以同步一般只在基础框架启动时使用，用来加载配置文件、初始化程序等。

    通过哪些方法可以进行异步流程的控制？
        （1）多层嵌套回调。
        （2）为每一个回调写单独的函数，函数里边再回调。
        （3）用第三方框架，如 async、 promise等。

    如何避免回调地狱？
        使用Promise
        使用aync/await

    Node.js有哪些定时功能？
        setTimeout/clearTimeout
        setInterval/clearInterval
        setImmediate/clearImmediate
        process. nextTick

    什么是错误优先的回调函数？
        错误优先(Error-first)的回调函数（Error-First Callback）用于同时返回错误和数据。第一个参数返回错误，并且验证它是否出错；其他参数返回数据。

    对 Node 中的 fs模块的理解? 有哪些常用方法
        概念
            fs（filesystem），该模块提供本地文件的读写能力，可以说，所有与文件的操作都是通过fs核心模块实现，这个模块对所有文件系统操作提供异步（不具有sync 后缀）和同步（具有 sync 后缀）两种操作方式，而供开发者选择
                
        常用方法
            文件读取
                同步读取：fs.readFileSync
                    第一个参数为读取文件的路径或文件描述符
    第二个参数为 options，默认值为 null，其中有 encoding（编码，默认为 null）和 flag（标识位，默认为 r），也可直接传入 encoding
                异步读取：fs.readFile
                    异步读取方法 readFile 与 readFileSync 的前两个参数相同，最后一个参数为回调函数，函数内有两个参数 err（错误）和 data（数据），该方法没有返回值，回调函数在读取文件成功后执行
            文件写入
                同步写入：fs.writeFileSync
                    第一个参数为写入文件的路径或文件描述符
    第二个参数为写入的数据，类型为 String 或 Buffer
    第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 w）和 mode（权限位，默认为 0o666），也可直接传入 encoding
                异步写入：fs.writeFile
                    异步写入，writeFile 与 writeFileSync 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 err（错误），回调函数在文件写入数据成功后执行
            文件追加写入
                同步追加：fs.appendFileSync
                    第一个参数为写入文件的路径或文件描述符
    第二个参数为写入的数据，类型为 String 或 Buffer
    第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 a）和 mode（权限位，默认为 0o666），也可直接传入 encoding
                异步追加：fs.appendFile
                    异步追加写入方法 appendFile 与 appendFileSync 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 err（错误），回调函数在文件追加写入数据成功后执行
            文件拷贝
                同步拷贝：fs.copyFileSync
                    
                异步拷贝：fs.copyFile
                    
            创建目录
                同步创建：fs.mkdirSync
                    同步创建，参数为一个目录的路径，没有返回值，在创建目录的过程中，必须保证传入的路径前面的文件目录都存在，否则会抛出异常
                异步创建：fs.mkdir
                    异步创建，第二个参数为回调函数

    对 Node 中的 Buffer 的理解？应用场景？
        概念
            在Node应用中，需要处理网络协议、操作数据库、处理图片、接收上传文件等，在网络流和文件的操作中，要处理大量二进制数据，而Buffer就是在内存中开辟一片区域（初次初始化为8KB），用来存放二进制数据；Nodejs不能控制数据传输的速度和到达时间，只能决定何时发送数据，如果还没到发送时间，则将数据放在Buffer中，即在RAM中，直至将它们发送完毕
        应用场景
            I/O操作
            加密解密
            zlib.js

    对中间件概念的理解
        概念
            中间件（Middleware）是介于应用系统和系统软件之间的一类软件，能够达到资源共享、功能共享的目的。中间件的本质为一个回调函数，参数包含请求对象、响应对象和执行下一个中间件的函数
                

    npm是什么，作用是？
        概念
            npm是 Node. js中管理和分发包的工具，可用于安装、卸载、发布、查看包等。
        作用
            通过ηpm，可以安装和管理项目的依赖，还可以指明依赖项的具体版本号。
                （1）允许用户从npm服务器下载别人编写的第三方包到本地。
                （2）允许用户从npm服务器下载并安装别人编写的命令行程序到本地。
                （3）允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。

    什么是 EventEmitter？EventEmitter有哪些典型应用？
        什么是EventEmitter？
            EventEmitter是 Node. js中一个实现观察者模式的类，主要功能是订阅和发布消息，Node.js 中任何对象发出的事件都是 EventEmitter 类的实例，所有 EventEmitter 类都可以使用 eventEmitter.on() 函数将事件侦听器附加到事件。然后一旦捕捉到这样的事件，就会同步地逐个调用它的侦听器。
        EventEmitter有哪些典型应用？
            （1）在模块间传递消息。
            （2）在回调函数内外传递消息。
            （3）处理流数据，因为流是在 EventEmitter的基础上实现的。

    Node. js中的流是什么？使用流有什么好处？流有哪些典型应用？
        概念
            流(Stream)是基于 EventEmitter的数据管理模式，由各种不同的抽象接口组成，主要包括可写、可读、可读写、可转换等类型。
        好处
            流是非阻塞式数据处理模式，可以提升效率，节省内存，有助于处理管道且可扩展等。
        典型应用
            流在文件读写、网络请求、数据转换、音频、视频等方面有很广泛的应用。

    有哪些常用 Stream流？分别什么时候使用？
        Readable流为可读流，在作为输入数据源时使用；Writable流为可写流，在作为输岀源时使用；Duplex流为可读写流，它作为输岀源被写入，同时又作为输入源被后面的流读出。Transform流和 Duplex流一样，都是双向流，区别是 Transfrom流只需要实现一个函数 _transfrom( chunk, encoding, callback)；而 Duplex流需要分别实现_read(size )函数和_write( chunk, encoding, callback ）函数。

    readFile 和 createReadStream 函数有什么区别？
        readFile 函数异步读取文件的全部内容，并存储在内存中，然后再传递给用户。createReadStream 使用一个可读的流，逐块读取文件，而不是全部存储在内存中。与 readFile 相比，createReadStream 使用更少的内存和更快的速度来优化文件读取操作。

    对Nodejs中的事件循环机制理解?
        事件循环其实就是一个事件队列，先加入先执行，执行完一次队列，再次循环遍历看有没有新事件加入队列。执行中的事件叫IO事件，Node 规定，process.nextTick和Promise的回调函数，追加在本轮循环，即同步任务一旦执行完成，就开始执行它们，且process.nextTick是所有异步任务里面最快执行的。而setTimeout、setInterval、setImmediate的回调函数，追加在次轮循环。 由于setTimeout在 timers 阶段执行，而setImmediate在 check 阶段执行。所以，setTimeout会早于setImmediate完成。
        Nodejs事件循环六个阶段
            每个阶段对应一个队列，当事件循环进入某个阶段时, 将会在该阶段内执行回调，直到队列耗尽或者回调的最大数量已执行, 那么将进入下一个处理阶段。除了上述6个阶段，还存在process.nextTick，其不属于事件循环的任何一个阶段，它属于该阶段与下阶段之间的过渡, 即本阶段执行结束, 进入下一个阶段前, 所要执行的回调，类似插队
                timers：这个是定时器阶段，处理setTimeout()和setInterval()的回调函数。进入这个阶段后，主线程会检查一下当前时间，是否满足定时器的条件。如果满足就执行回调函数，否则就离开这个阶段。
                I/O事件回调阶段(I/O callbacks)：执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些I/O回调
                闲置阶段(idle, prepare)：仅系统内部使用
                这个阶段是轮询时间，用于等待还未返回的 I/O 事件，比如服务器的回应、用户移动鼠标等等。这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待 I/O 请求返回结果。
                检查阶段(check)：setImmediate() 回调函数在这里执行
                关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on('close', ...)

    性能优化
    CDN
        CDN的概念
            CDN（Content Delivery Network，内容分发网络）是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。
        CDN的作用
            CDN一般会用来托管Web资源（包括文本、图片和脚本等），可供下载的资源（媒体文件、软件、文档等），应用程序（门户网站等）。使用CDN来加速这些资源的访问。
                在性能方面，引入CDN的作用在于
                    ● 用户收到的内容来自最近的数据中心，延迟更低，内容加载更快
                    ● 部分资源请求分配给了CDN，减少了服务器的负载
                在安全方面，CDN有助于防御DDoS、MITM等网络攻击
                    ● 针对DDoS：通过监控分析异常流量，限制其请求频率
                    ● 针对MITM：从源服务器到 CDN 节点到 ISP（Internet Service Provider），全链路 HTTPS 通信
                除此之外，CDN作为一种基础的云服务，同样具有资源托管、按需扩展（能够应对流量高峰）等方面的优势。
        CDN的原理
            用户未使用CDN缓存资源的过程
                1. 浏览器通过DNS对域名进行解析，依次得到此域名对应的IP地址
                2. 浏览器根据得到的IP地址，向域名的服务主机发送数据请求
                3. 服务器向浏览器返回响应数据
            用户使用CDN缓存资源的过程
                
                    1. 对于点击的数据的URL，经过本地DNS系统的解析，发现该URL对应的是一个CDN专用的DNS服务器，DNS系统就会将域名解析权交给CNAME指向的CDN专用的DNS服务器。
                        CNAME（意为：别名）：在域名解析中，实际上解析出来的指定域名对应的IP地址，或者该域名的一个CNAME，然后再根据这个CNAME来查找对应的IP地址。
                    2. CDN专用DNS服务器将CDN的全局负载均衡设备IP地址返回给用户
                    3. 用户向CDN的全局负载均衡设备发起数据请求
                    4. CDN的全局负载均衡设备根据用户的IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备
                    5. 区域负载均衡设备选择一台合适的缓存服务器来提供服务，将该缓存服务器的IP地址返回给全局负载均衡设备
                    6. 全局负载均衡设备把服务器的IP地址返回给用户，告诉用户向这台设备发起请求
                    7. 用户向该缓存服务器发起请求，缓存服务器响应用户的请求，将用户所需内容发送至用户终端。
                    8.如果缓存服务器没有用户想要的内容，那么缓存服务器就会向它的上一级缓存服务器请求内容，以此类推，直到获取到需要的资源。最后如果还是没有，就会回到自己的服务器去获取资源。
        CDN的使用场景
            使用第三方的CDN服务
                如果想要开源一些项目，可以使用第三方的CDN服务
            使用CDN进行静态资源的缓存
                将自己网站的静态资源放在CDN上，比如js、css、图片等。可以将整个项目放在CDN上，完成一键部署。
            直播传送
                直播本质上是使用流媒体进行传送，CDN也是支持流媒体传送的，所以直播完全可以使用CDN来提高访问速度。CDN在处理流媒体的时候与处理普通静态文件有所不同，普通文件如果在边缘节点没有找到的话，就会去上一层接着寻找，但是流媒体本身数据量就非常大，如果使用回源的方式，必然会带来性能问题，所以流媒体一般采用的都是主动推送的方式来进行。

    懒加载
        懒加载的概念
            懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。如果使用图片的懒加载就可以解决以上问题。在滚动屏幕之前，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，页面列表较长（长列表）的场景中。
        懒加载的特点
            减少无用资源的加载
                使用懒加载明显减少了服务器的压力和流量，同时也减小了浏览器的负担
            提升用户体验
                如果同时加载较多图片，可能需要等待的时间较长，这样影响了用户体验，而使用懒加载就能大大的提高用户体验。
            防止加载过多图片而影响其他资源文件的加载
                会影响网站应用的正常使用
        懒加载的实现原理
            图片的加载是由src引起的，当对src赋值时，浏览器就会请求图片资源。根据这个原理，我们使用HTML5 的data-xxx属性来储存图片的路径，在需要加载图片的时候，将data-xxx中图片的路径赋值给src，这样就实现了图片的按需加载，即懒加载。
            懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。
            使用原生JavaScript实现懒加载
                
                    window.innerHeight 是浏览器可视区的高度
                    document.body.scrollTop || document.documentElement.scrollTop 是浏览器滚动的过的距离
                    imgs.offsetTop 是元素顶部距离文档顶部的高度（包括滚动条的距离）
                    图片加载条件：img.offsetTop < window.innerHeight + document.body.scrollTop;
                代码实现
                    
        懒加载与预加载的区别
            这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。
                懒加载
                    懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。
                预加载
                    预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 src属性，来实现图片的预加载。

    节流与防抖
        对节流与防抖的理解
            防抖
                概念
                    函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。
                应用场景
                    按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次 
                    服务端验证场景：表单验证需要服务端配合，只执⾏⼀段连续的输⼊事件的最后⼀次，还有搜索联想词功能类似⽣存环境请⽤lodash.debounce
            节流
                概念
                    函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。
                应用场景
                    拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动
                    缩放场景：监控浏览器resize 
                    动画场景：避免短时间内多次触发动画引起性能问题 
        实现节流函数和防抖函数
            函数防抖实现
                
            函数节流实现
                

    减少回流与重绘
        回流与重绘的概念及触发条件
            回流/重排
                概念
                    当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为回流。
                触发条件
                    ● 页面的首次渲染
                    ● 浏览器的窗口大小发生变化
                    ● 元素的内容发生变化
                    ● 元素的尺寸或者位置发生变化
                    ● 元素的字体大小发生变化
                    ● 激活CSS伪类
                    ● 查询某些属性或者调用某些方法
                    ● 添加或者删除可见的DOM元素
            重绘
                概念
                    当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是重绘。
                触发条件
                    ● color、background 相关属性：background-color、background-image 等
                    ● outline 相关属性：outline-color、outline-width 、text-decoration
                    ● border-radius、visibility、box-shadow
        如何避免回流与重绘
            CSS
                避免设置多层内联样式。
                如果需要设置动画效果，最好使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素。
                避免使用CSS表达式（例如：calc()）。
            JS
                避免频繁操作样式，最好将样式列表定义为class并一次性更改class属性。
                避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。
                可以先为元素设置为不可见：display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
            浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列
                浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批量处理。这样就会让多次的回流、重绘变成一次回流重绘。
        documentFragment是什么？用它跟直接操作DOM的区别是什么？
            概念
                DocumentFragment，文档片段接口，一个没有父对象的最小文档对象。它被作为一个轻量版的 Document使用，就像标准的document一样，存储由节点（nodes）组成的文档结构。与document相比，最大的区别是DocumentFragment不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。
            与直接操作 DOM 的区别
                由于DocumentFragment不会出现在文档树中，将DocumentFragment插入文档树中，相当于把把他的子孙节点插入到文档树中，在频繁的DOM操作时，我们就可以将DOM元素插入DocumentFragment，之后一次性的将所有的子孙节点插入文档中。和直接操作DOM相比，将DocumentFragment 节点插入DOM树时，仅会触发页面的一次重绘，这样就大大提高了页面的性能。

    图片优化
        如何对项目中的图片进行优化？
            不用图片
                很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。
            对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。
            小图使用 base64 格式
            将多个图标文件整合到一张图片中（雪碧图）
            选择正确的图片格式：
                ○ 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好
                ○ 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替
                ○ 照片使用 JPEG
        常见的图片格式及使用场景？
            BMP
                是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。
            GIF
                是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。
            JPEG
                是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。
            PNG-8
                是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。
            PNG-24
                是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。
            SVG
                SVG是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制Logo、Icon等。
            WebP
                WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。
                    ● 在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；
                    ● 在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；
                    ● WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。

    webpack优化
        如何用webpack优化前端性能？
            通过webpack优化前端的手段
                代码压缩
                    JS代码压缩
                        利⽤webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS⽂件
                    CSS代码压缩
                        利⽤ cssnano （css-loader?minimize）来压缩css
                    Html文件代码压缩
                        使用HtmlWebpackPlugin插件来生成HTML的模板时候，通过配置属性minify进行html优化
                文件大小压缩
                    对文件的大小进行压缩，减少http传输过程中宽带的损耗
                图片压缩
                Tree Shaking
                    将代码中永远不会⾛到的⽚段删除掉（消除死代码）。可以通过在启动webpack时追加参数 --optimize-minimize 来实现；
                代码分离
                    代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存
                提取公共第三⽅库
                    SplitChunksPlugin插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码 
        如何提高webpack构建速度？
            优化webpack构建的方式有很多，主要可以从优化搜索时间、缩小文件搜索范围、减少不必要的编译等方面入手
                优化loader配置
                    在使用loader时，可以通过配置include、exclude、test属性来匹配文件，缩小文件的搜索范围，优化搜索时间
                多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码
                通过 externals 配置来提取常⽤库，脱离webpack打包，不被打⼊bundle中，从⽽减少打包时间
                利⽤ DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的npm包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来，让⼀些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间  
                使⽤ Happypack 实现多线程加速编译 
                使⽤ webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采⽤了多核并⾏压缩来提升压缩速度
                使⽤ Tree-shaking 和 Scope Hoisting 来剔除多余代码 
                利⽤缓存提⾼rebuild效率
        如何减少webpack打包时间？
            优化 Loader
                对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低。
                    优化 Loader 的文件搜索范围
                        对于 Babel 来说，希望只作用在 JS 代码上的，然后 node_modules 中使用的代码都是编译过的，所以完全没有必要再去处理一遍。
                    还可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间
                        
            HappyPack
                受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了
                    
            DllPlugin
                DllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。
                    
                    然后需要执行这个配置文件生成依赖文件，接下来需要使用 DllReferencePlugin 将依赖文件引入项目中
            代码压缩
                在 Webpack3 中，一般使用 UglifyJS 来压缩代码，但是这个是单线程运行的，为了加快效率，可以使用 webpack-parallel-uglify-plugin 来并行运行 UglifyJS，从而提高效率。在 Webpack4 中，不需要以上这些操作了，只需要将 mode 设置为 production 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 console.log 这类代码的功能。
            其他
                resolve.extensions
                    用来表明文件后缀列表，默认查找顺序是 ['.js', '.json']，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面
                resolve.alias
                    可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径
                module.noParse
                    如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助
        如何减少webpack打包体积？
            按需加载
                在开发 SPA 项目的时候，项目中都会存在很多路由页面。如果将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，希望首页能加载的文件体积越小越好，这时候就可以使用按需加载，将每个路由页面单独打包为一个文件。当然不仅仅路由可以按需加载，对于 loadash 这种大型类库同样可以使用这个功能。
            Scope Hoisting
                Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。这样的打包方式生成的代码明显比之前的少多了。如果在 Webpack4 中你希望开启这个功能，只需要启用 optimization.concatenateModules 就可以了
                    
            Tree Shaking
                Tree Shaking 可以实现删除项目中未被引用的代码（死代码）

    Vue知识点
    1.vue核心
        vue简介
            vue概念
                动态构建用户界面的渐进式 JavaScript 框架
            vue特点
                采用组件化模式，提高代码复用率、且让代码更好维护
                声明式编码，让编码人员无需直接操作DOM，提高开发效率
                使用虚拟DOM+优秀的Diff算法，尽量复用DOM节点
            创建vue
                
                    想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象
                    root容器里的代码依然符合html规范，只不过混入一些特殊的Vue语法
                    root容器里的代码被称为【Vue模板】
                    容器和Vue实例对象必须一一对应，即一个容器只能有一个对应的Vue，一个Vue只能找一个容器
                    实际开发中只有一个Vue实例，并且会配合着组件一起使用
                    {{xxx}}中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性
                        js表达式：一个表达式可以生成一个值，放在任何一个需要的地方，比如a、a+b、x===y？“a”：“b”
                        js代码（js语句）：if（）{...}   for(）{...}
                    一旦data中的数据发生改变，那么页面中用到该数据的地方会自动更新
                    注意
                        由vue管理的函数，一定不要写成箭头函数，一旦写成箭头函数，this的指向就会为window，若写成普通函数，this的指向为vue实例对象，比如data、methods等
        MVVM模型
            
                简介
                    MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，实现了数据双向绑定。Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷
                        在MVVM的架构下，View层和Model层并没有直接联系，而是通过ViewModel层进行交互。ViewModel层通过双向数据绑定将View层和Model层连接了起来，使得View层和Model层的同步工作完全是自动的。因此开发者只需关注业务逻辑，无需手动操作DOM，复杂的数据状态维护交给MVVM统一来管理
                Vue.js中mvvm的体现
                    Vue.js的实现方式，对数据（Model）进行劫持，当数据变动时，数据会出发劫持时绑定的方法，对视图进行更新
                        Observer相当于Model层观察vue实例中的data数据，当数据发生变化时，通知Watcher订阅者（通过Object.defineProperty将data中的属性添加到vue实例身上，为每个添加到vue实例身上的属性都配置getter和setter，在内部它们让Vue追踪依赖。在属性被访问和修改时通知变化
                        Compile指令解析器位于View层，初始化View的视图，将数据变化与更新函数绑定，传给Watcher订阅者。
                        Watcher是整个模型的核心，对应ViewModel层，连接Observer和Compile。Watcher将Observer监听到的数据变化对应相应的回调函数，处理数据，反馈给View层更新界面视图
        指令语法
            功能
                解析标签属性、解析标签体内容、绑定事件
            说明
                Vue 中有有很多的指令，且形式都是v-？？？
            指令分类
                内置指令
                    插值语法指令
                        v-text
                            作用
                                更新该整个DOM元素的 textContent（不会解析标签）
                            写法
                                
                            注意
                                {{xxx}} ，xxxx 是js表达式，且可以直接读取到data中所有属性
                        v-html
                            作用
                                更新整个DOM元素的 innerHTML（会解析标签）
                            写法
                                
                            注意
                                v-html有安全性问题！在网站上动态渲染任意HTML是非常危险的，容易受到XSS攻击，一定要在可信的内容上使用v-html，不要用在用户提交的内容上
                    数据绑定指令
                        v-bind：
                            作用
                                数据只能从data流向页面
                            应用
                                用于动态渲染页面中的内容，只渲染，无需收集页面的数据，一般用于不需要用户操作或者输入的页面内容上
                                绑定样式
                                    绑定class样式
                                        ：class="xxx" xxx可以是字符串、对象、数组
                                            
                                                字符串写法，适用于：只选择一个样式（多选一），样式的类名不确定，需要动态指定
                                                数组写法，适用于：要绑定的样式个数不确定、名字也不确定
                                                对象写法，适用于：要绑定的样式个数确定、名字也确定,但是不确定用不用
                                    绑定style样式
                                        ：style="xxx" xxx可以是对象、数组
                                            ：style="{fontSize：xxx}" 其中xxx是动态值
                                                
                                            ：style="[a，b]" 其中a、b是样式对象
                                                
                            写法
                                
                        v-model：
                            作用
                                数据不仅能从data流向页面，还可以从页面流向data
                            应用
                                双向绑定一般都应用于表单元素上（如：input、select等），一般使用于收集表单元素上
                            写法
                                
                            v-model的三个修饰符
                                v-model.lazy：失去焦点再收集数据
                                v-model.number：输入字符串转为有效的数字
                                v-model.trim：输入首尾空格过滤
                    事件处理指令
                        v-on：/@
                            事件的基本使用
                                
                                    使用v-on：xxx或@xxx 绑定事件，其中xxx是事件名称
                                    事件的回调需要配置在methods对象中，最终会在vm上
                                    methods中配置的函数，都是被Vue所管理的函数，this指向是vm或者组件实例对象
                                    @click=“demo”和@click=“demo（$event）效果一致，但是后者可以传参
                            键盘事件
                                
                                    vue中常用的按键别名
                                        @keyup.enter:按回车键
                                        @keyup.delete:删除（捕获”删除“和”退格“）
                                        @keyup.esc:按退出键
                                        @keyup.space:按空格键
                                        @keydown.tab:按换行键
                                        @keyup.up:按上键
                                        @keyup.down:按下键
                                        @keyup.left:按左键
                                        @keyup.right:按右键
                                    注意
                                        Vue未提供别名的按键，可以使用按键原始的key值去绑定，但要注意要转为kebab-case（短横线命名）
                                        系统修饰键（用法特殊）：ctrl、alt、shift、mata（win）
                                            配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发
                                            配合keydown使用：正常触发事件
                                        也可以使用keyCode去指定具体的按键（不推荐）例如：@keyup.13
                                        Vue.config.keyCodes.自定义键名 = 键码（13），可以去定制按键别名
                                        当需要按下ctrl+y才能触发事件可以这样写：@keyup.ctrl.y="showInfo"
                            鼠标事件
                                鼠标事件分类
                                    @click  //单击
                                        @click.left  //左键单击
                                        @click.right  //右键单击
                                        @click.middle  //点击中间滑轮
                                    @dblclick  //双击
                                    @mousedown  //按下
                                    @mouseup  //抬起
                                    @mousemove  //移动
                                    @mouseout  //移出
                                    @mouseenter  //进入
                                    @mouseleave  //离开
                                    @mouseover  //经过
                                事件修饰符
                                    
                                        @click.prevent：阻止默认行为（常用）
                                        @click.stop：阻止事件冒泡（常用）
                                        @click.once：事件只触发一次（常用）
                                        @click.capture：使用事件的捕获模式
                                        @click.self：只有event.target是当前操作的元素时才触发事件（只会触发自己范围内的事件，不包含子元素）
                                        @click.passive：事件的默认行为立即执行，无需等待事件回调执行完毕
                    条件渲染指令
                        v-if
                            写法
                                ® v-if=“表达式”
                                v-else-if=“表达式”
                                v-else
                            适用场景
                                切换频率较低的场景
                            特点
                                不展示的DOM元素直接被移除
                            注意
                                v-if可以和v-else-if、v-else一起使用，但要求结构不能被“打断”
                        v-show
                            写法
                                v-show=“表达式”
                            适用场景
                                切换频率较高的场景
                            特点
                                不展示的DOM元素未被移除，仅仅是使用样式隐藏掉（display：none）
                    列表渲染指令    
                        v-for
                            语法
                                v-for=“（item，index） in（或者of） xxx” ：key=“yyy”
                            可遍历
                                数组、对象、字符串（用的很少）、指定次数（用的很少）
                            key作用与原理（vue中的key有什么作用？）
                                虚拟DOM中key的作用
                                    key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则
                                        旧虚拟DOM中找到了与新虚拟DOM相同的key
                                            若虚拟DOM中内容没变, 直接使用之前的真实DOM
                                            若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM
                                        旧虚拟DOM中未找到与新虚拟DOM相同的key
                                            创建新的真实DOM，随后渲染到到页面
                                用index作为key可能会引发的问题
                                    若对数据进行：逆序添加、逆序删除等破坏顺序操作:会产生没有必要的真实DOM更新 ==> 界面效果没问题, 但效率低
                                    如果结构中还包含输入类的DOM：会产生错误DOM更新 ==> 界面有问题
                                开发中如何选择key?
                                    最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值
                                    如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的
                    防止闪现指令
                        v-cloak
                            当网络较慢，网页还在加载 Vue.js ，而导致 Vue 来不及渲染，这时页面就会显示出 Vue 源代码。我们可以使用 v-cloak 指令来解决这一问题。v-cloak 指令设置样式，这些样式会在 Vue 实例编译结束时，从绑定的 HTML 元素上被移除
                                
                                
                            注意
                                在简单项目中，使用 v-cloak 指令是解决屏幕闪动的好方法。但在大型、工程化的项目中（webpack、vue-router）只有一个空的 div 元素，元素中的内容是通过路由挂载来实现的，这时我们就不需要用到 v-cloak 指令（大型项目中一般不会出现闪现现象）
                    静态内容指令
                        v-once
                            v-once所在节点在初次动态渲染后，就视为静态内容了，以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能
                                
                                
                    跳过编译指令
                        v-pre
                            跳过其所在节点的编译过程，可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译
                自定义指令       
                    为什么要使用自定义指令
                        在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令，一般需要对DOM元素进行底层操作时使用，尽量只用来操作 DOM展示，不修改内部的值。当使用自定义指令直接修改 value 值时绑定v-model的值也不会同步更新；如必须修改可以在自定义指令中使用keydown事件，在vue组件中使用 change事件，回调中修改vue数据
                    自定义指令分类
                        局部指令
                            只针定义自定义指令所在的组件内的元素
                                
                        全局指令
                            在任意页面的任意位置都可使用的自定义指令
                                
                    自定义指令定义形式
                        函数形式
                            
                        对象形式
                            配置对象中常用的3个回调:
    □ bind:指令与元素成功绑定时调用。
    □ inserted:指令所在元素被插入页面时调用。
    □ update:指令所在模板结构被重新解析时调用。
                    注意
                        指令定义时不加v-，但使用时要加v-
                        指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名，定义的时候要加引号’kebab-case‘。
        数据代理
            原理
                Object.defineProperty
                    vue是采用Object.defineProperty的getter和setter，并结合观察者模式来实现数据绑定的。
                        
            概念
                通过一个对象代理另一个对象中属性的操作（读/写）
                    
            Vue中的数据代理
                通过vm对象来代理data对象中属性的操作
                Vue中数据代理的好处
                    更加方便操作data中的数据
                基本原理
                    通过Object.defineProperty()把data中所有属性添加到vm上
                    为每个添加到vm上的属性，都指定一个getter和setter
                    在getter和setter内部操作（读/写）data中对应的属性
        Vue监测数据的原理
            Vue会监测data中所有层次的数据
            Vue如何监测data中对象中的数据
                通过setter实现监测，且要在new Vue时就传入要监测的数据
                对象中的所有属性都有专门的setter
                对象中后加入的属性，Vue默认不做响应式处理
                如需要给对象中后加入的属性做响应式，要使用如下API去添加对象中新的属性
                    Vue.set(target,propertyName/index,value)
                    vm.$set(target,propertyName/index,value)
            Vue如何监测data中数组中的数据
                通过包裹数组更新元素的方法实现，本质上做了两件事
                    调用原生对应方法对数组进行更新
                    重新解析模板，进而更新页面
                数组中的每一项没有单独为其服务的setter，所以整体修改数组中的每一项Vue不会监测，即arr[0] = …没有效果
                ® 如需在Vue修改数组中某个元素一定要用如下方法
                    使用这些数组本来的API：push（）、pop（）、shift（）、unshift（）、splice（）、sort（）、reverse（）
                    Vue.set(target,propertyName/index,value)
                    vm.$set(target,propertyName/index,value)
        属性
            el
                el写法
                    new vue时配置el属性
                        
                    先创建Vue实例，随后通过实例.$mount('#root')指定el的值
                        
            data
                data写法
                    对象式
                        
                    函数式
                        
            computed：计算属性
                定义
                    要用的属性不存在，要通过已有的属性计算得来（通过data中的数据计算得来）
                原理
                    底层借助Object.defineProperty方法提供的getter和setter
                get函数什么时候执行？
                    初次读取时会执行一次
                    当依赖的函数改变时会再次调用
                优势
                    与methods相比，内部有缓存机制（复用）效率更高，调试方便
                备注
                    计算属性最终会出现在vm上，直接读取使用即可
                    如果计算属性要被修改，必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变
                        
                    计算属性依赖data中的数据时，data中它所依赖的数据变化时，他也跟着变化
                    简写
                        
            watched：监视属性
                当被监视的属性变化时，回调函数自动调用，进行相关操作
                监视的属性必须存在，才能进行监视
                data中的属性可以被监视，计算属性computed中的属性也可以被监视
                监视的两种写法
                    
                        new Vue时传入watch配置
                        通过vm.$watch监视
                立即执行
                    immediate：true
                深度监视
                    deep：true
                        
                            Vue中的watch默认不监视对象内部值的改变（一层）
                            配置watch里面的deep：true可以监测到对象内部值得改变（多层）
                            Vue自身可以读取到或者改变多层的内部值，但是Vue提供的watch默认不能监视到
                            使用watch时根据数据的具体结构，决定是否采用深度监视
                监视简写
                    new Vue直接配置时简写第一种
                        
                    vm.$watch监视简写
                        
                计算属性与监视属性区别
                    computed能完成的功能，watch都可以完成
                    watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作
                原则
                    ◊ 所有被Vue管理的函数，最好写成普通函数，这样this的指向才是vm或者组件实例对象
                    所有不被Vue管理的函数（定时器函数、AJAX的回调函数，Promise的回调函数）最好写成箭头函数，这样this的指向才是vm或者组件实例对象
            props：接收数据属性
                功能
                    让组件接收外部传过来的数据
                数据传递
                    父组件传递数据
                        
                            <子组件名 传递数据定义的名字="具体数据"/>
                                <Demo name="xxx"/>
                    子组件接收数据
                        
                            第一种方式（只接收）【数组形式】
                                props:['name'，‘age’]
                            第二种方式（限制类型）【对象形式】
                                props:{name:String}
                            第三种方式（限制类型、限制必要性、指定默认值）【对象形式】
                                props:{
    name:{
    type:String, //类型
    required:true, //必要性
    default:'老王' //默认值
    }
    }
                注意
                    props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据
                        
        mixin混入
            功能
                可以把多个组件共用的配置提取成一个混入对象
            使用方式
                定义混入
                    
                使用混入
                    全局混入 Vue.mixin(xxx)
                        
                            
                    局部混入 mixins:[xxx]
                        
        filter过滤器
            定义
                对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）
            语法
                注册过滤器：Vue.filter(name,callback)【全局过滤器】 或 new Vue{filters:{}}【局部过滤器】
                使用过滤器：{{ xxx | 过滤器名}}  或  v-bind:属性 = "xxx | 过滤器名"
            备注
                过滤器也可以接收额外参数、多个过滤器也可以串联
                并没有改变原本的数据, 是产生新的对应的数据，所以要return
            示例
                
                    
        生命周期
            
                又名
                    生命周期回调函数（没调用，但是执行了）、生命周期函数、生命周期钩子
                概念
                    Vue在关键时刻帮我们调用的一些特殊名称的函数
                生命周期函数中的this指向是vm或者组件实例对象
                常用的生命周期钩子
                    mounted
                        发送AJAX请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】
                    beforeDestroy
                        清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】
                关于销毁Vue实例
                    销毁后借助Vue开发者工具看不到任何消息
                    销毁后自定义事件会失效，但原生DOM事件依然有效
                    一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了
        动画与过渡
            写法
                
                若有name属性，定义动画或者过渡样式的时候不要写.v-enter等,要写成.名字-enter
                
            动画
                
                
            过渡
                
                
            第三方
                

    2.vue组件化编程
        组件概念
            用来实现局部(特定)功能效果的代码集合
        组件（.vue 文件）的组成
            模板页面
                <template>
    页面模板 
    </template>
            JS 模块对象
                <script>
    export default {
        data() {return{}},
    methods:{},
    computed:{},
    components:{}
    }
    </script>
            样式
                <style>
    样式定义
    </style>
        组件的使用
            局部注册组件的使用
                引入组件（import）+注册组件（components）：{}
                    使用组件
            全局注册组件的使用
                引入组件（import）+注册组件（Vue.component（'组件名',组件））
                    使用组件
        VueComponent构造函数
            组件本质是一个名为VueComponent的构造函数
            我们只需要写<school/>或<school></school>，Vue解析时会帮我们创建school组件的实例对象，即Vue帮我们执行的：new VueComponent(options)
            关于this指向
                组件配置中
                    data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】
                new Vue(options)配置中
                    data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】
            内置关系
                注：这个关系使得组件实例对象（vc）也可以访问到Vue原型上的属性、方法
        组件间数据通信
            props：父给子传递数据
                父组件中在子组件自身传递数据
                    
                子组件在props接收父组件传递过来的数据
                    props中的数据直接挂载到组件实例中，直接用this...可以访问的到
            自定义事件：子给父传递数据
                子组件中触发自定义事件
                    在子组件中有一个点击事件：点击事件中的方法中this.$emit('自定义事件名称'，传递的参数)
                        
                父组件定义自定义事件并接收数据
                    在父组件中的子标签上写自定义事件及方法@自定义事件名称="方法名称"
                        父组件methods方法中定义test方法methods：{test（接收的参数） {}}
            全局事件总线：任意组件间通信
                安装全局事件总线
                    
                使用全局事件总线
                    传递方this.$bus.$emit('xxx',数据）
                    接收方this.$bus.$on('xxx',this.方法名)/this.$bus.$on('xxx',回调函数)【回调函数写成箭头函数】
                        
                    注意
                        
                            
            消息订阅与发布：任意组件间通信
                安装pubsub
                    
                使用pubsub
                    引入pubsub
                        
                    传递方
                        
                    接收方
                        
                    注意
                        
            vuex：万能
            插槽：父子组件间通信（一般是结构，即标签）
                作用
                    父组件向子组件指定位置插入html结构（默认插槽、具名插槽），或者子组件给父组件传递数据，父组件决定插入子组件对应位置的结构（作用域插槽）
                分类
                    默认插槽
                        
                    具名插槽
                        
                    作用域插槽
                        数据在子组件中，但是自己不能决定结构，需要将数据传递给父组件，父组件决定结构
                            
                            
                        例子
                            
                                父组件
                                    
                                子组件1
                                    
                                子组件2
                                    
            v-model：子组件有表单元素时
                父子组件数据实时同步实现
                    父组件传递数据，在子组件input中显示，并接收子组件input改变的值，修改data中的相关数据
                        
                    子组件接收父组件的数据在input中展示，并传递自己改变的值在父组件中修改对应的data中的数据
                        
            sync属性修饰符【与v-model类似】
                父组件
                    ：money.sync="moneys",代表了两个含义
                        给子组件传递了一个名为money的props
                        给自身自动绑定了一个自定义事件，自定义事件为子组件触发的事件名称，并将子组件触发自定义事件时传递过来的值自动赋予自身money所绑定的data中的特定数据moneys
                            
                子组件
                    当一个子组件改变了一个带 .sync 的prop的值时，这个变化也会同步到父组件中所绑定的值
            $attrs与$listeners（都是对象形式）
                $attrs与$listeners它们两者是组件实例的属性，可以获取到父组件给子组件传递的props和自定义事件
                    父组件
                        
                    子组件
                        
            $children（数组）与$parent
                例子
                    要实现的功能
                        父组件
                            
                                ref可以获取到某一个DOM节点、组件标签、子组件标签（以便操作子组件的数据与方法）；$children组件实例的属性，可以获取到当前组件的全部子组件【数组】
                        子组件
                            $parent组件实例的属性，可以获取到当前子组件的父组件。从而可以操作父组件的数据和方法
            依赖注入（（provide/ inject））
                provide / inject是Vue提供的两个钩子，和data、methods是同级的。并且provide的书写形式和data一样。● provide 钩子用来发送数据或方法● inject钩子用来接收数据或方法
                    父组件
                    子组件
                    或者这样写可以访问父组件中的所有属性

    3.vue-cli脚手架
        作用
            vue脚手架的作用是用来自动一键生成vue+webpack的项目模版,包括依赖库,免去你手动安装各种插件,寻找各种cdn并一个个引入的麻烦
        使用步骤
            第一步（仅第一次执行）：全局安装@vue/cli
                npm install -g @vue/cli
            第二步：切换到你要创建项目的目录，然后使用命令创建项目
                vue create xxxx
            第三步：启动项目
                npm run serve
        模板项目结构
            

    4.vue中的AJAX
        配置代理   
            
        配置axios
            
            
        配置API
            配置
                
            使用
                

    5.vuex
        vuex概念
            专门在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 vue 应 用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方 式，且适用于任意组件间通信
        vuex工作原理图
            
        vuex
            vuex构造
                actions
                    由子组件this.$store.dispatch('actions名',传递的数据）触发
                    actions： { action名（{commit}，数据）{...}}
                mutations
                    由actions中的commit('mutations名',传递的数据）触发
                    mutations：{mutations名（state,数据）{...}}
                state
                    存储数据：state：{userInfor：{}}
                getters
                    计算state中的数据：getters：{getters名（state）{...}}
            vuex中的模块(module)和命名空间(namespaced)
                vuex模块(module)
                    由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。
    为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的state、mutations、actions、getters、甚至是嵌套子模块。
                        vuex的常规用法（不使用模块(module)的store）
                            创建store    
                                
                                    
                            在组件中使用
                                
                                    
                                mapState、mapGetters、mapActions、mapMutations两种写法
                                    mapState、mapGetters两种写法
                                    mapActions、mapMutations两种写法
                        vuex中模块的基础使用（不开启命名空间时）
                            默认情况下，模块内部的 actions、mutations 和 getters 是注册在全局命名空间的——这样使得多个模块能够对同一 mutations 或 actions 作出响应。对于actions、mutations 和 getters，是在模块中还是在全局中，它们的使用方式是相同的，只是state会有所不同，模块中的state会多一层模块名。格式变成store.state.模块名.状态名
                                目录结构
                                    
                                store模块
                                    创建一个带模块的根store
                                        
                                            
                                    store子模块
                                        主题模块（store/modules/theme.js）内容
                                            
                                                
                                        产品模块（store/modules/product.js）内容
                                在组件中使用
                                    
                                        
                vuex命名空间(namespaced)
                    默认情况下，模块内部的 actions、mutations 和 getters 是注册在全局命名空间的——这样使得多个模块能够对同一 mutations 或 actions 作出响应，如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getters、actions 及 mutations 都会自动根据模块注册的路径调整命名。
                        vuex中模块的基础使用（开启命名空间时）
                            如果你想模块之间相互独立、互不影响。可以通过添加 namespaced: true 的方式使其成为带命名空间的模块，当模块被注册后，它的所有 getters、actions 和 mutations 都会自动根据模块注册的路径调整命名。所以开启命名空间的模块中的getters、actions 和 mutations的使用方式都会改变；但是开启命名空间和不开启命名空间的模块中的state的使用方式不会改变。格式依然是store.state.模块名.状态名
                                开启store子模块的命名空间
                                    
                                在组件中使用
                                    
                                        

    6.vue-router
        相关概念
            vue-router
                vue 的一个插件库，专门用来实现 SPA 应用
            SPA 应用
                单页 Web 应用（single page web application，SPA）
                整个应用只有一个完整的页面
                点击页面中的导航链接不会刷新页面，只会做页面的局部更新
                数据需要通过 ajax 请求获得
            路由
                路由概念
                    个路由就是一组映射关系（key - value）
                    key 为路径, value 可能是 function 或 component
                路由分类
                    后端路由
                        理解：value 是 function, 用于处理客户端提交的请求
                        工作过程：服务器接收到一个请求时, 根据请求路径找到匹配的函数 来处理请求, 返回响应数据
                    前端路由
                        理解：value 是 component，用于展示页面内容
                        工作过程：当浏览器的路径改变时, 对应的组件就会显示
        路由组件与非路由组件区别
            非路由组件放在components中，路由组件放在pages或views中
            非路由组件通过标签使用，路由组件通过路由使用
            在main.js注册完路由，所有的路由和非路由组件身上都会拥有$router 、$route属性
            $route： 一般获取路由信息（ path query  params meta等）
            $router：一般进行编程式导航进行路由跳转（push replace 【还有forward（）、back（）、go（参数：可正可负）】）
        路由的基本使用
            
                下载vue-router
                    npm i vue-router
                引入vue及vue-router
                    import Vue from '...';import router from '...';
                应用插件vue-router
                    Vue.use(router)
                在main.js中引入并注册router
                    
                配置vue-router
                    配置项
                        routes：[ { },{ }...]
                            routes为数组，数组里面为每个路由的配置对象，配置对象中常用的属性包括
                                path：‘/home';
                                name:'Home'; 
                                component:Home(要事先引入Home这个路由组件）
                                    路由懒加载
                                        component：（）=> import('@/Home')
                                children:[{ },{ }...]
                                    children为数组，数组中为每个路由的配置对象，配置对象常用的属性与routes一致，注意children中的每一个配置对象中的path后面的路径不加/，即path：'detail'
                                        为什么要二级路由（即配置children）：因为在跳转的时候不是全部覆盖掉原来的界面，而是在原来的基础上添加一个组件
                                        二级路由和引入组件不同，二级路由不需要在上一个页面引入，直接在路由页面引入即可（上一个页面的路由和子组件的路由都要引入，子组件的路由写在上一个页面组件（也就是父组件）路由的children里面，在父组件中写声明式导航或者编程式导航，在插入的位置上写<router-view></router-view>
                                meta:{ xxx:xxx,yyy:yyy...}
                                props（用于该路由接收传递过来的query或者params参数）
                                    对象型--props：{a:100,b:200 }
                                        路由配置项
                                        该路由组件内用props接收
                                    布尔型（仅限params参数）--props：true/false；
                                        路由配置项
                                        跳转到该路由组件的页面
                                        该路由组件内用props接收
                                    函数型--props($route) {return {id:$route.query.id,name:$route.query.name}}
                                        该路由配置项
                                        跳转到该路由组件的页面
                                        该路由组件内用props接收
                        scrollBehavior(to, from, savedPosition) {
        // 始终滚动到顶部
        return { y: 0 }
    }
        路由跳转
            路由跳转方式
                声明式导航<router-link to="/home"></router-link >
                    直接跳转，无需业务逻辑的处理
                        router-link（可以理解为a标签，可以加class修饰）【就是把a替换成router-link】
                            
                编程式导航this.$router.push/replace( )
                    需要处理业务逻辑，比如发送ajax请求，需要响应数据
                        push、replace【就是利用点击事件等配置methods，methods里面写this.$router.push("路径")（直接写路径的是无需传参数）】
                            push有历史记录，replace没有历史记录
            配置路由出口（在哪里展示）
                <router-view></router-view>
                    
        路由传参
            query参数
                不属于路径中的一部分，类似于ajax中的queryString  /home?k=v&k=v，路径与参数之间用？隔开,路由信息配置path时不需要占位
                    声明式导航传递query参数
                        to的对象写法中的path可以换成name
                    编程式导航传递query参数
                        编程式导航里面的配置项不能用path，要用name
            params参数
                属于路径中的一部分，需要注意，在配置路由时，路由信息配置path时需要占位
                    跳转目标路由信息配置的path中需要占位
                        声明式导航传递params参数
                            
                                接收参数
                        编程式导航传递params参数
                            编程式导航里面的配置项不能用path，要用name
                params传参问题
                    如何指定params参数可传可不传？
                        
                    解决了params参数可传可不传问题后，若传递的params为空字符串怎么解决？
                        
        路由守卫
            守卫分类
                全局守卫
                    前置路由守卫--router.beforeEach((to,from,next){...})
                        
                    后置路由守卫----router.afterEach((to,from){...})
                    全局解析守卫--router.beforeResolve
                独享守卫
                    beforeEnter：（to,from,next）=>{...}
                        写在哪个路由组件配置信息中就表示哪个组件需要权限
                组件内守卫
                    beforeRouteEnter(to,from,next){...}
                        组件内路由守卫是在组件内写
                    beforeRouteupdate(to,from,next){...}
                    beforeRouteLeave(to,from,next){...}
            守卫next（）问题
                next（）直接放行
                next（‘/home’）放行到home路由
                next（false）【停留在来的时候原来的页面】
        路由独有的两个生命周期函数
            
            应用
                当绑定的表达式需要用键值对时，要写成对象形式
                    可以这样写
                        也可以这样写
        缓存路由组件
            include后面跟的是组件名
            当要缓存多个组件时，可以写成数组形式，include前面要加冒号
        路由history与hash模式
            

    7.vue ui组件库
        移动端常用 UI 组件库
            Vant https://youzan.github.io/vant
            Cube UI https://didi.github.io/cube-ui
            Mint UI http://mint-ui.github.io
        PC 端常用 UI 组件
            Element UI https://element.eleme.cn
            IView UI https://www.iviewui.co

    Js知识点
    DOM
        DOM树
            
        事件基础
            事件三要素
                事件源（谁）
                事件类型（鼠标事件、键盘事件等）
                    常见的鼠标事件
                        鼠标左键点击触发：click（onclick）
                        鼠标经过触发：mouseover（onmouseover）/mouseenter（onmouseenter）
                            mouseover与mouseenter区别
                                mouseenter鼠标事件：当鼠标移动到元素上就会触发mouseenter事件；mouseover鼠标经过自身盒子会触发，经过子盒子也会触发；mouseenter只会经过自身盒子才会触发，因为mouseover有冒泡，mouseenter没有冒泡
                        鼠标离开触发：mouseout（onmouseout）/mouseleave（onmouseleave）
                            mouseout与mouseleave区别
                                mouseleaver鼠标事件：当鼠标离开到元素上就会触发mouseleave事件；mouseout鼠标离开自身盒子会触发，离开子盒子也会触发；mouseleaver只会离开自身盒子才会触发，因为mouseout有冒泡，mouseleave没有冒泡
                        获得焦点触发：focus（onfocus）
                        失去焦点触发：blur（onblur）
                        鼠标移动触发：mousemove（onmousemove）
                        鼠标按下触发：mousedown（onmousedown）
                        鼠标弹起触发：mouseup（onmouseup）
                        禁止鼠标右键菜单
                            contextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单
                                
                        禁止鼠标选中
                            selectstart主要控制选中，主要用于程序员取消默认的选中区域
                    常见的键盘事件
                        某个键盘被松开时触发：keyup（onkeyup）
                            不区分大小写
                        某个键盘被按下时触发：keydown（onkeydown）
                            不区分大小写
                        某个键盘被松开时触发：keypress（onkeypress）
                            区分大小写
                事件处理函数（干什么/函数）
            执行事件步骤
                获取事件源
                    获取元素
                        利用DOM提供的方法获取元素
                            根据id获取
                                document.getElementById('id名')
                            根据标签获取
                                document.getElementByTagName('标签名'）
                            根据类名获取
                                document.getElementByClassName('类名')
                            querySelector('选择器')
                                选择类：document.querySelector('.类名’)
                                选择id：document.querySelector('#id名’)
                                选择标签：document.querySelector('li')
                            querySelectorAll('选择器')
                            获取特殊元素
                                获取html元素：document.documentElement
                                获取body元素：document.body
                        利用节点层级关系获取
                            节点定义
                                
                            获取元素
                                父级节点（亲父亲）：节点名.parentNode
                                    parentNode属性可返回某节点的父亲节点，注意是最近的一个父节点
                                    如果指定的节点没有父节点则返回null
                                子节点
                                    标准：父节点名.childNodes（标准）
                                        返回包含指定节点的子节点的集合，该集合为即时更新的集合
                                        返回值里面包含了所有的子节点，包括元素节点、文本节点等
                                        若只想要里面的元素节点，则需要专门处理，所以我们一般不提倡使用该方法
                                            
                                    非标准
                                        方法一
                                            获取第一个子节点：父节点名.firstChild
                                            获取最后一个子节点：父节点名.lastChild
                                        方法二
                                            获取第一个子节点：父节点名.firstElementChild
                                            获取最后一个子节点：父节点名.lastElementChild
                                        方法三
                                            获取第一个子节点：父节点名.children[0]
                                            获取最后一个子节点：父节点名.children[父节点名.children.length - 1]
                                兄弟节点
                                    方法一
                                        获取上一个兄弟节点：节点名.nextSibling
                                        获取下一个兄弟节点：节点名.previousSibling
                                    方法二
                                        获取上一个兄弟节点：节点名.nextElementSibling
                                        获取下一个兄弟节点：节点名.previousElementSibling
                注册事件（绑定事件）
                    传统方式：事件源.onclick = function（） {...}
                        解绑事件：元素.onclick = null
                            
                    方法监听注册方式：元素.addEventListener(‘click’，function（） {...})
                        解绑事件：元素.removeEventListener（type，listener,useCapture);
                            
                添加事件处理程序（采取函数赋值形式）
                    操作元素
                        元素新增/删除
                            创建元素
                                document.createElement('标签名')
                            添加元素
                                添加到父节点的最后位置：父节点名.appendChild(添加的元素)
                                    
                                添加到父元素中指定子元素前面：父元素名.insertBefore(添加的元素，指定元素)
                                    
                            删除元素
                                父节点名.removeChild（子节点名）
                                    
                            复制元素
                                要克隆的节点名.cloneNode（true/false）
                                    false
                                        
                                    true
                                        
                        元素内容属性操作
                            改变元素内容
                                元素名.innerText
                                    从起始位置到终止位置的内容，不识别html标签同时空格和换行也会去掉。
                                元素名.innerHTML
                                    起始位置到终止位置的全部内容，识别html标签，同时保留空格和换行。
                            常见元素属性操作
                                src、href、 id、alt、title（都是元素.属性=“”）
                                    
                            表单元素属性操作
                                type、value、checked、selected、disabled
                                    
                            样式属性操作
                                修改元素的大小、颜色、位置（定位中的left、top等）、隐藏等样式：元素名.style.width =""
                                    
                            类名属性操作
                                
                                    className会直接更改元素的类名，覆盖掉原先的类名，解决方法：两个类名都写且用空格隔开。
                                        
                            自定义属性操作
                                设置属性值
                                    H5规定自定义属性data-开头作为属性名并赋值，比如data-index = “1”
                                        元素名.setAttribute('data-index', '2')
                                获取属性值
                                    元素名.getAttribute('属性')
                                移除属性
                                    元素名.removeAttribute('属性')
                    事件对象
                        事件对象概念
                            
                            
                            
                        事件对象的常见属性和方法
                            e.target
                                返回触发事件的对象 标准
                                    e.target返回的是触发事件的对象（点击了哪个元素返回哪个对象或元素）；this返回的是绑定了事件的对象（元素）；this约等于e.currentTarget。
                                        
                            e.srcElement
                                返回触发事件的对象 非标准 ie6、7、8使用
                            e.type
                                返回事件的类型 比如click、mouseover 不带on
                                    
                            e.cancelBubble
                                该属性阻止冒泡、非标准 ie6、7、8使用
                            e.returnValue
                                该属性阻止默认事件（默认行为） 非标准 ie6、7、8使用 比如不让链接跳转
                            e.preventDefault()
                                该属性阻止默认事件（默认行为） 标准  比如不让链接跳转
                                    
                            e.stopPropagation()
                                阻止冒泡 标准
                                    
                        鼠标事件对象
                            e.clientX
                                返回鼠标相对于浏览器窗口可视区的X坐标
                            e.clientY
                                返回鼠标相对于浏览器窗口可视区的Y坐标
                            e.pageX
                                返回鼠标相对于文档页面的X坐标
                            e.pageY
                                返回鼠标相对于文档页面的Y坐标
                            e.screenX
                                返回鼠标相对于电脑屏幕的X坐标
                            e.screenY
                                返回鼠标相对于电脑屏幕的Y坐标
                        键盘事件对象
                            键盘事件对象---keyCode:返回该键的ASCII值
                                
                    DOM事件流
                        事件流概念
                            事件流描述的是从页面中接收事件的顺序。事件发生会在元素节点之间按照特定的顺序传播，这个传播过程就是DOM事件流。
                                
                                    
                        事件捕获：从外到里【若子和父都有点击事件，那么点击父亲，只会执行父亲的回调，若点击儿子，先会执行父亲的，再执行儿子的】
                        事件冒泡：从里到外【若子和父都有点击事件，若点击父亲的，只会执行父亲的，若点击儿子的，会先执行儿子的，后执行父亲的】
                            事件冒泡应用：事件委托（代理、委派）
                                
                                    事件委派原理
                                        不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理，通过e.target影响设置每个子节点。
                                    事件委派作用
                                        只操作了一次DOM，提高了程序的性能

    BOM  
        BOM概念
            BOM是浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是windows。BOM由一系列相对对象的构成，并且每个对象都提供了很多方法和属性。
        BOM构成
            
                window
                    window对象是浏览器的顶级对象，它具有双重角色。
                        他是JS访问游览器窗口的一个接口
                        他是一个全局对象，定义在全局作用域中的变量、函数都会变成window对象的属性和方法。在调用的时候可以省略window，前面学习的对话框属于window对象方法，如alert（）、prompt（）等
                    windows对象的常见事件
                        窗口加载事件
                            概念
                                window.onload是窗口（页面）加载事件，当文档内容完全加载完成会触发该事件（包括图像、脚本文件、CSS文件等）。就调用的处理函数。
                            写法
                                window.onload = function() {...}
                                window.addEvebtListener('load',function() {...})
                            注意
                                有了window.onload就可以把JS代码写到页面元素的上方，因为onload是等页面内容全部加载完毕，再去执行处理函数；
                                window.onload传统注册事件方式只能写一次，会以最后一个window.onload为准。
                                如果使用addEventListener则没有限制。
                                
                        调整窗口大小事件
                            概念
                                调整窗口大小加载事件，当触发时就调用的处理函数。
                            写法
                                window.onresize = function () {...}
                                window.addEventListener('resize',function() {...})
                            注意
                                只要窗口大小发生像素变化，就会触发这个事件
                                我们经常利用这个事件完成响应式布局。window.innerWidth当前屏幕的宽度。
                                    
                        定时器
                            setTimeout（）【一次性】
                                设置定时器
                                    window.setTimeout(调用函数，[延迟的毫秒数])；
                                        
                                    注意
                                        window可以省略
                                        这个调用函数可以直接写函数，或者写函数名或者采取字符串‘函数名（）’三种形式
                                        间隔的毫秒数省略默认是0，如果写，必须是毫秒，表示过多长时间自动调用这个函数，一次性，不重复
                                        因为定时器可能很多，所以我们经常给定时器赋值一个标识符。
                                清除定时器
                                    window.clearTimeout(定时器名字)；
                                        
                            setInterval（）【可重复】
                                设置定时器
                                    window.setInterval(调用函数，[延迟的毫秒数])；
                                        
                                    注意
                                        window可以省略
                                        这个调用函数可以直接写函数，或者写函数名或者采取字符串‘函数名（）’三种形式
                                        间隔的毫秒数省略默认是0，如果写，必须是毫秒，表示每间隔多长时间自动调用这个函数
                                        因为定时器可能很多，所以我们经常给定时器赋值一个标识符。
                                清除定时器
                                    window.clearInterval(定时器名字)；
                                        
                document
                location
                    概念
                        window对象给我们提供了一个location属性用于获取或者设置窗体的URL，并且可以解析URL，因为这个属性返回的是一个对象，所以我们将这个属性也称为location对象。
                        URL统一资源定位符是互联网上标准资源的地址，互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器该怎么处理他。
                            
                    location对象的属性
                        location.href
                            获取或者设置整个URL
                                
                        location.host
                            返回主机（域名）www.itheima.com
                        location.port
                            返回端口号 如果未写返回空字符串
                        location.pathname
                            返回路径
                        location.search
                            返回参数【问号后面的】
                        location.hash
                            返回片段 #后面内容 常见于链接、锚点
                    location对象方法
                        location.assign( )
                            跟href一样，可以跳转页面（也称为重定向页面），记录历史
                        location.replace( )
                            替换当前页面，因为不记录历史，所以不能后退页面
                        location.reload( )
                            重新加载页面，相当于刷新按钮或者f5 如果参数为true 强制刷新ctrl+f5
                        
                navigator
                    概念及作用
                        navigator对象包含有关浏览器的信息，他有很多属性，我们最常用的是userAgent，该属性可以返回由客户机发送服务器的user-agent头部的值。下面前端代码可以判断用户用哪个终端打开页面，实现跳转。
                            
                screen
                history
                    概念
                        window对象给我们提供了一个history对象，与浏览器历史记录进行交互。该对象中包含用户（在浏览器窗口中）访问过的URL。
                    方法
                        切换历史状态
                            history.forward( )
                                前进功能
                            history.back( )
                                可以后退功能
                            history.go(参数)
                                前进后退功能，如果参数是1 前进1个页面 如果是-1 后退1个页面
                                    
                                        
                        修改历史状态
                            history.pushState(state, title[, url])
                            history.replaceState(state, title[, url])

    ECMAScript
        变量
            概念
                变量就是一个装东西的盒子；变量是用于存放数据的容器，我们通过变量名获取数据，甚至数据可以修改。本质：变量是程序在内存中申请的一块用来存放数据的空间。
            使用
                声明变量
                    var uage；
                赋值
                    uage=18；
                变量的初始化
                    声明一个变量并赋值
            语法拓展
                变量的更新
                    一个变量被重新赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。（var a = 18；a = 20；最终a的结果为20）
                同时声明多个变量
                    同时声明多个变量时，只需要写一个var，多个变量名之间使用英文逗号隔开。var a = 1，b=2，c=3；
                声明变量的特殊情况
                    只声明，不赋值
                        undefined
                    不声明，不赋值
                        报错
                    不声明，赋值
                        正常输出（不建议使用）
            命名规范
                由大小写字母、数字、下划线和$组成
                严格区分大小写
                变量不能以数字开头
                不能是关键字、保留字
                变量名必须有意义
        数据
            数据类型
                数据类型分类
                    基本数据类型/简单数据类型/值类型
                        Number（数字型）【包含整型值和浮点值】
                            数字型进制
                                二进制
                                八进制
                                十进制
                                十六进制
                            数字型范围
                                最大值
                                    Number.MAX_VALUE
                                最小值
                                    Number.MIN_VALUE
                            数字型三个特殊值
                                无穷大
                                    Infinity
                                无穷小
                                    -Infinity
                                非数值
                                    NaN
                                        通常用isNaN（）来判断是否为数值型，返回true为非数值型，返回false为数值型
                        String（字符串型）
                            字符串引号嵌套
                                可用单引号，也可以用双引号，规则：内双外单，内单外双
                            字符串转义符
                                转义符必须包含在引号里面，转义符都是\开头的
                                    /n【换行符】
                                    /t【缩进符】
                                    /b【空格符】
                                    /'【单引号】
                                    /"【双引号】
                                    //【斜杠】
                            字符串长度
                                通过s.length获取字符串长度
                            获取字符串特定位置元素
                                通过索引值获取，索引值从0开始
                                    str[0]获取数组中的第一个
                            字符串拼接
                                +连接，数值相加，字符相连
                        Boolean（布尔型）
                            true（真/1）
                            false（假/0）
                        Null
                            通过id获取元素如果获取不到，返回的值默认为null
                            可以给变量赋值为null，来清空变量，可以用来释放堆内存；
                            正则捕获捕获不到内容时，返回值为null
                        Undefined
                            如果变量只声明未定义，默认存储的值为undefined;
                            获取对象的某个属性是，如果属性不存在，获取的值是undefined;
                            如果函数的形参没有对应的实参，那么形参默认存储的值是undefined；
                            如果函数没有return返回值，那么默认的返回值是undefined；
                        Symbol
                            Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题
                                特点
                                    Symbol 的值是唯一的，用来解决命名冲突的问题
                                    Symbol 值不能与其他数据进行运算
                                    Symbol 定义 的 对象属 性 不能 使 用 for…in 循 环遍 历 ，但 是可 以 使 用 Reflect.ownKeys 来获取对象的所有键名
                    引用数据类型/复杂数据类型（统称为Object）
                        Object（对象）
                            对象的概念
                                在JS中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。对象是由属性和方法组成的。
                                    属性
                                        事物的特征，在对象中用属性来表示（常用名词）
                                    方法
                                        属性的行为，在对象中用方法来表示（常用动词）
                            应用
                                保存一个值时，可以使用变量，保存多个值（一组值）时，可以使用数组。如果要保存一个人的完整信息则用对象。
                            创建对象
                                利用new创建
                                    var obj = new Object（）；obj.name="cara";obj.age=18;obj.sayHi = function() {console.log("Hi");
                                利用字面量创建
                                    var obj = {name:'cara',age:18,sayHi:function(){console.log('Hi') }
                                利用构造函数创建
                                    因为上面两种方法一次只能创建一个对象，当有多个对象时，需要重复创建，因此我们可以利用函数的方法，来构造多个对象。构造函数：function Star(uname,uage,usex){this.name=uname;this.age=uage;this.sex=usex;} 实例化对象：var ldh = new Star('刘德华'，18，‘男’)
                                    注意点
                                        构造函数是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，他总与new运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。
                                        构造函数，如Stars（），抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class）
                                        创建对象，如new Stars（），特指某一个，通过new关键字创建对象的过程我们也称为对象实例化。
                                        构造函数名称首字母要大写，且内部构造的属性名与方法名之前要加“this.”
                                        我们构造函数不需要return，就可以返回结果
                                        调用构造函数必须使用new
                                        只要new Star（）调用函数就创建了一个对象
                                    new关键字
                                        在内存中创建一个新的空对象
                                        让this指向这个新的对象
                                        执行构造函数里面的代码，给这个新对象添加属性和方法
                                        返回这个新对象（所以构造函数中不需要return）
                            遍历对象属性及属性值
                                for...in
                                    for(var k in obj) {} 【k为属性名，obj[k]为属性值】
                        Array（数组）
                            数组概念
                                    数组（array）是指一组数据的集合，其中的每个数据被称为元素，在数组中可以存放任意类型的元素。数组是一种将一组数据存储在单个变量名下的优雅方式。
                            创建数组
                                利用new创建
                                    var arr = new Array（）
                                利用数组字面量创建
                                    var arr = [ ] 
                            获取数组
                                获取数组中特定元素
                                    通过索引值获取，索引值从0开始
                                        arr[0]取得arr数组中的第一项
                                获取数组长度
                                    arr.length
                        Function（函数）
                            概念
                                函数就是封装了一段可被重复调用执行的代码块。通过代码块可以实现大量代码的重复使用。
                            使用
                                声明函数
                                    命名函数
                                        function fn（） {}
                                    匿名函数
                                        var fn = function（） {}
                                    箭头函数
                                调用函数
                                    fn（）【函数不调用、自己不执行】
                            参数
                                类型
                                    形参
                                        声明函数时函数名后面小括号里面的参数，函数定义的时候传递的参数，当时并不知道是什么，在js中，形参的默认为undefined
                                    实参
                                        调用函数时传递给对应函数的参数，实参是传递给形参的
                                作用
                                    在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去。参数可以有，也可以没有，并且不限个数
                                形参与实参个数不一致
                                    实参个数 = 形参个数
                                        输出正确的结果
                                    实参个数< 形参个数
                                        多的形参被定义为undefined，结果为NaN
                                    实参个数>形参个数
                                        只取到形参个数
                            返回值
                                函数只是实现某种功能，返回值需要return给函数调用者
                                return之后的代码不再执行
                                return只能返回一个值，多个返回值以最后一个为准，如果需要返回多个值，可以以数组的形式，即return [ ]
                                函数没有return返回undefined
                            arguments
                                适用场景
                                    当我们不确定有多少个参数传递的时候，可以用arguments来获取。（此时函数形参处不需要传入argument，直接在函数体内使用即可）
                                概念
                                    arguments实际上他是当前函数的一个内置对象。所有函数都内置了一个arguments对象，且只有函数有arguments，arguments对象中存储了传递的所有实参，并且无需将arguments写在形参处
                                特点
                                    arguments是伪数组，伪数组有以下特点
                                        具有length长度
                                        按照索方式存储数据
                                        不具有数组的pop、push等方法
                        Date（日期对象）
                            new Date（）是一个构造函数，必须使用new 来调用创建我们的日期对象。
                        RegExp（正则）
                            创建正则表达式
                                通过调用RegExp对象的构造函数创建
                                通过字面量创建
                            测试正则表达式
                                test（）正则对象方法，用于检测字符串是否符合该规则，该对象会返回true或false，其参数是测试字符串。
                            正则表达式中的特殊符号
                                边界符
                                    
                                        
                                字符类
                                    字符类表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在[]里：
                                        
                                            方括号里范围符—
                                                
                                            字符组合
                                                
                                            方括号[]里有^，即[^]表示取反
                                                
                                            小括号（）表示优先级
                                                
                                量词符
                                    量词符用来设定某个模式出现的次数。
                                        
                                            
                                                
                                                    
                                预定义类
                                    预定义类指的是某些常见模式的简写方式。
                                        
                            正则表达式应用
                                替换
                                    replace（）方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式。
                                        
                            正则表达式参数
                                
                                    
                            注意
                                正则表达式里面不需要加引号，不论是数字型还是字符型。
                        Math
                            Math 是一个内置对象，它拥有一些数学常数属性和数学函数方法。Math 不是一个函数对象。Math 用于 Number 类型。它不支持 BigInt。与其他全局对象不同的是，Math 不是一个构造器。Math 的所有属性与方法都是静态的。
                        Map
                            类似于对象
                        Set
                            类似于数组
                数据类型区别
                    区别
                        存储空间区别：基本数据类型存储在栈内存中，引用数据类型存储在堆内存中；
                        存储值类型区别：数据存储时，基本数据类型在变量中存的是值，引用数据类型在变量中存储的是空间地址；
                        操作区别：基本数据操作的是值，引用数据类型操作的是空间地址；
                    栈和堆空间
                        栈空间（基本数据类型）
                            
                        堆空间（引用数据类型）
                            
            数据类型检测
                typeof xxx
                    操作符返回一个字符串，表示未经计算的操作数的类型
                        typeof 1 // 'number'
                        typeof '1' // 'string'
                        typeof undefined // 'undefined'
                        typeof true // 'boolean'
                        typeof Symbol() // 'symbol'
                        typeof null // 'object'
                        typeof [] // 'object'
                        typeof {} // 'object'
                        typeof console // 'object'
                        typeof function（）{} // 'function'
                xxx instanceof constructor
                    可以正确判断对象的类型，用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上，object instanceof constructor，object为实例对象，constructor为构造函数
                        console.log(2 instanceof Number);                    // false
                        console.log(true instanceof Boolean);                // false 
                        console.log('str' instanceof String);                // false
                        console.log([] instanceof Array);                    // true
                        console.log(function(){} instanceof Function);       // true
                        console.log({} instanceof Object);                   // true
                        let Car = function() {}
    let benz = new Car()
    benz instanceof Car // true
    let car = new String('xxx')
    car instanceof String // true
    let str = 'xxx'
    str instanceof String // false
                Object.prototype.toString.call()
                    调用该方法，统一返回格式“[object Xxx]”的字符串
                        Object.prototype.toString({})       // "[object Object]"
                        Object.prototype.toString.call({})  // 同上结果，加上call也ok
    Object.prototype.toString.call(1)    // "[object Number]"
    Object.prototype.toString.call('1')  // "[object String]"
    Object.prototype.toString.call(true)  // "[object Boolean]"
    Object.prototype.toString.call(function(){})  // "[object Function]"
    Object.prototype.toString.call(null)   //"[object Null]"
    Object.prototype.toString.call(undefined) //"[object Undefined]"
    Object.prototype.toString.call(/123/g)    //"[object RegExp]"
    Object.prototype.toString.call(new Date()) //"[object Date]"
    Object.prototype.toString.call([])       //"[object Array]"
    Object.prototype.toString.call(document)  //"[object HTMLDocument]"
    Object.prototype.toString.call(window)   //"[object Window]"
                typeof与instanceof区别
                    typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值
                    instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型
                    虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了function 类型以外，其他的也无法判断
            数据类型转换
                转换为字符串类型
                    变量.toString()
                    String(变量)
                    隐式转换：加号拼接字符串：【变量 + ‘’ 】
                转换为数字类型
                    parseInt（变量）：将string类型转换成整数数值型
                    parseFloat（变量）：将string类型转换成浮点数数值型
                    Number（变量）
                    隐式转换：利用-、*、/【变量 - 0、变量 * 1 、变量 / 1】
                转换为布尔类型
                    Boolean（变量）：Boolean（‘true’）
        运算符
            运算符类型
                算术运算符
                    加：+
                    减：-
                    乘：*
                    除：/
                    取余： %
                递增/递减运算符
                    递增运算符
                        前置递增运算符：++a（先自加1，后返回新值）
                            var a = 1；var b = ++a；//b=2（++a=2，a=2）
                        后置递增运算符：a++ （先返回原值，后自加1）
                            var a = 1；var b = a++；//b=1（a++ = 1，a=2）
                    递减运算符
                        前置递减运算符：--a（先自减1，后返回新值）
                            var a = 1；var b = --a；//b=0（--a=0，a=0）
                        后置递减运算符：a-- （先返回原值，后自减1）
                            var a = 1；var b = a--；//b=1（a-- = 1，a=0）
                比较运算符/关系运算符
                    小于：<
                    大于：>
                    小于等于：<=
                    大于等于：>=
                    等于：==
                    不等于：！=
                    全等：===
                    不全等：！==
                逻辑运算符
                    类型
                        逻辑与：&&
                            全真才为真，只要有一个假就是假
                        逻辑或：||
                            全假才为假，只要有一个真就是真
                        逻辑非：！
                    短路运算/逻辑中断
                        逻辑与 && 短路运算（找假）
                            语法：表达式1 && 表达式2 && 表达式3...
                        逻辑或 || 短路运算（找真）
                            语法：表达式1 || 表达式2 || 表达式3...
                赋值运算符
                    直接赋值：=
                        var a=5;
                    加减一个数之后再赋值：+=，-+
                        var a = 2;a+=5;// a = 7;
                        var a = 2;a-=3;//a = -1;
                    乘除取余后再赋值：*=，/=,%=
                        var a = 2;a*=3;//a = 6;
                        var a = 2;a/=2;//a = 1;
                        var a = 4;a%= 3;//a = 1;
            运算符优先级
                一级：小括号（）
                二级：一元运算符 ++ -- ！
                三级：算术运算符 先乘除取余 后加减
                四级：关系运算符 > >= < <=
                五级：相等运算符 == ！= === ！==
                六级：逻辑运算符 先&& 后||
                七级：赋值运算符 =
                八级：逗号运算符 ，
        流程控制
            概念
                流程控制就是来控制我们的代码按照什么顺序来执行
            结构类型
                顺序结构
                    顺序结构是程序中最简单的、最基本的流程控制，他没有特定的语法结构，程序会按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。
                分支结构
                    概念
                        分支结构由上到下执行代码的过程中，根据不同的条件，执行不同的路径代码（执行代码多选一的过程），从而得到不同的结果
                    类型
                        if语句
                            if分支语句
                                if（）{}
                            if else语句（双分支语句）【二选一】
                                if（） {} else {}
                            if else if语句（多分支语句）【多选一】
                                if（） {} else if （） {} else{}
                            三元表达式
                                语法结构
                                    条件表达式 ？表达式1 ：表达式2
                                执行流程
                                    如果条件表达式为真，则返回语句1的值，若为假，则返回表达式2的值。
                        switch语句
                            概念
                                switch语句也是多分支语句，它用于基于不同的条件来执行不同的代码。当要针对变量设置一系列的特定值的选项时，就可以使用switch。
                            语法结构
                                
                            注意
                                我们开发中switch的（）里经常写成变量
                                我们switch（）中的变量和case后面的值相匹配时是全等的，必须数据类型和值都相等，即（）===value
                                break如果当前的case中没有break，则不会退出switch，是继续执行下一个case
                循环结构
                    概念
                        在实际问题中，有许多具有规律性的重复操作，因此在程序中要完成这类操作就要重复执行某些语句。
                    类型
                        for循环
                            结构
                                for（初始化变量；条件表达式；操作表达式）{循环体}
                            应用
                                for循环重复执行相同代码
                                    for（var i = 1；i<=10;i++) {console.log(111)}
                                for循环重复执行不同代码
                                    for(var i = 1;i <= 10; i++) {if(i == 1) {console.log(1) else if (i == 10) {console.log(10)} else {console.log(i)}}
                                for循环重复执行某些相同操作
                                    求1-100之间所有整数和：var sum = 0;for(i=1;i <= 100;i++) {sum+=i} console.log(sum); 
                                双重for循环
                                    if(初始化变量1；条件表达式1；操作表达式1) { for（初始化变量2；条件表达式2；操作表达式12）{ 循环体}}
                                    注意
                                        把里层循环语句当作外层的执行语句即可
                                        外层代码循环1次，里层代码循环执行全部
                                        外层循环控制行数，里层循环控制列数
                                        定义的变量必须有嵌套，即str = str + …
                        while循环
                            概念
                                while语句可以在条件表达式为真的前提下，循环执行指定的一段代码，直到表达式不为真时结束循环
                            结构
                                while（表达式）{循环体}
                            例子
                                
                            do...while循环
                                概念
                                    do...while语句其实是while语句的一个变体，先执行一次代码之后判断while中的语句是否正确，若为假，退出循环，若为真，继续循环，也就是至少会执行一次循环体
                                结构
                                    do {循环体}while（表达式）
                    continue与break
                        continue用于跳出本次循环,继续下一次循环，执行i++
                            
                        break用于跳出整个循环，循环结束
                            子主题 1
        常用的内置对象
            Math
                概念
                    Math对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用Math中的成员。
                使用
                    属性
                        Math.PI
                            圆周率，一个圆的周长和直径之比，约等于 3.14159
                    方法
                        向上取整
                            Math.ceil()
                                Math.ceil(2.1)  // 3    Math.ceil(-2.7) // -2
                        向下取整
                            Math.floor()
                                Math.floor(2.8) // 2  Math.floor(-2.1) // -3
                        四舍五入
                            Math.round()
                                Math.round(3.5) // 4  Math.round(-3.5) // -3(遇到5往大了取)
                        最大值
                            Math.max()
                                Math.max(1,21,99,0.4) // 99
                        最小值
                            Math.min()
                                Math.min(1,21,99,0.4) // 0.4
                        绝对值
                            Math.abs()
                                Math.abs(-2.5) // 2.5
                        随机数
                            Math.random()
                                生成【0，1）浮点数
                                    常用：得到一个两数之间的随机整数，包括两个数在内
                                        function getRandomIntInclusive(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min; //含最大值，含最小值 
    }
            Date
                参数
                    无参数
                        var today = new Date( ) // 返回今日（格式：Wed Mar 30 2022 08:55:46 GMT+0800 (中国标准时间)）
                    有参数
                        数字型
                            var date = new Date(2022,3,30) // 返回：Sat Apr 30 2022 00:00:00 GMT+0800 (中国标准时间) 【注意：此处返回的月份比括号内的大1，因为月份是从0开始的，星期不准】
                        字符串型
                            var date = new Date('2022-3-30 8:8:8') // 返回Wed Mar 30 2022 08:08:08 GMT+0800 (中国标准时间)
                格式化日期
                    获取当年
                        日期.getFullYear( )
                    获取当月
                        日期.getMonth( )
                            注意：月份是从0-11，所以获取当月要在后面+1
                    获取当日
                        日期.getDate( )
                    获取星期
                        日期.getDay( )
                            注意：星期日为0，周一到周六为1-6
                    获取小时
                        日期.getHours( )
                    获取分钟
                        日期.getMinutes( )
                    获取秒
                        日期.getSeconds( )
                    把总的秒数折算成天/小时/分钟/秒
                        d=parseInt（总的秒数/60/60/24) 计算天数
                        h=parseInt（总的秒数/60/60%24) 计算小时
                        m=parseInt（总的秒数/60%60）计算分钟
                        s=parseInt（总的秒数%60） 计算秒数
                获取总的毫秒数
                    常规写法
                        var date = new Date( );                                             date.valueOf( );或者date.getTime( )
                    简易写法
                        +new Date( );
                    H5新增写法
                        Date.now( )
            String
                根据字符返回位置
                    字符串.indexOf('字符'，开始的位置)---从前往后找
                        若没有返回-1，若有返回索引号
                    字符串.indexOf('字符')---从后往前找
                        若没有返回-1，若有返回索引号
                根据位置返回字符
                    字符串名字.charAt(index)
                        返回指定位置的字符（index 字符串的索引号）
                    字符串名字.charCodeAt(index)
                        获取指定位置处字符的ASCII码（index索引号）（判断用户按了哪个键）
                    字符串名字[index]
                        获取指定位置处字符
                字符串操作方法
                    拼接字符串：字符串名称.concat（字符串名称，...）
                        concat()方法用于连接两个或多个字符串，拼接字符串，等效于+，+更常用
                    截取字符串：字符串名称.substr（start,length）
                        从start位置开始（索引号），length取的个数
                    替换字符串：字符串名称.replace（‘被替换的字符’，‘替换为的字符’）
                        若被替换的有多个，只会替换最前面的一个
                    字符串转换为数组：字符串名称.split（‘分隔符’）
                        此分割符需与字符串里面的字符与字符之间的一致才能分割成几个数组元素

            Array
                数组创建方式
                    利用new创建
                        var arr = new Array( );
                            空数组
                        var arr = new Array(2 );
                            括号内只有一个数，表示数组长度，且每个元素都是空属性
                        var arr = new Array(2，3 );
                            括号内数字个数大于1，表示数组元素，即[2,3]
                    利用字面量创建
                        var arr = [1，2，3 ]；
                检测数组方式
                    Object.prototype.toString.call(数组名)
                        若是数组返回[object Array]；
                    通过ES6的Array.isArray(数组名)
                        返回布尔值
                    通过 数组名 instanceof Array
                        返回布尔值
                    通过原型链
                        数组名.__proto__ === Array.prototype;
                            返回布尔值
                    Array.prototype.isPrototypeOf（数组名）
                        返回布尔值
                数组元素更改
                    添加/删除开头/结尾数组元素
                        末尾添加
                            数组名.push(1,2,3)---数组末尾添加元素1，2，3【改变原数组并返回新的长度】
                        开头添加
                            数组名.unshift(1,2,3)---数组开头添加元素1，2，3【改变原数组并返回新的长度】
                        末尾删除
                            数组名.pop( )---无参数，删除最后一个元素【改变原数组并返回删除的值】
                        开头删除
                            数组名.shift（）---无参数，删除第一个元素【改变原数组并返回删除的值】
                    删除或替换现有元素或者原地添加新的元素来修改数组
                        数组名. splice(start[, deleteCount[, item1[, item2[, ...]]]])
                            返回被删除的元素的数组。此方法会改变原数组。
                排序数组元素
                    颠倒原数组
                        数组名.reverse( )--无参数，改变原数组并返回新数组
                    排序原数组
                        升序排序
                            arr.sort(function(a,b) {return a-b}) -- 改变原数组并返回新数组
                        降序排序
                            arr.sort(function(a,b) {return b-a})-- 改变原数组并返回新数组
                数组元素片段浅拷贝
                    数组名.slice([begin[, end]])
                        slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。
                数组转换为字符串
                    数组名.toString( )--逗号连接每一项
                    数组名.join（‘分隔符’） --分隔符连接每一项
                数组拼接
                    数组.concat（arr1，arr2，arr3…）
                    ES6新增：[...arr1,arr2]
                数组索引方法
                    数组名.indexOf(元素，开始的位置)--从前往后找的第一个
                        若找不到返回-1，找到了返回索引值
                    数组名.lastIndexOf(元素)--从后往前找的第一个
                        若找不到返回-1，找到了返回索引值
                数组常用方法
                    forEach
                        forEach() 方法对数组的每个元素执行一次给定的函数。
                            arr.forEach(callback(currentValue [, index [, array]])[, thisArg])
                    filter
                        filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。
                            var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])
                    map
                        map() 方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。
                            var new_array = arr.map(function callback(currentValue[, index[, array]]) {
    // Return element for new_array 
    }[, thisArg])
                    every
                        every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。
                            arr.every(callback(element[, index[, array]])[, thisArg])
                    some
                        some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。
                            arr.some(callback(element[, index[, array]])[, thisArg])
                    reduce
                        reduce() 方法对数组中的每个元素按序执行一个由您提供的 reducer 函数，每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。
                            求数组所有值的和：let total = [ 0, 1, 2, 3 ].reduce(
    ( previousValue, currentValue ) => previousValue + currentValue,
    0
    )
        作用域
            作用域
                全局作用域
                    整个script标签 或者是一个单独的JS文件
                局部作用域/函数作用域
                    在函数内部就是局部作用域，这个代码的名字只在函数内部起效果和作用。
            变量作用域
                全局变量
                    在全局作用域下的变量，在全局下都可以使用。
    注：如果在函数内部，没有声明直接赋值的变量也属于全局变量。
                局部变量
                    在局部作用域（函数内部）下的变量，只能在函数内部使用。
    注：函数的形参也可以看作是局部变量。
            作用域链（就近原则）
                内部函数访问外部函数的变量，采取的是链式查找的方式来决定取哪个值，这种结构称为作用域链。
        预解析
            变量预解析
                就是把所有的声明变量提升到当前作用域最前面，不提升赋值操作。
            函数预解析
                就是把所有的函数声明提升到当前作用域的最前面，不调用函数。
        this指向
            this指向分类
                普通函数
                    window
                构造函数
                    实例对象，原型对象里面的方法也指向实例对象
                对象方法
                    该方法所属对象
                        注：若对象中的方法为普通函数写法吗，则this指向该方法所属对象，若为箭头函数，则this指向为window
                事件绑定函数
                    绑定事件对象
                定时器
                    window
                立即执行函数
                    window
                箭头函数
                    外层作用域中的this（且this指向不可改变）
            改变函数内部this指向
                函数名称.call（this要指向的，传递的参数1，...）
                    
                函数名.apply（this要指向的，[传递的参数1，...]）
                    利用apply传递数组（伪数组），借助数学内置对象求数组最大值/最小值
                函数名.bind（this要指向的，传递的参数1，...）
                    
        ES6
            声明变量
                let关键字
                    不允许重复声明
                    块级作用域
                    不存在变量提升
                    不影响作用域链
                const关键字
                    声明必须赋初始值
                    不允许重复声明
                    值不允许被修改，修改后会报错（对于数组和对象的元素修改，不算对常量的修改，只要不改变地址就可以，不会报错）
                    块级作用域
            变量的解构赋值
                ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称 为解构赋值。
                    
                    
            模板字符串``
                字符串中可以出现换行符
                可以使用 ${xxx} 形式输出变量
            简化对象写法
                ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这 样的书写更加简洁。
                    对象中函数简写
                        
                    对象中直接引用属性和方法
                        
            箭头函数
                箭头函数定义及调用
                    
                箭头函数特点
                    如果形参只有一个，则小括号可以省略
                    函数体如果只有一条语句，则花括号可以省略，函数的返回值为该条语句的 执行结果，若有return，return必须省略
                    箭头函数的this是静态的，箭头函数 this 指向声明时所在作用域下 this 的值，且无法改变。箭头函数的this不指向本身，指向外层作用域中的this
                    箭头函数不能作为构造函数实例化
                    不能使用 arguments（使用了会报错，没有arguments）
                箭头函数应用
                    箭头函数适合与this无关的回调，比如定时器、数组的方法回调，不适合与this有关的回调，事件回调，对象的方法。
            函数形参默认值
                形参赋初始值
                    
                与解构赋值结合
                    
            rest参数
                ES6 引入 rest 参数，用于获取函数的实参，用来代替 arguments 。与arguments不同的是，arguments返回的是一个对象，而rest函数返回的是一个数组，便于我们使用forEach（）、filter（）、map（）、some（）、every（）去操作数组。
                注意：rest函数必须放在参数最后，否则会报错
                    
            spread扩展运算符
                概念
                    扩展运算符（spread）也是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列，对数组进行解包。
                应用
                    数组的合并
                        
                    数组的克隆
                        
            Set：集合【去重】（类似数组）
                概念
                    ES6 提供了新的数据结构 Set（集合）(是一个对象类型）。它类似于数组，但成员的值都是唯一的，集合实现了 iterator 接口，所以可以使用『扩展运算符』(…)和『for…of…』进 行遍历
                集合的属性和方法
                    size：返回集合的元素个数
                    add增加一个新元素，返回当前集合（一次只能加一个）
                    delete删除一个元素，返回Boolean值
                    has 检测集合中是否包含某个元素，返回 boolean 值
                    clear 清空集合，返回 undefined
                    
            Map（类似于对象）
                概念
                    ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合。但是“键” 的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map 也实现了 iterator 接口，所以可以使用『扩展运算符』和『for…of…』进行遍历。若给map赋初始值，可以以数组形式，数组里面的也都为数组形式：const m = new Map([array(2),array(2)]);这样形成一个对象中包含两对键值对，第一个数组中前一个为键名，后一个为键值，第二个数组同理。
                Map的属性和方法
                    size 返回 Map 的元素个数（键值对个数）
                    set 增加一个新元素，返回当前 Map
                    delete 删除键值对，返回boolean 值
                    get 返回键名对象的键值
                    has 检测 Map 中是否包含某个元素，返回 boolean 值
                    clear 清空集合，返回 undefined
                    
            Promise
                Promise 是 ES6 引入的异步编程的新解决方案。语法上 Promise 是一个构造函数， 用来封装异步操作并可以获取其成功或失败的结果。
                    构造Promise
                        new Promise（（resolve，reject） => { resolve('成功‘）  或者 reject（’失败‘）}）
                    方法
                        promise名称.then( )
                            Promise名称.then(（value） => {console.log(value),(reason) => {console.log(reason)})     [成功和失败的回调]
                        promise名称.catch( )
                            promise名称.catch（reason => {console.log(reason)}）[失败的回调]
                        Promise.allSettled([p1,p2,...])
                            p1,p2...都是promise，不管p1、p2...是成功的还是失败的，promise.allSettled都是成功
                        Promise.all([p1,p2,...])
                            p1,p2...都是promise，p1、p2...全部成功promise.allSettled才是成功，只要有一个失败，Promise.all（[p1,p2,...]）就是失败的
            async await
                async 和 await 两种语法结合可以让异步代码像同步代码一样
                    await
                        await 必须写在 async 函数中 
                        await 右侧的表达式一般为 promise 对象
                        await + 表达式返回的是 promise 成功的值
                        await 的 promise 失败了, 就会抛出异常, 需要通过 try...catch 捕获处理
            可选链操作符
                可选链操作符( ?. )允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。?. 操作符的功能类似于 . 链式操作符，不同之处在于，在引用为空(nullish ) (null 或者 undefined) 的情况下不会引起错误，该表达式短路返回值是 undefined。与函数调用一起使用时，如果给定的函数不存在，则返回 undefined。
                    
        构造函数
            构造函数：提取对象共有的属性和方法，通过new实例化创建对象
                构造函数的创建
                    创建构造函数
                        
                            添加成员方式（添加构造函数的属性和方法的方式）
                                通过构造函数.prototype方式添加【Star.prototype.sing=...】
                                    只有实例成员可以访问得到
                                        
                                在构造函数内部添加：实例成员
                                    只有实例成员可以访问得到
                                        
                                在Star身上添加：静态成员
                                    只有构造函数可以访问得到
                                        
                    创建对象
                        
                        new的作用
                            在内存中创建一个新的内存空间
                            让this指向这个新对象
                            执行构造函数里面的代码，给这个新对象添加属性和方法
                            返回新对象（所以构造函数不需要return）
                原型
                    构造函数的原型：prototype【原型对象】
                        每一个构造函数都有一个原型对象prototype，prototype也是对象，所以叫原型对象；prototype里面有构造函数挂载到prototype上的公有方法，还有一个constructor（用于指回该构造函数）；这个prototype原型对象指向另一个原型对象（Object原型对象prototype）【因为只要是对象就有__proto__,而__proto__都指向某个prototype】
                            prototype内部构造
                                通过构造函数挂载到prototype上的公有方法
                                    
                                constructor：用于指回该构造函数
                                    constructor：Star
                            原型链
                                
                        原型对象prototype中的this指向
                            指向实例对象（谁调用指向谁）
                                
                    实例对象的原型：__proto__【对象原型】
                构造函数、实例对象、原型（构造函数原型、实例对象原型）联系
                    
                JS成员查找规则
                    当访问一个对象的属性或方法时，先在该实例对象身上查找（即构造函数身上）
                    若没有再查找它的原型对象prototype
                    若没有查找原型对象的原型对象（Object的原型对象）【通过该原型对象的__proto__】
                    若都有，则采取就近原则选择
        面向对象
            在ES6中新增加了类的概念，可以使用class类抽取了对象的公共部分，它泛指某一大类（模板），对象特指某一个，通过类实例化一个具体的对象
                创建类
                    语法
                        class name {
        constructor（uname）{
        this.uname = uname;
        }
        sing（） {
        console.log('i am' + this.uname)
        }
    }

                    创建实例
                        var xx = new name(‘cara’);
                类的构造
                    类constructor构造函数（属性）
                        constructor（）方法是类的构造函数（默认方法），用于传递参数，返回实例对象，通过new生成实例对象后自动调用该方法，如果没有显示定义，类内部会自动创建constructor
                            
                    方法
                        普通函数方法
                            class name {
        constructor（uname）{
        this.uname = uname;
        }
        sing（） {
        console.log('Hi‘)
        }
    }

                            或者class name {
        constructor（uname）{
        this.uname = uname;
        }
        sing（） {
        return 123
        }
    }

                        构造函数方法
                            class name {
        constructor（uname）{
        this.uname = uname;
        }
        sing（） {
        console.log('i am' + this.uname)
        }
    }

                类的继承
                    语法
                        
                    super关键字
                        在调用构造函数方法时，super可以充当传递参数的角色，要在子类的constructor中写，而且super必须放到子类this前面；当调用普通函数时，可以直接在子级的方法中（不要写在constructor里面）用super.父亲方法（）来调用【super必须与extends搭配使用】super无需考虑父级中this的指向，而ES5中的调用父亲的构造函数方法需要考虑父级中this指向问题，需要用call等方法修改this指向后才能调用构造函数方法：Father.call(this[修改后的this指向，在子级中写一般是this（也就是子级自己）]，参数1，...）
                            调用父亲的构造函数
                                
                            调用父亲的普通函数
                                
                构造函数实例化对象与类实例化对象对比（ES5与ES6对比）
                    创建对象
                        ES5
                            
                        ES6
                    继承
                        ES5
                            
                        ES6
                            
                类的注意点
                    在ES6中类没有变量提升，所以必须先定义类，才能通过实例化对象
                    this指向问题：constructor里面的this指向实例对象，方法里的this指向这个方法的调用者
                    类里面的共有属性和构造函数方法（普通函数方法不需要）一定要加this使用。
                    super要搭配extends一起用，super要写到子类的constructor中，而且必须放到子类this前面
                    继承中的属性或者方法查找原则：				就近原则。继承中，如果实例化子类输出一个方法，先看子类中有没有这个方法，如果有就先执行子类的；若没有，就去父类中查找，如果有就执行这个方法
        闭包
            闭包的产生条件
                高阶函数
                    高阶函数是对其它函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。
                        接收函数作为参数
                        将函数作为返回值输出
                            有可能产生闭包
            闭包的概念
                闭包指有权访问另一个函数作用域中变量的函数。简单理解就是一个作用域可以访问另一个函数内部的局部变量。
                    
            闭包的作用
                延伸了变量的作用范围
                    
        递归
            概念
                如果一个函数在内部可以调用其本身，那么这个函数就是递归函数；简单理解：函数内部自己调用自己，这个函数就是递归函数。递归函数的作用和循环效果一样，由于递归很容易出现“栈溢出”错误，所以必须要加退出条件return。
                    
            应用
                利用递归求数学题
                    求阶乘
                    求和
                利用递归求：根据id返回对应的数据对象
                    
                        
        深拷贝、浅拷贝
            深拷贝：拷贝数据
            浅拷贝：拷贝地址
                浅拷贝的方式
                    obj1=obj2
                    
                    
        模块化
            引入：require、引出：exports、module.exports
                引出：exports与module.exports
                    exports.fn = function( ) {...} / module.exports = {fn( ) {...},a:25}
                        在一个node执行一个文件时，会给这个文件内生成一个 exports和module对象，而module又有一个exports属性。他们之间的关系如下图，都指向一块{}内存区域。
                            
                                其实require导出的内容是module.exports的指向的内存块内容，并不是exports的。简而言之，区分他们之间的区别就是 exports 只是 module.exports的引用，辅助后者添加内容用的。也就是用exports.a = 13来向module.exports = { }中添加了一个a属性，值为13，用require引入的时候引入的其实就是module.exports中的内容，为了避免糊涂，尽量都用 module.exports 导出，然后用require导入
                引入：const a = require（’../utils')       a.foo( )
                    注意：引入的是module.exports里面的内容，exports只是辅助module.exports添加内容的
            引入：import、引出：export、export default
                引出：export、export default
                    export const fn = function( ) {...}                                              或者const fn =function( ) {...}         export {fn,...}
                    export default {fn( ) {...},a:25}
                引入：import
                    用export引出的时候，引入方式
                        统一引入：import * as mi1 from '../utils'    m1.fn1( )
                        解构赋值import {fn1，fn2} from '../utils'     fn1(  )
                    用export default 引出的时候，引入方式
                        import m1 from '../utils'   m1.fn1( )
            注意
                require原本是在node.js中的引入，他只识别commonjs的语法规范的模块，而exports与module.exports就是commonjs的引出
                import是在浏览器中的引入，他只识别符合es6的语法规范，而export与export default就是符合es6的语法规范的导出
            在浏览器中可以使用require导入export和export default的模块是因为Babel或者webpack将符合es6规范的export和export default转化为require可以识别的commonjs语法，所以require既可以导入exports、module.exports的模块，也可以导入export和export default的模块，只不过在node环境中无法识别es6中的export和export default的模块
        JS执行机制
            JS是单线程，也就是说，同一时间只能做一件事。
                同步（按顺序来）
                    同步任务：同步任务都在主流程上执行，形成一个执行栈。
                异步（同时进行）
                    异步任务：JS的异步是通过回调函数实现的。异步任务相关回调函数添加到任务队列中（任务队列也称消息队列）。一般而言，异步任务有三种类型：
                        普通事件，如click、resize等
                        资源加载，如load、error等
                        定时器，包括setTimeout、setInterval等。
            JS执行机制--Event Loop
                先执行执行栈中的同步任务；
                异步任务（回调函数）放入任务队列中；
                一旦执行栈中的所有同步任务执行完毕，系统会按次序取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。
                
                

# 网页特效
## pc端三大系列
    元素偏移量offset系列
        概述
            获得元素距离带有定位的父元素的位置
            获得元素自身的大小（宽度和高度）
            注意：返回的数值都不带单位
        offset常用属性
            元素名.offsetParent
                返回作为该元素带有定位的父级元素 若父级都没有定位则返回body
            元素名.offsetTop
                返回元素相对带有定位父元素上方的偏移
            元素名.offsetLeft
                返回元素相对带有定位父元素左边框的偏移
            元素名.offsetWidth
                返回自身包括padding、边框、内容区的宽度，返回数值不带单位
            元素名.offsetHeight
                返回自身包括padding、边框、内容区的高度，返回数值不带单位
        offset与style区别
                
    元素可视区client系列
        概述
            client就是客户端，我们使用client系列的相关属性来获取元素可视区得相关信息。通过client系列的相关属性可以动态的得到该元素的边框大小、元素大小等。
        client属性
            元素名.clientTop
                返回元素上边框的大小
            元素名.clientLeft
                返回元素左边框的大小
            元素名.clientWidth
                返回自身包括padding、内容区的宽度，不含边框，返回数值不带单位
            元素名.clientHeight
                返回自身包括padding、内容区的高度，不含边框，返回数值不带单位
    元素滚动scroll系列
        概述
            scroll翻译过来就是滚动的，我们使用scroll系列的相关属性可以动态的得到该元素的大小、滚动距离等。
        scroll属性
            元素名.scrollTop
                返回元素被卷去的上侧距离，返回数值不带单位
            元素名.scrollLeft
                返回元素被卷去的左侧距离，返回数值不带单位
            元素名.scrollWidth
                返回自身实际的宽度，包括padding，不含边框，返回数值不带单位
            元素名.scrollHeight
                返回自身实际的高度，包括padding，不含边框，返回数值不带单位
        
    注意
        滚动窗口到文档中的特定位置：window.scroll（x，y），这里的x和y不加单位，且是瞬间移动，若想缓慢移动可以添加动画。

    三大系列总结
        主要用法
            offset系列经常用于获得元素位置 offsetTop、offsetLeft
            client经常用于获取元素大小 clientWidth、clientHeight（包含自身宽度/高度，padding，但是不包含边框，没有单位）
            scroll经常用于获取滚动距离 scrollTop、scrollLeft，注意页面滚动的距离通过window.pageXoffset获得

## 移动端
    触屏事件
            touchstar
                手指触摸到一个DOM元素时触发
            touchmove
                手指在一个DOM元素上滑动时触发
            touchend
                手指从一个DOM元素上移开时触发
    触屏事件对象
        概述
            TouchEvent是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件。这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少等等。touchstart、touchmove、touchend三个事件都有各自的事件对象。
        touchstart事件对象
            touches
                正在触摸屏幕的所有手指的一个列表
            targetTouches
                正在触摸当前元素上的手指的一个列表
            changedTouches
                手指状态发生改变的列表，从无到有，从有到无
        注意
            如果侦听的是一个元素，那么touches和targetTouches是一样的，手指离开无
            changedTouches，手指状态发生改变的列表，从无到有，从有到无，手指离开有
            因为我们一般都是触摸元素，所以在实际开发中最常用的是targetTouches
    应用
        移动端拖动元素
            
# Css知识点
## 1.CSS基础
### CSS选择器
    作用：根据不同需求把不同的标签选出来
    分类
        基础选择器
            标签选择器/元素选择器
            类选择器
            id选择器
            通配符选择器
        复合选择器
            后代选择器：中间用空格隔开
            子代选择器：中间用>隔开
            并集选择器：中间用逗号隔开
            伪类选择器
                链接伪类选择器
                    a：link 选择所有未被选择的链接
                    a: visited 选择所有访问过的链接
                    a: hover 选择鼠标指针位于其上的链接
                    a：active 选择活动链接，鼠标按下未弹起
                focus伪类选择器
                    ：focus 聚焦表单伪类选择器
        新增选择器
            属性选择器
                E[attr]：选择有attr属性的E元素
                E[attr=”val“]：选择有attr属性且attr属性值为”val“的E元素
                E[attr^=”val“]：选择有attr属性且attr属性值为”val“开头的的E元素
                E[attr$=”val“]：选择有attr属性且attr属性值为”val“开头结尾的的E元素
                E[attr*=”val“]：选择有attr属性且attr属性值含有”val“的的E元素
            结构伪类选择器
                child
                    E：first-child 第一个子元素E
                    E：last-child 最后一个子元素E
                    E：nth-child（n） 第n个子元素E
                type
                    E：first-of-type 指定类型的第一个E元素
                    E：last-of-type 指定类型的最后一个E元素
                    E：nth-of-type（n) 指定类型的第n个E元素
            伪元素选择器
                ::before
                ::after
    选择器优先级（权重）
        继承或通配符（*）---0
        标签选择器、伪元素选择器---1
        类选择器、属性选择器、结构伪类选择器---10
        id选择器---100
        行内样式---1000
        ！important---无穷大
### CSS属性
    字体属性
        font family：字体系列（多个字体样式用逗号隔开）
        font size（默认16px）
        font weight （bold/700、normal/400）
        font style （normal、italic）
    文本属性
        color：颜色
            颜色值：red
            十六进制：#fff
            RGB值：rgb（255，0，0）
        text-align：水平对齐方式
            left
            center
            right
        line-height：垂直对齐方式
            16px等
        text-decoration
            none：无
            underline：下划线
            overline：上划线
            line-through：删除线
        text-indent：缩进
            10px
            2em
    背景属性
        background-color：背景颜色
        background-image：url（image.png）
        background-repeat：背景平铺
            repeat：在x轴、y轴均平铺
            no-repeat：不平铺
            repeat-x：在x轴平铺
            repeat-y：在y轴平铺
        background-attachment：背景固着
            scroll：滚动
            fixed：固定
        background-position：背景位置
            length
            position
### CSS三大特性
    层叠行：解决样式冲突问题
        就近原则：离结构近以谁为准；样式不冲突，不会层叠
    继承性
        继承父元素color、text、font、行高
    优先级
        继承与通配符权重为0；标签选择器、伪元素选择器权重为1，类选择器、属性选择器、结构伪类选择器权重为10、id选择器权重为100，行内样式权重为1000，！important权重为无穷大，复合选择器权重需要叠加计算

## CSS高级技巧
    精灵图
    字体图标
    用户界面样式
        cursor
            default：默认
            pointer：小手
            text：文本
            move：移动
            not-allowed：禁止
        表单input样式
            outline：none（清除聚焦蓝色边框）
    vertical-align
        baseline：父元素基准线上
        top：与行内最高元素顶端对齐
        middle：父元素中间部分
        bottom：与行内最低元素的底部对齐
    溢出文字隐藏并显示省略号
        单行
            white-space：nowrap；overflow：hidden；text-overflow：ellipsis
        多行
            overflow：hidden；text-overflow：ellipsis；display：-we'bkit-box；-webkit-line-clamp：2；-webkit-box-orient：vertical；

## CSS新特性
    新增选择器
        属性选择器
        结构伪类选择器
        伪元素选择器
    2D转换：transform
        移动：translate
            写法
                translate（10px，10px）
                translateX（10px）
                translateY（10px）
            特点
                不会影响其他元素的位置
                translate（50%，50%）是针对元素自身进行平移
                对行内元素无效
        缩放：scale
            写法
                scale（2，2）：宽和高都放大为原来的2倍
                scale（0.5）：宽和高都缩小为原来的一半
            特点
                可以设置转换中心缩放，默认以中心点缩放的，而且不影响其他盒子，若要改变中心点转换可以用transform-origin设置（这个要写到改变的元素身上，而不写到hover中）
                transform-origin： 10px 10px 或者transform-origin： center bottom 或者transform-origin： 50% 50%（自身元素、默认值）
        旋转：rotate
            写法
                rotate（45deg）：顺时针旋转45度
                rotate（-45deg）：逆时针旋转45度
            特点
                可以设置转换中心旋转，默认以中心点旋转的，而且不影响其他盒子，若要改变中心点转换可以用transform-origin设置（这个要写到改变的元素身上，而不写到hover中）
                transform-origin： 10px 10px 或者transform-origin： center bottom 或者transform-origin： 50% 50%（自身元素、默认值）
    3D转换
        位移：translate
            写法
                translate3d（x，y，z）都不可以省略，可以写0
                translateX（100px）：向右平移100px
                translateY（-100px）：向上平移100px
                translateZ（100px）：向前平移100px
        旋转：rotate
            写法
                rotate3d（x，y，z，deg）
                rotateX（45deg）：沿着x轴向里旋转45度
                rotateY（-45deg）：沿着y轴向外旋转45度
                rotateZ（45deg）：沿着z轴顺时针旋转45度
        3D呈现：transform-style
            flat：子元素不开启3d空间
            preserve-3d：子元素开启3d空间
        透视：perspective（单位px）
            人的眼睛到屏幕的距离；近大远小。
        注意
            x轴右方为正方向
            y轴下方为正方向
            z轴前方为正方向
## 动画
    动画的基本使用
        css中用@keyframes定义动画
            @keyframes 动画名称 {0% {width：100px} 100% {width：200px}}
        在元素身上使用动画
            简写--animation：mine（动画名称） 2s（持续时间） linear（运动方式） 1s（延迟时间） infinite（运动次数） alternate（运动结束是否改变方向） backwords（运动结束回到起始位置还是留在原位）【前两个必须写】
    动画序列
        0%、100%/from、to
    动画常用属性
        @keyframes：规定动画
        animation：动画简写属性名称 其中不包含animation-play-state
        animation-name：动画名称
        animation-duration：动画持续时间
        animation-timing-function：动画运动速度曲线
            ease：开始结束慢，中间快（默认）
            linear：匀速
            ease-in：慢速进入
            ease-out：慢速离开
            ease-in-out：低俗开始和结束
            steps（）：指定了时间函数中的间隔数量（步长）
        animation-delay：延迟开始时间
        animation-iteration-count：动画次数：默认是1  infinite （无限次）
        animation-direction：动画下一次开始的方向：normal（从头开始） alternate（逆播放）
        animation-fill-mode：动画结束停留位置：forwards（原始位置） backwards（当前位置）
        animation-play-state：动画运动状态 running（运动） paused（暂停） 经常与hover一起使用
盒子模型：box-sizing
    content-box
        盒子的宽度和高度包含padding、border
    border-box
        盒子的宽度和高度不包含padding和border
CSS过渡：transition
    transition：all（要过渡的属性） 2s（过渡时间） linear（速度方式） 1s（开始延迟时间）
    注意：谁过渡给谁加
其他特性
    背景渐变
        pc端
            background：linear-gradient（起始方向，颜色1，颜色2，。。。）
        移动端
            background：-webkit-linear-gradient（left top，red，pink）
    图片模糊
        filter：blur（5px）数值越大越模糊
    calc函数
        width：calc（100% - 80px）
        注意：括号里面可以使用+ - * /来进行计算。注：+ - * / 前后都要有一个空格才行。
    圆角：border-radius
    文字特效 （text-shadow）
    文字渲染 （Text-decoration）

4.元素类型转换及显示/隐藏
元素类型转换
    类型
        块级元素
        行内元素
        行内块元素
    转换 -- display
        转换为块级元素--display：block
        转换为行内元素--display： inline
        转换为行内块元素--display：inline-block
元素的显示与隐藏
    display：隐藏后不再占有原来的位置
        display：none 隐藏
        display：block 显示
    visibility：隐藏后继续占有原来的位置
        visibility：hidden 隐藏
        visibility：visible 显示
    overflow：超出部分可以设置显示与隐藏
        overflow：visible 不剪切内容也不添加滚动条
        overflow：hidden 隐藏超出部分
        overflow：scroll 不管是否超出，都显示滚动条
        overflow：auto 超出部分自动显示滚动条，不超出不显示滚动条

## PC端布局
布局基础
    盒子模型
        内容：content
        内边距：padding
        边框：border
            border-width：边框粗细：单位px
            border-style：边框样式：solid（实线）、dashed（虚线）、dotted（点线）
            border-color：边框颜色
        外边距：margin
            相邻元素外边距合并：上面的盒子给margin-bottom：10px；下面的盒子margin-top：5px；两个盒子之间的距离不等于15px，而是等于10px
            嵌套块元素垂直外边距的塌陷：父亲mergin-top：10px；里面的儿子margin-top：5px；结果是儿子与父亲没有margin，而父亲的margin-top取大值
            脱标的盒子不会存在外边距合并的问题
布局核心
    简单流/标准流
        简单流/标准流就是标签按照规定好默认方式排列。
            块级元素独占一行
            行内元素多个占一行，超过部分另起一行
    浮动：float
        浮动可以让多个块级盒子一行没有缝隙排列显示，经常用于横向排列盒子。
            语法
                左浮动：float：left;
                右浮动：float:right;
            浮动特性
                浮动的元素会脱离标准流（脱标）【不再保留原来的位置】
                浮动元素一行内显示（不会有缝隙，若一行装不下，另起一行），并且顶部对齐
                浮动盒子具有行内块元素特性：任何元素都可以浮动，不管原先是什么模式的元素，添加浮动之后具有行内块元素相似的特性。如果块级元素没有设置宽度高度，设置宽度之后，会根据内容决定；一行显示，没有缝隙；可以设置宽度和高度
            浮动注意点
                一般来说一个盒子浮动了，其他的兄弟盒子也要浮动
                浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流
            清除浮动
                为什么要清除浮动
                    由于父级盒子很多情况下，不方便给高度，但是盒子浮动又不占有位置，最后父级盒子高度为0时，就会影响下面的标准流盒子。
                清除浮动的本质
                    清除浮动的本质是清除浮动元素造成的影响
                    如果父盒子有高度，则不需要清除浮动
                    清除浮动之后，父盒子会根据浮动的儿子来自动检测高度，从而不会影响后面的标准流
                    语法
                        clear：left；
                        clear：right；
                        clear：both；
                清除浮动的方法
                    额外标签法：在浮动元素后面添加一个块级标签
                        行内样式：<div style="clear: both"></div>
                        类选择器方法：<style>
                .clear {
                    clear: both;
                    }
            </style>
            <div class=”clear“></div>
                    父级添加overflow属性（父元素添加）
                        overflow：hidden
                        overflow：scroll
                        overflow：auto
                    父级添加：after伪元素（父元素添加）
                        结构：  <div class="box clearfix">
    <div class="damao">damao</div>
    <div class="ermao">ermao</div>
    </div>
                        样式：
                    父元素添加双伪元素
                        结构：  <div class="box clearfix">
    <div class="damao">damao</div>
    <div class="ermao">ermao</div>
    </div>
                        样式
    定位：position
            定位是让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子。

            定位模式
                static：静态定位【不脱标，不使用边偏移】
                    静态定位按照标准流特性摆放位置，没有边偏移。
                relative：相对定位【不脱标，相对自身位置边偏移】
                    相对自己原来的位置进行边偏移
                    不脱标，原来的位置继续保留，主要作用是用来限制子元素的绝对定位
                absolute：绝对定位【脱标，相对于有定位的父亲边偏移】
                    如果没有祖先元素或者祖先元素没有定位，则边偏移是相对浏览器可视区为准
                    如果祖先有定位，则以最近有定位的祖先为准边偏移
                    不再占有原来的位置，脱标
                    注：加了绝对定位的盒子不能通过margin：0 auto来设置水平居中对齐
                fixed：固定定位【脱标，浏览器可视区边偏移】
                    固定定位是一种特殊的绝对定位
                    固定定位必须有宽度
                    边偏移相对于浏览器可视区为准，与父元素没有关系，不会随着页面的滚动而消失
                sticky：粘性定位【不脱标，浏览器可视区】
                    语法：position：sticky；top：10px；（滚到距离顶部10px，固定住）
                    不脱标，保留位置
                    边偏移相对于浏览器为准，与父亲没有关系
                    必须添加top、left、right、bottom其中一个才有效
            边偏移
                top：距离父元素上方距离
                bottom：距离父元素下方距离
                left：距离父元素左侧距离
                right：距离父元素右侧距离

## 移动端基础
    视口：浏览器显示页面内容的屏幕区域
        布局视口：layout viewport【网页的宽度】
        视觉视口：visual viewport【视觉视口是指用户正在看到的网站的区域】（这个区域的宽度等同于移动设备的浏览器窗口的宽度）
        理想视口：ideal viewport【使布局视口的大小和屏幕宽度是一致的】
            为了实现理想视口，需要手动去添加meta视口标签通知浏览器操作
            <meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0 user-scalable=no">
                width：布局视口宽度，可以设置device-width特殊值
                initial-scale：初始缩放比，一般为1.0
                maximum-scale：最大缩放比，一般为1.0
                minimum-scale：最小缩放比，一般为1.0
                user-scalable：是否允许用户进行缩放，一般为no
    二倍图
        将一张50px*50px的图片放到移动端会放大二倍（或者3bei等），此时移动端的照片会变得不清晰，解决方案就是如果想在移动端放一张100px*100px的图片，我们可以准备一个100px*100px的图片，然后将他缩小至50px*50px，这样即使在移动端放大也不会变模糊
            图片（原始图片：100px*100px）
                img{width：50px；height：50px；}
            背景图片（原始背景图片：100px*100px）
                .box{background-size:50px 50px}
                    background-size：长度
                        长度若只写一个，肯定是宽度，高度等比例缩放
                    background-size：百分比
                        百分比是相对于父盒子来说的，若只写一个，肯定是宽度，高度等比例缩放
                    background-size：cover
                                    § cover也是等比例拉伸 只要父盒子宽和高有一个没有完全被覆盖住，就一直拉伸。要完全覆盖父盒子，可能有一部分图片显示不全

                    background-size：contain
                                    § contain当高度或者宽度任一铺满父盒子就不再进行拉伸，可能父盒子会有留白

## 移动端开发选择
    单独制作移动端页面（主流）
        布局方式（pc端使用需要考虑兼容性问题）
            实现网页宽度随着设备宽度变化
                流式布局/百分比布局
                    将容器盒子的宽度划分成视口的百分比
                flex布局/弹性布局
                    特点
                        给父亲添加flex属性，里面的孩子不论是块级元素还是行内元素都可以设置宽度和高度
                        当给父元素添加flex属性，子元素的float、clear以及vertical-align都将失效
                        采用flex布局的元素，称为flex容器，简称“容器”。他的所有子元素自动成为容器成员，称为flex项目，简称“项目”，项目可以横向排列也可以纵向排列。

                        flex布局不会出现外边距合并的问题
                    写法：display：flex；
                    flex常见的父项属性
                        flex-direction：设置主轴方向（所有子元素横着还是竖着排列）
                            flex-direction：row（子元素横向排列，从左到右【默认】）
                            flex-direction：row-reverse（子元素横向排列，从右到左【顺序颠倒】）
                            flex-direction：column（子元素纵向排列，从上到下）
                            flex-direction：column-reverse（子元素纵向排列，从下到上【顺序颠倒】）
                        flex-wrap：设置子元素是否换行
                            flex-wrap：nowrap（不换行）
                            flex-wrap：wrap（换行）
                        justify-content：设置主轴子元素的排列方式
                            flex-start：默认值 从头部开始 如果主轴是x轴，则从左到右
                            flex-end：从尾部开始排列
                            center：主轴居中对齐
                            space-around：平分剩余空间
                            space-around：两边先贴边，后平分剩余空间
                        align-items：设置侧轴子元素的的排列方式（单行）
                            flex-start：从上到下
                            flex-end：从下到上
                            center：垂直居中
                            stretch：（默认值）拉伸
                        align-content：设置侧轴子元素的排列方式（多行）
                            flex-start：从上到下
                            flex-end：从下到上
                            center：侧轴居中
                            space-around：平分剩余空间
                            space-between：先贴两边，再平分剩余空间
                            stretch：设置子项元素高度平分父元素高度
                    flex常见子项属性
                        flex：flex属性定义子项目分配剩余空间，用flex来表示占多少份数。number还可以写百分比，百分比是相对于父亲来说的。

                        align-self：控制子项自己在侧轴上的排列方式
                            align-self属性允许单个项目与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch
                        order：定义项目的排列顺序
                                    数值越小，排列越靠前，默认为0.注意：和z-index不一样。

元素大小（宽度、高度）随着屏幕自适应变化
        less+rem+媒体查询（flexible.js)
        先引入flexible.js(底层原理：媒体查询，根据不同的设备宽度规定不同的根字号):将根字号转换为视口宽度的1/10
        看设计稿的宽度，若为iphone/6/7/8，则视口宽度为375px，那么根字号为视口的1/10，即为37.5，若在375px的屏幕宽度下有一个元素为60px*60px，那么换算成rem单位就是（60/37.5rem)*(60/37.5rem)
        less+vw/vh
    vw：视口宽度的1/100
    看设计稿的宽度，若为iphone/6/7/8，则视口宽度为375px，那么vw=1/100 * 375px，即为3.75，若在375px的屏幕宽度下有一个元素为60px*60px，那么换算成vw单位就是（60/3.75vw)*(60/3.75vw)
    vh:视口高度的1/100
    看设计稿的高度，若为iphone/6/7/8，则视口宽度为667px，那么vwh=1/100 * 667px，即为6.67，若在667px的屏幕高度下有一个元素为60px*60px，那么换算成vh单位就是（60/6.67vh)*(60/6.67vh)
    响应式页面兼容移动端（其次）
        实现原理：媒体查询
        使用框架：bootstrarp
            引入bootstrarp样式
            根据布局类名container来实现页面宽度的自适应
            根据栅栏系统实现元素的布局个数
                        
                        
                        
